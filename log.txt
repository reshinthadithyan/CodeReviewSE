LOG

SUBMITTED

Plain: 25 Mod: 16 Mask: 16 (maxSize = 512)
Plain: 25 Mod

PRE

Your results do seem odd, so I tried to rewrite your test and see if I can get different results.  I suspected that you might be starting and stopping the stopwatch too frequently, which can skew your results due to the loss of precision every time you start and stop.  In my code, I only start and stop the stopwatch once per type of calculation.

Using the code below, I get results more in line with what you would expect, namely that masking is the fastest, followed by plain subtraction, followed by modulo division.

Here is a typical output from one of my test runs:

MID

Plain: 59.7033
Mod: 64.6872
Mask: 58.1923


POST

In various runs, Plain and Mask tend to vary with respect to each other, and sometimes show very similar numbers.  Mod always tends to be slower.

And here is the code:

SUBMITTED

src != null

PRE

MID

null

POST

SUBMITTED

include&lt;stdafx.h&gt;
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string&gt;
#include&lt;iostream&gt;
using namespace std;
string temp[10];
void extract

PRE

MID

#include&lt;stdafx.h&gt;
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;


POST

The correct way to include C header files in C++ is to use <code>#include &lt;cheadername&gt;</code>, not <code>#include &lt;headername.h&gt;</code>. Further you should avoid C-functions when there are good C++ alternatives and you should generally not mix C's stdio with C++'s iostream. In this particular program I do not believe you need any of the C headers you include.

SUBMITTED

var objectiveIds = new List&lt;int&gt;();
objectiveIds.AddRange(GetObjectiveIds(objectiveName, false));

var q =
    from up in MetaData.UserProfile
    select new RankingDTO
    {
        UserId = up.UserID,
        FirstName = up.FirstName,
        LastName = up.LastName,
        LastWinnerDate = (
            from winner in MetaData.Winner
            where objectiveIds.Contains(winner.ObjectiveID)
            where winner.Active
            where winner.UserID == up.UserID
            orderby winner.CreatedOn descending
            select winner.CreatedOn).First(),
        WinnerCount = (
            from winner in MetaData.Winner
            where objectiveIds.Contains(winner.ObjectiveID)
            where winner.Active
            where winner.UserID == up.UserID
            orderby winner.CreatedOn descending
            select winner).Count(),
        Video1 = (
            from winner in MetaData.Winner
            join o in MetaData.Objective on winner.ObjectiveID equals o.ObjectiveID
            where o.ObjectiveNm == Constants.Promotions.SecVideo1
            where winner.Active
            where winner.UserID == up.UserID
            select winner).Count(),
        Quiz1 = (
            from winner2 in MetaData.Winner
            join o2 in MetaData.Objective on winner2.ObjectiveID equals o2.ObjectiveID
            where o2.ObjectiveNm == Constants.Promotions.SecQuiz1
            where winner2.Active
            where winner2.UserID == up.UserID
            select winner2).Count

PRE

That means you can refactor this where condition to a join in the containing query.

Also, you specify an <code>order by</code> clause, when you are only using the values to get the <code>Count()</code>.  This does nothing but take up space and time.

I think <strong>this query</strong> might be more along the line of what you are trying to achieve:

MID

        var rankingDtos = 
                    from user in MetaData.UserProfile
                    let userWinners = from winner in MetaData.Winner
                                      let objectives = from objective in MetaData.Objective
                                                       where winner.ObjectiveID == objective.ObjectiveID
                                                       select objective
                                      where winner.UserID == user.UserID &amp;&amp; winner.Active
                                      orderby winner.CreatedOn descending
                                      select new
                                                 {
                                                     Winner = winner,
                                                     Objectives = objectives
                                                 }
                    select new RankingDTO
                               {
                                   UserId = user.UserID,
                                   FirstName = user.FirstName,
                                   LastName = user.LastName,
                                   LastWinnerDate = userWinners.First().Winner.CreatedOn,
                                   WinnerCount = userWinners.Count(x =&gt; objectiveIds.Contains(x.Winner.ObjectiveID)),
                                   Video1 = userWinners.Count(x =&gt; x.Objectives.Any(o =&gt; o.ObjectiveNm == Constants.Promotions.SecVideo1)),
                                   Quiz1 = userWinners.Count(x =&gt; x.Objectives.Any(o =&gt; o.ObjectiveNm == Constants.Promotions.SecQuiz1))
                               };


POST

SUBMITTED

struct node

PRE

In your <code>findKthInOrder</code> helper function, the <code>k</code> argument is never actually used, and can be dropped as well.

A couple cleanups on the side:

MID

node

POST

SUBMITTED

function table($columns,$reverse=false,$fill=false,array $attr=null){
    $c = '';
    //ugly hack, looking for fix
    $max=sizeof(max($columns));
    for($i=0;$i&lt;sizeof($columns);$i++){
            $column = $columns[$i];

        if($fill==true){
            $l = ($max-sizeof($column));
            for($ii=0;$ii&lt;$l;$ii++){
                array_push($column,'');
            }
        }
        if($reverse==true){
            $columns[$i] = array_reverse($column);
        }else{
            $columns[$i] = $column;
        }
    }
    for($i=0,$l=sizeof($columns);$i&lt;$l;$i++){
        $column = $columns[$i];
        $c.="&lt;tr&gt;";
        for($ii=0,$ll=sizeof($column);$ii&lt;$ll;$ii++){
            $c.="&lt;td&gt;".$column[$ii]."&lt;/td&gt;";
        }
        $c.="&lt;/tr&gt;";
    }
    return "&lt;table".html::attributes($attr)."&gt;".$c."&lt;/table&gt

PRE

Didn't test, but I would write it something like this:

MID

function table($rows, $reverse = false, $fill = false, array $attr = null) {
    $c = '';
    $max_cols = sizeof(max($columns));

    foreach ($rows as $columns) {
        if ($fill &amp;&amp; sizeof($columns) &lt; $max_cols) {
            $columns = array_merge($columns, array_fill(0, $max_cols - sizeof($columns), ''));
        }
        if ($reverse) {
            $columns = array_reverse($columns);
        }
        $c .= '&lt;tr&gt;&lt;td&gt;' . implode('&lt;/td&gt;&lt;td&gt;', $columns) . '&lt;/td&gt;&lt;/tr&gt;';
    }

    return '&lt;table&gt;' . $c . '&lt;/table&gt;';
}


POST

SUBMITTED

if (SetLiveStatusEvent != null)
                {
                    SetLiveStatusEvent(this, new SetLiveStatusEventArgs(hostname, message

PRE

<H2>Thread safety stuff.</H2>

<H3>Raising events</H3>

This is not thread safe:

MID

if (SetLiveStatusEvent != null)
{
    SetLiveStatusEvent(this, new SetLiveStatusEventArgs(hostname, message));
}


The value of SetLiveStatusEvent could change after the check for null, but before you invoke it. This not an issue in the example code you posted, but would be in a more complex system. Try something like this instead:

var handler = SetLiveStatusEvent;
if (handler != null)
{
    handler(this, new SetLiveStatusEventArgs(hostname, message));
}


POST

When you are writing your event listeners, keep in mind that there is it possibility that they will be invoked after they have been unsubscribed from the event.

<H3>Use of Queue class with manual synchronization</H3>
I don't see any problems with how you interact with the Queue, but in .Net 4.0 there is the System.Collection.Concurrent.BlockingCollection class that will take care of all of the synchronization logic for you.

<H2>Other stuff</H2>

<H3>Explicit delegate creation</H3>

You don't need to create a new instance of a delegate.

SUBMITTED

start+1
            if num_sentence == 2:
                flag

PRE

If you must count, you must use a for loop! Also don't use 1 for <code>True</code>. I'm also very suspicous of boolean flags. I think they are delayed gotos. 

MID

        if flag == 1:


Use <code>if flag:</code>

            Snippet_Begin = start + 1
        elif flag == 0:


POST

If the flag can only <code>True</code> or <code>False</code> just use <code>else</code>

SUBMITTED

root=NULL;
static int count=0;
struct node *create_node(int);//function to create node
void travel_list(void);
void create_list(int);
void reverse_list(void);
int main()
{
    int i, j, choice;
    printf("Enter a number this will be root of tree\n");
    scanf("%d", &amp;i);
    create_list(i);
    printf

PRE

Don't store data in global variables. It makes your code unreusable and harder to follow.

MID

struct node *create_node(int);//function to create node
void travel_list(void);
void create_list(int);
void reverse_list(void);
int main()
{
    int i, j, choice;


POST

Using variables like i and j only make sense if used in the sense of indexes. Otherwise, the code just gets harder to read. Choice is also not very informative.

SUBMITTED

_previousMaterial               : null

PRE

MID

null

POST

<strong><code>removeComponentWithName</code></strong>

This code confuses me.  It seems built with multiple instances of the same component in mind, but then it <code>breaks</code> out the <code>for</code> loop. It seems you could write this code with 1 loop.

You can merge the 2 loops here in to 1 loop:

SUBMITTED

here

    IQueryable

PRE

By reviewing this I have two general comments to your code:

Is there any reason to use explicit transaction scope? When you call <code>SaveChanges</code> on the context it already uses transaction. It either uses ambient transaction or create a new one database transaction. So unless you are using multiple transactional resources (multiple database connections, MSMQ, etc.) or calling <code>SaveChanges</code> multiple times you don't need to create transaction explicitly. It is point of unit of work to save changes as one atomic unit. Also one side note: Default transaction used in SaveChanges uses default (or current) isolation level configured on database connection. Default for SQL Server is <code>ReadCommitted</code>. Default isolation level for <code>TransactionScope</code> is <code>Serializable</code>.

You mentioned that you want to make this abstraction to be able to replace context for testing. If you mean unit testing you can stop and go back to redesign your interfaces. You cannot unit test your business layer code if it uses <code>IQueryable</code> (Linq-to-entities) exposed by your data access layer. There is currently no provider which can simulate linq-to-entities behaviour for your unit tests. Once you use same in memory collection to mock <code>IQueryable</code> you will use linq-to-objects in your unit tests instead. That means you will test different code. 

The only correct way is either:

MID

IQueryable

POST

SUBMITTED

g_prizes_won = {}       # Format: {'3':3, '3+1':2, '4':2 ...}
g_quick_pick_file = ''
g_how_many_tickets_played = 0
g_how_many_tickets_won = 0


class TicketNumbers( object ):
  '''Represents the numbers of a ticket (or the 7 winning numbers).
  @var numbers: A sorted array of 7 unique numbers from 1-49.'''

  def __init__( self, numbers ):
    '''Constructor.
    @param numbers: The numbers for this ticket.'''

    self.numbers = numbers
    self._set_numbers

PRE

In Python, it is recommended not have global variables. I usually only put constants at the global level, and according to python style guide they should be written WITH_ALL_CAPS. I'd move all of this data into some sort of object.

MID

class TicketNumbers( object ):
    '''Represents the numbers of a ticket (or the 7 winning numbers).
    @var numbers: A sorted array of 7 unique numbers from 1-49.'''


Considering the fact that you later sort the number, why do specify that it should be sorted on input?

    def __init__( self, numbers ):
        '''Constructor.
        @param numbers: The numbers for this ticket.'''

        self.numbers = numbers


You assign to numbers here, but _set_numbers also assigns to it. This one is pointless.

        self._set_numbers( numbers )

    def name( self ):
        '''Return the name of this class type.'''
        return "TicketNumbers"


POST

What's the point of this? If you want the name of the class use <code>obj.__class__.__name__</code>

SUBMITTED

true);
        progressBar.setIndeterminate(true);

        SwingWorker&lt;Void, File&gt; worker = new SwingWorker&lt;Void, File&gt;() {
            @Override
            public Void doInBackground() {
                File file = (File) node.getUserObject();
                if (file.isDirectory()) {
                    File[] files = fileSystemView.getFiles(file, true); //!!
                    if (node.isLeaf()) {
                        for (File child : files) {
                            if (child.isDirectory()) {
                                publish(child);
                            }
                        }
                    }
                    setTableData(files);
                }
                return null;
            }

            @Override
            protected void process(List&lt;File&gt; chunks) {
                for (File child : chunks) {
                    node.add(new DefaultMutableTreeNode(child));
                }
            }

            @Override
            protected void done() {
                progressBar.setIndeterminate(false);
                progressBar.setVisible(false);
                tree.setEnabled(true);
            }
        };
        worker.execute();
    }

    /** Update the File details view with the details of this File. */
    private void setFileDetails(File file) {
        currentFile = file;
        Icon icon = fileSystemView.getSystemIcon(file);
        fileName.setIcon(icon);
        fileName.setText(fileSystemView.getSystemDisplayName(file));
        path.setText(file.getPath());
        date.setText(new Date

PRE

This code concerns me:

MID

  SwingWorker worker = new SwingWorker() {
     @Override
     public String doInBackground() {
        tree.setEnabled(false);
        progressBar.setVisible(true);
        progressBar.setIndeterminate(true);
        File file = (File) node.getUserObject();
        if (file.isDirectory()) {
           File[] files = fileSystemView.getFiles(file, true);
           if (node.isLeaf()) {
              for (File child : files) {
                 if (child.isDirectory()) {
                    node.add(new DefaultMutableTreeNode(child));
                 }
              }
           }
           setTableData(files);
        }
        progressBar.setIndeterminate(false);
        progressBar.setVisible(false);
        tree.setEnabled(true);
        return "done";
     }
  };
  worker.execute();


as you're making Swing calls to a JProgressBar off of the EDT.  Best to start the progress bar before the SwingWorker and end it in the done method. Either that or add a PropertyChangeListener to the SwingWorker and end the progress bar when the worker's state property is StateValue.DONE.

Another issue is that you're using a DefaultMutableTreeNode, and per the API, concurrency care must be taken when using this since you do appear to be using this in more than one thread:

This is not a thread safe class.If you intend to use a DefaultMutableTreeNode (or a tree of TreeNodes) in more than one thread, you need to do your own synchronizing. A good convention to adopt is synchronizing on the root node of a tree.

<strong>EDIT</strong><br>
One way to <em>possibly</em> get DefaultMutableTreeNode at least out of the equation is to add nodes to it in one thread only, the EDT, by using SwingWorker's publish/process.  For example:

   private void showChildren(final DefaultMutableTreeNode node) {
      tree.setEnabled(false);
      progressBar.setVisible(true);
      progressBar.setIndeterminate(true);

      SwingWorker&lt;Void, File&gt; worker = new SwingWorker&lt;Void, File&gt;() {
         @Override
         public Void doInBackground() {
            File file = (File) node.getUserObject();
            if (file.isDirectory()) {
               File[] files = fileSystemView.getFiles(file, true); //!!
               if (node.isLeaf()) {
                  for (File child : files) {
                     if (child.isDirectory()) {
                        publish(child);
                     }
                  }
               }
               setTableData(files);
            }
            return null;
         }

         @Override 
         protected void process(List&lt;File&gt; chunks) {
            for (File child : chunks) {
               node.add(new DefaultMutableTreeNode(child));
            }
         }

         @Override
         protected void done() {
            progressBar.setIndeterminate(false);
            progressBar.setVisible(false);
            tree.setEnabled(true);
         }
      };
      worker.execute();
   }


POST

SUBMITTED

c = 0
    passa = 0
    passb = 0
    passc = 0
    a = random.randrange(a, asciiValue)
    b

PRE

And here as well

MID

    a = random.randrange(a, asciiValue)


Ok, why did you assign zero to a earlier rather then just putting 0 as the argument here

    b = random.randrange(b, asciiValue - a)


Same here

    c = asciiValue - (a+b)
    passa = random.randrange(passa, password)
    passb = random.randrange(passb, password-passa)
    passc = password - (passa+passb)


POST

And again here, the earlier assignments seemed to have no purpose. Additionally, the same logic was applied to both asciiValue and password. Make a function that produces the a,b,c from the input and call it for each of those values instead.

SUBMITTED

BigInteger)Math.Sqrt(247457076132467-1))+1, 
               mod = 247457076132467;
    Dictionary&lt;int, BigInteger&gt; b

PRE

MID

Dictionary&lt;int, BigInteger&gt;

Dictionary&lt;BigInteger, int&gt;

POST

SUBMITTED

our_version)
    except:
        raise

def deRegisterPy(pycore_regpath, version):
    ''' remove

PRE

What??? the try..except does nothing if you just raise the error right away

MID

def deRegisterPy(pycore_regpath, version):


POST

Python style guide recommends lower_case_with_underscores for functions names

SUBMITTED

int.TryParse

PRE

MID

TryParse

TryParse

Error handling

TryParse

POST

SUBMITTED

if country and city and city_name and city_name != '':
    return City.get_or_insert('i'+str(city), city_name=city_name, parent=country)
  else:
    return None

PRE

As before, empty strings are false, so you are checking that twice

MID

    return City.get_or_insert('i'+str(city), city_name=city_name, parent=country)
  else:
    return None


POST

SUBMITTED

Stream&amp; stream )
            {
                std::locale const  utf8Locale( stream.getloc(), new CodecUtf8() );
                stream.imbue( utf8Locale );
                return stream;
            }

        public:
            static IStream&amp; inStream()
            {
                static IStream&amp; stream = withUtf8Conversion

PRE

Prefer to use normal include guards.

You are imbuing streams here:

MID

            std::locale const  utf8Locale( stream.getloc(), new CodecUtf8() );
            stream.imbue( utf8Locale );
            return stream;


POST

The only problem I see with this is that after you have started using the stream any attempt to imbue can silently fail (or it used too they may have fixed that in C++11). 

Now I assume you are trying to force this initialization before use with:

SUBMITTED

Delta0 = test[i][21] - OutNeuron[0]
        Delta1 = test[i][22] - OutNeuron[1]
        Delta2 = test[i][23] - OutNeuron[2]
        UpdateDelta()
        UpdateInWeights()    
        UpdateHiddenWeights()
    if Iterations % 1000 == 0:
        PercentComplete = Iterations / 1000
        print("Learning " + str(PercentComplete) + "% Complete

PRE

:(

MID

        UpdateDelta()
        UpdateInWeights()    
        UpdateHiddenWeights()
    if Iterations % 1000 == 0:
        PercentComplete = Iterations / 1000
        print("Learning " + str(PercentComplete) + "% Complete")


POST

Print automatically stringify's things. You shouldn't need to call str here

SUBMITTED

isdigit(s[j]); ++j) {
            eval = 10 * eval + (s[j] - '0');
        }
        fprintf(stdout, "eval = %d\n", eval);
        int l;
        for (l = 0; l &lt; eval; l++) {
            (esign &gt;= 0) ? (rtn *= 10) : (rtn /= 10);
        }
    }

    // Finally return the solution
    return rtn

PRE

I note that this is pretty much the same as a previous block of code. Consider extracting the common bits into a function:

MID

        fprintf(stdout, "eval = %d\n", eval);
        int l;
        for (l = 0; l &lt; eval; l++) {
            (esign &gt;= 0) ? (rtn *= 10) : (rtn /= 10);
        }


POST

I suspect using a <code>pow()</code> function would be more fruitful.

SUBMITTED

player.play()
screen = curses.initscr()
curses

PRE

For anything but a quick script, its recommended that you put your code inside a main function.

MID

screen = curses.initscr()


POST

I recommend that you take a look at the curses.wrapper function. It'll take care of closing curses correctly in the case of an error.

SUBMITTED

arrays
trace("Testing Array of Arrays random assignment performance:");
startTime = getTimer();
for(i = 0; i &lt; 100000; ++i) {
    randomIndex = Math.round(Math.random() * 99999) as uint;
    arrayOfArrays[randomIndex] = testArrays[randomIndex];
}
trace("Total time for 100000 random

PRE

is a quite slow operator compared to Array access. In this case: 

MID

for(i = 0; i &lt; 100000; ++i) {
    randomIndex = Math.round(Math.random() * 99999) as uint;
    arrayOfArrays[randomIndex] = testArrays[randomIndex];
}


POST

i think you'll measure the speed to the Math class, not array assignment speed. (same holds for other examples, where you use do lots of Math calls.) To test random assignment speed, i'd first populate an array with random elements.

SUBMITTED

datetimeformat_jinja(value

PRE

MID

value

POST

SUBMITTED

rightStick;
    Timer timer;

    // Motor ports (hardware)
    static const UINT32 kLeftFrontMotor = kPWMPort_1;
    static const UINT32 kRightFrontMotor = kPWMPort_2;
    static const UINT32 kLeftBackMotor = kPWMPort_3;
    static const UINT32 kRightBackMotor = kPWMPort_4;

    // Joystick ports (hardware)
    static const UINT32 kRightJoystickPort = kUSBPort_1;
    static const UINT32 kLeftJoystickPort = kUSBPort_2;

    // Delay to prevent spamming motors with input

PRE

There is no need declare these as static (unless you want to get the address or something) so just use enum:

MID

// Motor ports (hardware)
static const UINT32 kLeftFrontMotor = kPWMPort_1;
static const UINT32 kRightFrontMotor = kPWMPort_2;
static const UINT32 kLeftBackMotor = kPWMPort_3;
static const UINT32 kRightBackMotor = kPWMPort_4;


Prefer:

enum { kLeftFrontMotor = kPWMPort_1, kRightFrontMotor = kPWMPort_2, kLeftBackMotor = kPWMPort_3, kRightBackMotor = kPWMPort_4};


POST

No need to explicitly return from a constructor:

SUBMITTED

gt;) listOfSources

PRE

MID

listOfSources

POST

SUBMITTED

private final String contents;
  private final long id;
  // whether document has been allocated to a cluster
  private boolean allocated;
  // document word histogram

PRE

Since they are inside the <code>Document</code> class, it's obvious that the <code>title</code> is a title of a document, and so on.

MID

// whether document has been allocated to a cluster
private boolean allocated;


POST

Here I'd rename the variable to <code>allocatedToCluster</code> and remove the comment. It would make the code more readable since you don't have to check the declaration to figure out what it is allocated to.

For the same reason as above,

SUBMITTED

b");

   printf("\nChoose size(S,M,L):");
   scanf("%c",&amp;switch_size);
   buff_clr();

      switch(switch_size)
   {
       case 's':
       case 'S':n=3;break;
       case 'm':
       case 'M':n=5;break;
       case 'l':
       case 'L':n=8;break;
       default:printf("\nYou've choosen poorly!");
               getch();
               exit(EXIT_FAILURE);
   }

   printf("\nChoose difficulty(E,H):");
   scanf("%c",&amp;switch_difficulty);
   buff_clr();

   switch(switch_difficulty)
   {
       case 'e':
       case 'E':difficulty=(n*2)-2;break;
       case 'h':
       case 'H':difficulty=(n/2);break;
       default:printf("\nYou've choosen poorly!");
               getch();
               exit(EXIT_FAILURE);
   }

   ships=(int**)malloc(n*sizeof(int*));

   for(i=0;i&lt;n;i++)
   {
       ships[i]=(int*)malloc(n*sizeof(int));
   }

   pseudo_gui=(char**)malloc((n+1)*sizeof(char*));

   for(i=0;i&lt;(n+1);i++)
   {
       pseudo_gui[i]=(char*)malloc((n+1)*sizeof(char));
   }

   shipcount=randgen(ships,n);

   printf("\n\nNumber of ships to be sunk:%d",shipcount);
   printf("\nNumber of misses allowed: %d\n\n",difficulty);

   draw_gui(pseudo_gui,n);
   result(pseudo_gui,n);

   while(shipcount!=0 &amp;&amp; x_count!=difficulty)
   {

   printf("\nEnter coordinates (x,y):");
   scanf("%d,%d",&amp;coords.x,&amp;coords.y);
   buff_clr();

   system("cls");

   battle(ships,pseudo_gui,n,coords,&amp;shipcount,&amp;x_count);
   result(pseudo_gui,n);

   printf("Number of ships to be sunk:%d",shipcount);
   printf("\nNumber of misses(out of %d): %d\n\n",difficulty,x_count);

   }
   if(shipcount==0)
   {
       printf("\nWinner!\n\n");
       getch();
   }
   else if(x_count==difficulty)
   {
       printf("\nYou Lose!\n\n");
       getch();
   }


  return

PRE

:P

MID

               getch();
               exit(EXIT_FAILURE);
   }

   printf("\nChoose difficulty(E,H):");
   scanf("%c",&amp;switch_difficulty);
   buff_clr();

   switch(switch_difficulty)
   {
       case 'e':
       case 'E':difficulty=(n*2)-2;break;
       case 'h':
       case 'H':difficulty=(n/2);break;
       default:printf("\nYou've choosen poorly!");
               getch();
               exit(EXIT_FAILURE);
   }

   ships=(int**)malloc(n*sizeof(int*));

   for(i=0;i&lt;n;i++)
   {
       ships[i]=(int*)malloc(n*sizeof(int));
   }

   pseudo_gui=(char**)malloc((n+1)*sizeof(char*));

   for(i=0;i&lt;(n+1);i++)
   {
       pseudo_gui[i]=(char*)malloc((n+1)*sizeof(char));
   }

   shipcount=randgen(ships,n);

   printf("\n\nNumber of ships to be sunk:%d",shipcount);
   printf("\nNumber of misses allowed: %d\n\n",difficulty);

   draw_gui(pseudo_gui,n);
   result(pseudo_gui,n);

   while(shipcount!=0 &amp;&amp; x_count!=difficulty)
   {

   printf("\nEnter coordinates (x,y):");
   scanf("%d,%d",&amp;coords.x,&amp;coords.y);
   buff_clr();


Make you indent consistently!

   system("cls");

   battle(ships,pseudo_gui,n,coords,&amp;shipcount,&amp;x_count);
   result(pseudo_gui,n);

   printf("Number of ships to be sunk:%d",shipcount);
   printf("\nNumber of misses(out of %d): %d\n\n",difficulty,x_count);

   }
   if(shipcount==0)
   {
       printf("\nWinner!\n\n");
       getch();
   }
   else if(x_count==difficulty)
   {
       printf("\nYou Lose!\n\n");
       getch();
   }


  return 0;
}


POST

Overall pretty good. The only really crazy thing is the for-for-if. 

Also what would be the most optimal way of solving wrong input when it comes to size and difficulty? I first made the default in
  switch request the input again but the problem is that it only
  requests twice(once for the initial request and 2nd time in the
  default) so tried to add a do-while function for scanfs but it seems i
  can't have more than one condition(i tried adding multiple checks if
  input is != to the letter).

Some sort of while loop is the way to go. I'm not sure exactly where you had trouble. You may want to consider asking that as a question on Stackoverflow.

Also could you help me pitch some ideas how i could add longer ships which would span over 2 tiles since i'm using a random
  generator. I know i can check for 1's and then add a code to put a 1
  in (i+n) which would make a vertical ship spanning 2 tiles and for
  horizontal(i+1, i-1) but i would need some checks(i'm thinking of
  adding a few if's to check if i'm on n tile) to see if the 1 is by the
  'edge'. However would that work and is it the most efficient method?
  If not give me an idea.

I'd suggest you add a function like:

SUBMITTED

createDiv(),
        $pictureFrame

PRE

MID

pictureFrame

POST

SUBMITTED

def level(self):
    startdate = model.Order.all().filter('status =', 'PAID'
            ).filter('distributor_id =',
                     self._key.id()).get().created.date()
    last_day_nextmonth = startdate + relativedelta(months=2) \
        - timedelta(days=1)
    total = self.personal_silver(startdate, last_day_nextmonth) + self.non_manager_silver(startdate, last_day_nextmonth)
    if total &gt;= 125:
        level = 5
    elif total &gt;= 75:
        level = 4
    elif total &gt;= 25:
        level = 3
    elif total &gt

PRE

MID

def level(self):
    startdate = model.Order.all().filter('status =', 'PAID'
            ).filter('distributor_id =',
                     self._key.id()).get().created.date()
    last_day_nextmonth = startdate + relativedelta(months=2) \
        - timedelta(days=1)


Continuing lines with <code>\</code> is generally frowned upon. Either split it onto multiple lines or wrap the expression with parenthesis

    total = self.personal_silver(startdate, last_day_nextmonth) + self.non_manager_silver(startdate, last_day_nextmonth)


POST

I think writing a self.silver(start_date, end_date) function would make sense to get the sum of those two.

SUBMITTED

ValueError:
                print 'Invalid input...'
            else:
                if input_name &gt;= min_num and input_name &lt;= max_num:
                    return input_name
                    break
                input_name = 'Please

PRE

Consider putting a <code>continue</code> here, for clarity. It isn't necessary, though.

MID

            else:
                if input_name &gt;= min_num and input_name &lt;= max_num:


POST

Python understands <code>if min_num &lt;= input_name &lt;= max_num:</code>

SUBMITTED

current tty.
    """

    while True

PRE

To know more, take a look at <a href="http://www.python.org/dev/peps/pep-0257/#multi-line-docstrings" rel="nofollow noreferrer">PEP257</a> about multi line docstrings.

There's also no need to repeat the function declaration inside your docstring. If you tomorrow decide to use <a href="http://sphinx.pocoo.org/" rel="nofollow noreferrer">Sphinx</a> for generating your code documentation, that part will be taken care of on its own. You can find other possible conventions on docstrings <a href="http://packages.python.org/an_example_pypi_project/sphinx.html#function-definitions" rel="nofollow noreferrer">here</a>.

Replace this:

MID

while True:
    # ...


with:

while 1:
    # ...


POST

This will do a tiny difference in Python 2 (in Python 3 they will be exactly the same). This topic was well discussed on SO <a href="https://stackoverflow.com/q/3815359/1132524">here</a>.

This line:

SUBMITTED

user.field_names.index(field_name)
        field_values[field_index] = field_value
        field_scores[field_index] = field_score
    else:
        field_names

PRE

Use index to check if field_name is present. That way it doesn't have to search through the lists twice.

MID

        field_values[field_index] = field_value
        field_scores[field_index] = field_score


If possible, avoid maintaing parrallel lists. In this case, it looks like maybe you should have a dictionary of strings to tuples.

    else:
        field_names.append(field_name)
        field_values.append(field_value)
        field_scores.append(field_score)
    user.field_names = field_names
    user.field_values = field_values 
    user.field_scores = field_scores


POST

Unless user does something odd, this has no effect. Assignment doesn't copy in python, it just copies the references. 

SUBMITTED

get',
      success

PRE

MID

success

POST

The way you're building your html string is dangerous.  It's also hard to read and easy to get wrong.

As Philip suggested, using some sort of template would be a good idea, but there's no way to do this in standard jQuery (<a href="http://api.jquery.com/category/plugins/templates/" rel="nofollow">jQuery templates</a> have been deprecated, and the way forward seems to be <a href="https://github.com/BorisMoore/jsrender" rel="nofollow">JsRender</a> which is not yet Beta). Fortunately, your code is not big enough for you to need that. Instead, use <code>attr()</code>, <code>text()</code> and <code>addClass()</code> wisely:

SUBMITTED

static void Main()
{         
    int T = Convert.ToInt32(Console.ReadLine());
    for (int k = 0; k &lt; T; k++)
    {
        string[] split = (Console.ReadLine()).Split(new Char[] { ' ' });
        int N = Convert.ToInt32(split[0]);
        double K = 0;
        string Kst = split[1];
        double POST = 0;

        for (int i = 0; i &lt; N - 1; i++)
        {
            for (int j = 0; j &lt;= Kst.Length - 1; j++)
            {
                int Kindex = int.Parse(Convert.ToString(Kst[j]));
                K = K + Kindex*Kindex*Kindex;
            }
           POST = K; 
            Kst = Convert.ToString(K);
            K = 0;
        }
        Console.WriteLine(POST - Convert.ToDouble(split

PRE

Here are a few tips:

Instead of getting each character, creating a new string from it, and then parse the string into a number, just get the character and convert the character code into the number.

Alternatively, parse the whole number once, then get the digits numerically using modulo.

There are only ten digits, so you can easily set up an array of precalculated cube values.

<code>K</code> is a double, but there are no floating point operations here. Use an <code>int</code>, or a <code>long</code> if needed.

Example:

MID

int T = Convert.ToInt32(Console.ReadLine());
int[] cube = { 0, 1, 4, 9, 16, 25, 36, 49, 64, 81 };
for (int k = 0; k &lt; T; k++) {
  string[] split = Console.ReadLine().Split(' ');
  int N = Convert.ToInt32(split[0]);
  int Kst = Convert.ToInt32(split[1]);
  int K = 0;
  for (int i = 0; i &lt; N - 1; i++) {
    K = 0;
    while (Kst &gt; 0) {
      K += cube[Kst % 10];
      Kst /= 10;
    }
    Kst = K;
  }
  Console.WriteLine(K - Convert.ToInt32(split[2]));
}


POST

SUBMITTED

n ts

PRE

(Then it'd make sense to refactor the type of <code>extend</code> to get rid of the <code>flip</code>.)

Some questions:

MID

ts

POST

SUBMITTED

c))
    return d

PRE

Yeah this whole block is a mess. Two notes:

call <code>elementtree_to_dict</code> once

MID

return d


POST

This whole piece of code looks like a bad idea. 

SUBMITTED

static Vector

PRE

MID

Vector

Vector

POST

SUBMITTED

push(stk.top() * seq[x - 1]);
      que.push(que.back() * seq[y + 1]);
    }
  }
  for (int x = 0; x &lt; N; ++x) {
    std::cout &lt;&lt; (stk.top() * que.front()) &lt;&lt; std::endl;
    stk.pop();
    que.pop

PRE

to get:

MID

  stk.push(1);
  que.push(1);
  for (int x = 0, y = N-1; x &lt; N-1; ++x, --y)
  {
    stk.push(stk.top() * seq[x]);
    que.push(que.back() * seq[y]);
  }


POST

and a simpler implementation:

SUBMITTED

this
    .bind

PRE

MID

.bind

POST

So far the resulting code looks something like this (completely untested):

SUBMITTED

if self.step &lt;= 0:
                        raise SyntaxError
                except:
                    print("Error")
            self.start = math.ceil(self.start)
            self.step = math.ceil(self.step)
            self.maximum = math.ceil(self.maximum)
        def shift(self, x):
            """Shifts both the maximum and the start in one function call"""
            try:
                if self.maximum + x &lt; 0 or self.start + x &lt; 0:
                    raise SyntaxError
                self

PRE

What the fried turkey are you trying to do here? The whole function is a complete and total disaster. Do you seriously want this function? Whatever you are trying to do with it, you are doing it wrong.

MID

    def shift(self, x):
        """Shifts both the maximum and the start in one function call"""
        try:
            if self.maximum + x &lt; 0 or self.start + x &lt; 0:
                raise SyntaxError


Raise appropriate errors. Whatever the problem is, its not a SyntaxError.

            self.maximum += x
            self.start += x
            self.maximum, self.start = math.ceil(self.maximum), math.ceil(self.start)
        except:
            print("Error")


NEVER NEVER NEVER NEVER catch errors and just print "Error." Always catch only the specific errors you want to handle, and always provide all the information available about the problem.

    def stretch(self, x):
        """Changes both the maximum and the step in one function call"""
        try:
            if self.maximum + x &lt; 0 or self.step + x &lt; 0:
                raise SyntaxError
            self.maximum += x
            self.step += x
            self.maximum, self.step = math.ceil(self.maximum), math.ceil(self.step)
        except:
            print("Error")


POST

Again, don't do that.

SUBMITTED

var set_data = function(cluster) {
    if (!localStorage.getItem("Page")) {
        if (!localStorage.setItem("Page", JSON.stringify(cluster))) {
            log("Current Page: Stored");
        } else {
            log("Current Page: Store Failed");
        }
    } else {
        localStorage.removeItem("Page");
        if (!localStorage.setItem("Page", JSON.stringify(cluster))) {
            log("Current Page: Stored");
        } else {
            log("Current Page: Store Failed");
        }
    }
}

var get_data = function() {
    if (localStorage.getItem("Page")) {
        var last_page = JSON.parse(localStorage.getItem("Page"))
        log("Last Page: " + last_page);
        return last_page;
    } else {
        log("Last Page: Inexistent");
        return 1;
    }
}

var set_last_page = function(cluster) {
    if (Modernizr.localstorage) {
        var data = cluster;
        set_data(data);
    } else {
        var data = JSON.stringify(cluster);
        create_cookie("Page", data, 365);
    }
}

var get_current_page = function() {
    if (Modernizr.localstorage) {
        var data = get_data();
    } else {
        var data = JSON.parse(read_cookie("Page"));
    }
    return data;
}

var create_cookie = function(name, value, days) {
    var date;
    var expires;

    if (days) {
        date = new Date();
        date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
        expires = "; expires=" + date.toGMTString();
    } else {
        expires = "";
    }
    document.cookie = name

PRE

At the expense of having a little more code, I would use a <a href="https://gist.github.com/2398893/d6327b3ca7b7c50d3f4f784e06bac76cf649fe0f" rel="nofollow">localStorage polyfill</a> <a href="https://developer.mozilla.org/en/DOM/Storage#localStorage" rel="nofollow">[2]</a>.

With that code in place you no longer need to keep the create and read cookie methods. You also don't need the code wrapping <code>get_data</code> and <code>set_data</code>. Your resulting code would look something like this:

MID

set_last_page = function(cluster) {
    if (!localStorage.getItem("Page")) {
        if (!localStorage.setItem("Page", JSON.stringify(cluster))) {
            log("Current Page: Stored");
        } else {
            log("Current Page: Store Failed");
        }
    } else {
        localStorage.removeItem("Page");
        if (!localStorage.setItem("Page", JSON.stringify(cluster))) {
            log("Current Page: Stored");
        } else {
            log("Current Page: Store Failed");
        }
    }
}

get_current_page = function() {
    if (localStorage.getItem("Page")) {
        var last_page = JSON.parse(localStorage.getItem("Page"))
        log("Last Page: " + last_page);
        return last_page;
    } else {
        log("Last Page: Inexistent");
        return 1;
    }
}


POST

From here I would make a few changes:

SUBMITTED

lt;/ul

PRE

MID

ul

POST

SUBMITTED

amp; ((head ys) == '*') = error

PRE

MID

head ys

head

POST

SUBMITTED

n, r

PRE

MID

r

POST

SUBMITTED

Dim objFSO
Set objFSO = CreateObject("Scripting.FileSystemObject")

If (objFSO.FileExists("C:\urlsinfo.xml")) Then
Const ForReading = 1
Const ForWriting = 2
Const ForAppending = 8

Dim textToReplace
Dim textReplacement
textToReplace = "http://www.yahoo.com"
textReplacement = "http://www.google.com"

Set objFile = objFSO.OpenTextFile("C:\urlsinfo.xml", ForReading)
strText = objFile.ReadAll
objFile.Close
strNewText = Replace(strText, textToReplace, textReplacement)

Set objFile = objFSO.OpenTextFile("C:\urlsinfo.xml", ForWriting)
objFile.WriteLine strNewText
objFile.Close
WScript.Quit()

Else
Dim errorFileSys, errorLogTxt

Set errorFileSys = CreateObject("Scripting.FileSystemObject")
Set errorLogTxt = errorFileSys.OpenTextFile("C:\urlsinfoError.log", ForAppending, True) 
errorLogTxt.WriteLine(Now &amp;"     urlsinfo.xml file did not exist in directory C:\. ")
errorLogTxt.Close

WScript.Quit()
End If

'Exit Script
WScript.Quit

PRE

here is what it would look like after all but Items 4 &amp; 5

MID

Dim objFSO : Set objFSO = CreateObject("Scripting.FileSystemObject")
Const ForReading = 1
Const ForWriting = 2
Const ForAppending = 8
Const xmlInput = "C:\urlsinfo.xml"

Dim textToReplace : Set textToReplace = "http://www.yahoo.com"
Dim textReplacement : Set textReplacement = "http://www.google.com"


If (objFSO.FileExists(xmlInput)) Then

    Set objFile = objFSO.OpenTextFile(xmlInput, ForReading)
    strText = objFile.ReadAll
    objFile.Close
    strNewText = Replace(strText, textToReplace, textReplacement)

    Set objFile = objFSO.OpenTextFile(xmlInput, ForWriting)
    objFile.WriteLine strNewText
    objFile.Close
    WScript.Quit()

Else
    Dim errorFileSys : Set errorFileSys = CreateObject("Scripting.FileSystemObject")
    Dim errorLogTxt : Set errorLogTxt = errorFileSys.OpenTextFile("C:\urlsinfoError.log", ForAppending, True) 
    errorLogTxt.WriteLine(Now &amp;"     urlsinfo.xml file did not exist in directory C:\. ")
    errorLogTxt.Close
    WScript.Quit()
End If


POST

This is a little bit cleaner, I think that some Exception Handling could be added in there to make it a little nicer, maybe a <code>Try Catch</code> or the VBScript equivalent. I would also look into using the <code>Using</code> statement style code in VBScript, I know you can do it in VB but not sure about VBScript.

SUBMITTED

mysql_error());

                        echo "Thanks ".$username.", your account has been created!";
                    }
                    else echo"Username Unavailable, please try another

PRE

<strong>userlogin</strong>

This sounds like a logging table to me.  This sounds like it contains records of users logging in, not of actual user records. I would consider renaming this table to something like <code>users</code> or <code>user_accounts</code>.

<strong>escape html where necessary</strong>

MID

echo "Thanks ".$username.", your account has been created!";


POST

Once again, since it's limited to alphanumeric, this is definitely harmless, however, preparing for the future never hurts.  If at some point you allow users to create names that contain <code>&amp;</code>, this could output invalid html.

(Once again, sorry if I'm telling you something you already know.)

<strong>always use brackets</strong>

It's hard to see on a short script with fairly simple logic, but I'm a firm believer that braces should always be used.

SUBMITTED

let getVolumes

PRE

MID

getVolumes

POST

SUBMITTED

uint32_t add(uint32_t a, uint32_t b) {
        return a+b;
    }
}

// Pad the input to a multiple of 512 bits, and add the length
// in binary to the end.
std::string sha256::pad(std::string const &amp

PRE

Also the comment does not accurately reflect what it does:

MID

// Pad the input to a multiple of 512 bits, and add the length
// in binary to the end.


POST

After decoding this I find that you are adding the length to the end. <strong>BUT</strong> the length takes it upto the 512 bit byte boundary. It is not added after the string has been padded.

I assume this:

SUBMITTED

var self = this;
                $.ajax

PRE

<strong>sync related</strong>

MID

self = this

self

POST

<em>showHide</em>

SUBMITTED

int leftbound , int rightbound )
{
    if (rightbound &gt; leftbound

PRE

Though it makes no difference in this situation. There are situations where it can. So it one of those habits you should get into. Then when the types of objects are changed you do not need to search your code to make sure you are using the efficient version you know you used the efficient version automatically.

Your test for a sortable array is not aggressive enough:

MID

if (rightbound &gt; leftbound) {


You only don't sort if the array is zero length. Which may potentially lead to long recursion as you randomly choose a pivot point that always dives stuff to one side (luckily your non standard code below saved you by always leaving the pivot off subsequent sorts).

The real answer is you only need to sort arrays that have a size >= 2. (size zero and one are already sorted).

if ((rightbound - leftbound /* +1 depending on if you rightbound is one past or not*/ ) &gt;= 2)


POST

Small difference from a standard implementation here:<br>
Which can potentially give you an infinite loop.

SUBMITTED

cool";    
if( that.indexOf('hello

PRE

Here is the most seen way:

MID

if ( ~that.indexOf( 'hello' ) ) {
}


POST

The <code>~</code> operator does some magic and transforms only -1 in 0, thus it's the only falsy value.

SUBMITTED

function keyContains

PRE

MID

keyContains

POST

SUBMITTED

start();
            Thread

PRE

MID

Thread

POST

Anyway, it would be much easier, less error-prone and more readable with a fair <a href="http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/Semaphore.html" rel="nofollow noreferrer"><code>Semaphore</code></a> (from the <a href="http://docs.oracle.com/javase/6/docs/technotes/guides/concurrency/overview.html" rel="nofollow noreferrer">concurrency utilities package</a>):

<code>App.java</code>:

SUBMITTED

double[][] seg

PRE

MID

seg

POST

SUBMITTED

lt;?= $field ?&gt;" name="&lt;?= $field ?&gt;" 
    value="&lt;?= isset($_SESSION['form'][$field]) ? $_SESSION['form'][$field] : '' ?&gt;" maxlength="2" /&gt;
  &lt;? if (isset($_SESSION['errors'][$field])) { ?&gt;
    &lt;label class="error" for="&lt;?= $field ?&gt;"&gt;&lt;?= $_SESSION['errors'][$field] ?&gt;&lt;/label&gt;
  &lt;? } ?&gt;

  &lt;? $field = 'email'; ?&gt;
  &lt;label for="&lt;?= $field ?&gt;"&gt;What is your email?&lt;/label&gt;
  &lt;input type="text" id="&lt;?= $field ?&gt;" name="&lt;?= $field ?&gt;" 
    value="&lt;?= isset($_SESSION['form'][$field]) ? $_SESSION['form'][$field] : '' ?&gt;" maxlength="100" /&gt;
  &lt;? if (isset($_SESSION['errors'][$field])) { ?&gt;
    &lt;label class="error" for="&lt;?= $field ?&gt;"&gt;&lt;?= $_SESSION['errors'][$field] ?&gt;&lt;/label&gt;
  &lt;? } ?&gt;

  &lt;input type="submit" value="Submit Your Information" /&gt;           
  &lt;input type="hidden" name="hid_submit" value="1" /&gt;

&lt;/form&gt;
&lt;? 
if (isset($_SESSION['form'])) unset($_SESSION['form']);
if (isset($_SESSION['errors'])) unset($_SESSION['errors']);
?&gt

PRE

That method is fine, and is the one I use. As for a better way? I don't know, seems just fine to me. However, there are some other things that could be improved with this script, and that may be why you feel there might be a better way.

For one, that's some really messy HTML... I would try and separate your PHP from your HTML as much as possible. This is a little harder to do when not using MVC, but can still be accomplished by abstracting your larger bits of code. Also, you are using PHP short tags, but then not using PHP template syntax, this seems counter productive. The purpose of the short tags is to make your code cleaner and make it non-PHP user friendly. Of course, I'm not endorsing PHP short tags, I think you should avoid them, as you are not always guaranteed to have a server that will support them. Lastly, your code is pretty repetitive, the best thing for repetitive stuff like this is loops. For example, here's a sample of how my version of this form would look.

MID

&lt;?php
$fields = array(
    'name',
    'age',
    //etc...
);
?&gt;

&lt;?php foreach( $fields AS $field ) : ?&gt;

&lt;?php $value = isset( $_SESSION[ 'form' ] [ $field ] ) ? $_SESSION[ 'form' ] [ $field ] : ''; ?&gt;

&lt;label for="&lt;?php echo $field; ?&gt;"&gt;What is your &lt;?php echo $field; ?&gt;?&lt;/label&gt;
&lt;input type="text" name="&lt;?php echo $field; ?&gt;" value="&lt;?php echo $value; ?&gt;" maxlength="60" /&gt;

&lt;?php if( ! isset( $_SESSION[ 'errors' ] [ $field ] ) ) : ?&gt;

&lt;label class="error" for="&lt;?php echo $field; ?&gt;"&gt;&lt;?php echo $_SESSION[ 'errors' ] [ $field ]; ?&gt;&lt;/label&gt;

&lt;?php endif; ?&gt;

&lt;?php endforeach; ?&gt;


POST

Of course, even this seems really messy to me, though I can't think of much more, besides using MVC, to do to this to make it cleaner. Also, notice I removed the "id" attribute from your input tag. When your tag has a name, it doesn't need an id, you can just call it with the name. Example:

SUBMITTED

get implmented

        // normal value
        } else {
            o[this.name] = this.value;
        }

    });

    return o

PRE

<code>String.prototype.split()</code> returns an array of the entire string if a match isn't found. So the else condition isn't required.

MID

// not needed
else {
    o[this.name] = this.value;
}


POST

Instead of checking to see if you're at the end of the loop, iterate to <code>path.length - 1</code> then afterwards perform the statement, <code>current[path[i]] = this.value;</code>.

As for the array format contained within the name property, for simplicity I suggest that the array notation should be an endpoint where the value is the push to the current property. So for a value to a added to an array, then <code>[]</code> must be at the end of the name.

Here's an example:

SUBMITTED

rooms
func (r room) neighbors() []room {
    rslice := make([]room, 0, 4)
    if

PRE

You can use <code>start</code> variable here.

MID

func (r room) neighbors() []room {


POST

In this function, it'd be more idiomatic to use <code>switch { ... }</code> instead of sequence of ifs. Same for the if-elses in the <code>main()</code>.

Also it may be more efficient to have a single global re-used <code>[4]room</code> array and have <code>neighbors</code>/<code>nonvisitedneighbors</code> returns slices on it instead of <code>make</code>-ing a new one each call.

SUBMITTED

gt;800, :height=&gt;800).pack('fill' =&gt; 'both', 'expand'=&gt;true)

while $i&lt;10 do
    before_drawing()
    circs[$i] = TkcOval.new(canvas, $point_A, $point_B)
    if $i%2==0 then
        circs[$i][:fill] = 'blue'
    else
        circs[$i][:fill] = 'red'
    end
    after_drawing()
    $i+=1
end

Tk.mainloop

PRE

You should turn <code>$i</code> into a local variable for the loop. There is no need for it to be global.

Then replace the loop with <code>upto</code>.

MID

0.upto(10) do |i|
    before_drawing()

    circs[i] = TkcOval.new(canvas, $point_A, $point_B)
    # As suggested using ternary operator
    # circs [i] [:fill] = i % 2 == 0 ? 'blue' : 'red'

    if i % 2 == 0 then
        circs[i][:fill] = 'blue'
    else
        circs[i][:fill] = 'red'
    end

    after_drawing()
end


POST

You seem to use too many global variables. My advice would be to prefer local variables whenever you can (Like i in the loop). All your global variables can also be made local to the loop (or function in case you wrap the loop in some function).

SUBMITTED

library");
    }
    connected_=false;
}
//-----------------------------------------------------------------------------

MySocketClient::~MySocketClient(){
    WSACleanup();
}
//-----------------------------------------------------------------------------

void MySocketClient::receive(void){
    char recBuf[1024];
    while(1){
        EnterCriticalSection(&amp;sect_

PRE

One last thing, its usually considered good form to provide a way to exit the infinite while loop. So you should consider changing is as follows:

MID

void MySocketClient::receive(void){
    char recBuf[1024];
    while(run_){
        // ...
    }
}


POST

Then, add a setter/getter to the MySocketClient class to set the field, thus allowing the client to exit gracefully. It should be protected, preferably by a read/write lock.

SUBMITTED

function() {
  $('#shop_formatted_address').autocomplete({
    // This bit uses the geocoder to fetch address values
    source: function(request, response) {
      geocoder.geocode( {'address': request.term }, function(results, status) {
        response($.map(results, function(item) {
          // Get address_components
          for (var i = 0; i &lt; item.address_components.length; i++)
          {
            var addr = item.address_components[i];
            var get_street_address, get_route, get_intersection;
            if (addr.types[0] == 'street_address')
              get_street_address = addr.long_name;
            if (addr.types[0] == 'route')
              get_route = addr.long_name;
            if (addr.types[0] == 'intersection')
              get_intersection = addr.long_name;
          }
          return {
            label: item.formatted_address,
            value: item.formatted_address,
            lat: item.geometry.location.lat(),
            lng: item.geometry.location.lng(),
            street_address: get_street_address,
            route: get_route,
            intersection: get_intersection
          }
        }));
      })
    },

    // This bit is executed upon selection of an address
    select: function(event, ui) {
      clearValue();
      // Get values
      $('#shop_lat').val(ui.item.lat);
      $('#shop_lng').val(ui.item.lng);
      $('#shop_street_address').val(ui.item.street_address);
      $('#shop_route').val(ui.item.route);
      $('#shop_intersection').val(ui.item.intersection);
      var location = new google.maps.LatLng(ui.item.lat, ui.item.lng);
      marker.setPosition(location);
      map.setCenter(location);
    },

    // Changes the current marker

PRE

You could refactor this using a few arrays to avoid as much typing, but I think readability is paramount, and I don't see many ways for it to be more readable than what you have submitted.

You could try using filter instead, but it will be over 3 times slower (most of the time this won't matter), (N times slower where N is the number of components):

MID

      function getValueOfAddressType(values, addressType) {
        var candidates = $.filter(values, function(i) {
            return values[i].types[0] === addressType;
        });
        return candidates[0].long_name;
      }


$('#shop_formatted_address').autocomplete({
This bit uses the geocoder to fetch address values
source: function(request, response) {
  geocoder.geocode( {'address': request.term }, function(results, status) {
    response($.map(results, function(item) {

      return {
        label: item.formatted_address,
        value: item.formatted_address,
        lat: item.geometry.location.lat(),
        lng: item.geometry.location.lng(),
        street_address: getValueOfAddressType(item.address_components, 'street_address'),
        route: getValueOfAddressType(item.address_components, 'route'),
        intersection: getValueOfAddressType(item.address_components, 'intersection')
      }


POST

SUBMITTED

pragma once

#include &lt;stdexcept&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;time.h&gt;
#include

PRE

There are C++ equivalent of most C libraries that put the appropriate interface into the standard namespace.

MID

#include &lt;time.h&gt;

// Prefer

#include &lt;ctime&gt;


POST

My pet peeve (OK second after <code>using namespace std;</code>); because everybody thinks they know the rules but get it wrong all the time:

SUBMITTED

find

PRE

MID

find

POST

This won't cost you anything and can be useful sometimes.

There has been <a href="https://stackoverflow.com/q/17409641/1333025">a request</a> for an implementation like yours, perhaps you could consider publishing it as a small library somewhere.

SUBMITTED

s2

PRE

MID

s2

POST

SUBMITTED

file);
    }

    (*linebuff)[this_char] = '\0';
    line = *linebuff;
    return line;
}

int

PRE

<s>Looks like you've successfully avoided the "leak on <code>realloc</code> failure" issue that traps many newbies.</s> (<b>Update:</b> Sorry, must have suffered temporary blindness, you do leak here.)  But I think this is too verbose.  Why do you need to maintain <code>linebuff</code> as a double pointer?  You already have <code>line</code>.

MID

(*linebuff)[this_char] = '\0';
line = *linebuff;


POST

Seems like you missed a potential <code>realloc</code> here.  If the buffer is exactly full when you hit that line, you'll write past the allocation.

SUBMITTED

T&gt;(
                new OBB2D(m_bounds.getBoundingRect().left + halfWidth + quarterWidth,
                        m_bounds.getBoundingRect().top + quarterHeight, halfWidth,halfHeight)));
        m_nodes.add(new QuadTreeNode&lt;T&gt;(
                new OBB2D(m_bounds.getBoundingRect().left + halfWidth + quarterWidth,
                        m_bounds.getBoundingRect().top + halfHeight + quarterHeight,
                        halfWidth, halfHeight

PRE

is consistent with that hypothesis.

MID

    m_nodes.add(new QuadTreeNode&lt;T&gt;(
            new OBB2D(m_bounds.getBoundingRect().left,
                    m_bounds.getBoundingRect().top + halfHeight + quarterHeight, 
                    halfWidth,halfHeight)));


POST

is not. The x-coord is offset by a quarter and the y-coord by a half.

If the arguments to the constructor are centre and size then one of the four quads is misplaced, so on average something like 1/8 of the items which should go further down the quad are being stored in the current node. If the arguments to the constructor are corner and size then three of the four quads are misplaced, and on average something like 7/16 of the items is not being pushed further down.

SUBMITTED

h"

#pragma

PRE

Not much to say here, choose whichever you like, but you seem to have a bunch of those in your code.

Not everybody agrees on the use of <code>pragma</code>, as (I think ?) "/* */" can do the same (puts a link in the jump bar), but you can go further with it:

MID

pragma -


will create a simple separator,

pragma My Label


will create a label, and

pragma - My Label


POST

will create both (as you used it).

SUBMITTED

var stage

PRE

MID

var

POST

SUBMITTED

currentNode.x, currentNode.y))
        possibleMoves = currentNode.neighbors()
        for move in possibleMoves:
            if not (move.x, move.y) in closedSet:
                try:
                    index = frontier.index(move)
                    if move.priority &lt; frontier[index].priority:
                        frontier.pop(index)
                        bisect.insort_left(frontier, move)
                except ValueError:
                    # move is not in frontier so just add it
                    bisect.insort_left(frontier, move)
    return

PRE

No reason to store it in a local, just combine the previous two lines

MID

            if not (move.x, move.y) in closedSet:
                try:
                    index = frontier.index(move)
                    if move.priority &lt; frontier[index].priority:
                        frontier.pop(index)
                        bisect.insort_left(frontier, move)


Move the last three lines into an else block. That'll make sure only your index line can actually throw things that'll get caught.

                except ValueError:
                    # move is not in frontier so just add it
                    bisect.insort_left(frontier, move)


POST

You do this in either case, I'd move it after the try/except block.
        return -1

SUBMITTED

False

    for

PRE

MID

for

POST

SUBMITTED

class Time(object):
"""Attributes: hours, minutes, seconds"""
def __init__(self,hours,minutes,seconds):
    self.hours =hours
    self.minutes=minutes
    self.seconds=seconds

def print_time(self):
    """prints time object as a string"""
    print "%.2d:%.2d:%.2d" % (self

PRE

It is perfectly fine to implement an <code>__init__</code> method in this case. I think the only thing you should note is, by the way it's defined, the <code>Time</code> class forces the programmer to give values for <code>hours</code>, <code>minutes</code> and <code>seconds</code> to define a <code>Time</code> object. So, with that constraint in mind, it's really up to you as to whether this is an advantage or disadvantage. Do you want to force the programmer (most likely yourself) to enter these values here? Or should you allow him to first construct an object and then define them later? This is your decision; I don't think Pythoneers will try to sway you one way or another.

Alternatives are (1)  as you've already implied: removal or (2) giving these variables default values.

For example:

MID

def __init__(self,hours=None,minutes=None,seconds=None):
    self.hours =hours
    self.minutes=minutes
    self.seconds=seconds


POST

With the above you are giving the user the option to define these later or now with no penalty either way. Just keep the following simple philosophy of Python in mind:

Easier to ask for forgiveness than permission

(From the <a href="http://docs.python.org/2/glossary.html" rel="nofollow">Python Glossary</a>)

I don't really see a point in naming instances. Do you have a rationale for that? Also, if you choose to name them, I think that returning said name after setting is an unexpected behavior and gives the <code>name</code> function more responsibility than it needs.

In your <code>add_time</code> method, I would suggest constructing a new <code>Time</code> object using the values of the <code>self</code> object and then returning that with the incrementation. And, in general, <code>import</code> statements occur at the top of the Python module, unless it is a really special case.

Overall, everything looks pretty good. I hope this was somewhat helpful, if you have any questions be sure to comment.

SUBMITTED

remember) {
        this.clientStorage = remember ? localStorage : sessionStorage
    },
    clear: function () {
        this.clientStorage.clear();
    },
    setAll: function (o

PRE

Looks really good. It's clear and easy to understand. Regarding this specific implementation, a couple of things that came to mind:

In <code>setRemember()</code>, unless you specifically only want to support the values <code>1</code> or <code>0</code>, the code can be changed to:

MID

this.clientStorage = remember ? this.localStorage : this.sessionStorage;

POST

In <code>setRemember()</code>, when switching storage mechanisms it might make sense to copy the values out of the old mechanism into the new one so anything the user has previously set will be preserved. Similary, if the user is changing from <code>localStorage</code> to <code>sessionSorage</code>, would it make sense to also <em>clear</em> the old storage mechanism? If making either of these changes, the method could also first compare the new value against the old value and only continue if there is actually a change.

What is <code>o</code> used for in <code>log()</code> method? 

In the <code>log()</code> method, depending on on the utility you're using for logging, you might consider logging the entire object, at once, as many console / logging utilities will allow you to inspect objects. This can sometimes be more informative, although here it's just about whatever would be more convenient because all values will be strings, anyway. If you go this route, you could rename the current function to something like <code>logEach()</code>. 

In the execution of <code>clear()</code>, should you preseve the <code>h_token</code> key?

Taking a step back, here is an alternate API for the utilitiy. Just thinking out loud. 

SUBMITTED

error renaming %s to %s\n%s" file newFile e.Message)

    files |&gt; Seq.iter moveHelper


let moveFrom source =
  getAllFiles source
    |&gt; Seq.filter (fun f -&gt; Path.GetExtension(f).ToLower() &lt;&gt; ".db")  //exlcude the thumbs.db files
    |&gt; move """C:\_EXTERNAL_DRIVE\_Camera"""
  printfn "Done"


#time
moveFrom """C:\Users\Mike\Pictures\To Network"""
moveFrom """C:\_EXTERNAL_DRIVE\Camera

PRE

A few things:

There's already a recursive overload of <code>EnumerateFiles</code> so you don't need <code>getAllFiles</code>. Your top level function would be:

MID

let moveFrom source =
  Directory.EnumerateFiles(source, "*", SearchOption.AllDirectories)
    |&gt; Seq.filter (fun f -&gt; Path.GetExtension(f).ToLower() &lt;&gt; ".db")  //exlcude the thumbs.db files
    |&gt; move """C:\_EXTERNAL_DRIVE\_Camera"""
  printfn "Done"


POST

<code>:? Exception</code> is a type test pattern match, which is unnecessary in a <code>try/with</code> because <code>with</code> only fires for exceptions anyway. You could do this:

SUBMITTED

new Scanner(System.in

PRE

MID

System.in

POST

By using a <code>BufferedReader</code> instead of the <code>Scanner</code> you get it to barely acceptable levels. The following approach runs in roughly 8.2 seconds and get's accepted.

SUBMITTED

include "BunnyNode

PRE

MID

#include

POST

You are not using <code>const</code> keyword anywhere. Using <code>const</code> can not only prevent bugs, but also it makes the programmers intentions clear about how variables and functions are going to be used.

In general, if a class member function will not change the state its member variables, it should be declared <code>const</code>. Note that this needs to be put in both the header and implementation file.

eg. in BunnyList.h

SUBMITTED

children
def fetch_all_sections(standard, section = nil, depth = 0)
  all_sections = []
  if section

PRE

What I needed was the pipe operator! It was of course just doing what I was telling it to - pushing the results of itself onto the current element in the array. Only when the rootsections loop completes does it start a new array element.

The 'pipe' (<code>|</code>) is a different array merge operator which appends what's to the right of it onto the end of the array on the left.

MID

all_sections | fetch_all_sections(standard, section, depth)


The pipe operator changed how depth worked so instead I just counted the number of "." in sortlabel:

depth = section.sortlabel.split('.').length -1


POST

The full method:

SUBMITTED

function () {
            localStorage

PRE

MID

localStorage

POST

SUBMITTED

public byte fill1
        {
            get { return _fill1; }
            private set { _fill1 = value; }
        }

        public Color

PRE

If you wanted to make the Gamma class immutable pass in all the arguments in the constructor.  If you wanted to added an extra layer (packet header, CRC etc) around the data object then your serialize could inherit from a base class that first read the surrounding packet data and offloaded the actual payload serialization/serialization as required.

As for the code itself.  Just a few minor things

I personally try not to make property names the same as their type names although this is just a personal preference.  In your case as suggested by svick it is good to leave as is.  Here's a good read on this conundrum I just found after a quick google if intereste.  <a href="https://stackoverflow.com/questions/2542963/how-to-avoid-using-the-same-identifier-for-class-names-and-property-names">How to avoid using the same identifier for Class Names and Property Names?</a>  

A couple of inconsistencies in your public property camel casing.  I noticed you had a <strong>fill1</strong>.  It should be <strong>Fill1</strong> to be consistent.

In line with 2.  I'm not sure of your application domain but I tend to find properties like fill1, fill2 a bit obscure and don't tend to suggest what that property is.  Perhaps a more meaningful name here to get away from the 1, 2 naming syntax would be appropiate.

If you are going to have public properties with backing fields unless you need the private field just use auto-properties.

i.e. 

MID

public byte Fill3 { get; private set; }


Alternatively you could do away with the private set altogether and make your field read-only and only expose a public method

i.e. 

private readonly byte _fill3; // initialise in constructor
public byte fill3 { get { return _fill3; } }


POST

As you seem to be mixing and matching your assignment in your constructor being fields and properties I would probably just go with the auto-property concept.

Just my 2cents...

SUBMITTED

setting thread
{
    CLUtilCompact.waitForMe = true;
    ClipSetThread set = new ClipSetThread(theApp);
    set.arg = arg;
    set.start();
    while

PRE

Even if the second line is called first, nobody knows when the field update will propagate to the other thread.

What we can do about this? In general, nothing. This is the (desired) behavior of threads.<br>
For your problem, you can either block the application until the job is done, or hope that it is done fast enough asynchronously. You could implement some logic, which will display some error message after a given time. But this is quite a bad solution for slow system or systems under heavy load.

If you want to do something after the run method has finished, try <code>SwingWorker</code> (read the java documentation).

Some more things:

MID

ClipSetThread set = new ClipSetThread(theApp);
set.arg = arg;


POST

Use the constructor, add a second argument.

SUBMITTED

val) 
  (begin

PRE

MID

begin

POST

Hope that helps. Cheers.

SUBMITTED

Buildvideo(x

PRE

MID

x

POST

SUBMITTED

afterTransition(function() {
            self.atFront

PRE

The usual way I approach the problem is by asking: what <em>does</em> change?

MID

self.atFront

self.atFront = !self.atFront

atFront

!atFront

self.trigger

POST

SUBMITTED

defn- create-counts [coll]
  "Computes how many times did each 'next state' come from a 'previous state'.
   The result type is {previous_state {next_state count}}."
  (let [past    coll
        present (rest coll)
        zipped  (map vector past present)
        sorted  (sort zipped)
        grouped (group-by first sorted)
        seconds (map (fn [[key pairs]] [key (map second pairs)]) (seq grouped))
        freqs   (map (fn [[key secs]]  [key (frequencies secs)]) seconds)]
    (into {} freqs

PRE

First of all, you could use abstract structural binding (a.k.a. destructuring) to reduce the number of <code>let</code> bindings:

MID

(defn- create-counts_org [[_ &amp; present :as coll]]
  "Computes how many times did each 'next state' come from a 'previous state'.
   The result type is {previous_state {next_state count}}."
  (let [zipped  (map vector coll present)
        sorted  (sort zipped)
        grouped (group-by first sorted)
        seconds (map (fn [[key pairs]] [key (map second pairs)]) (seq grouped))
        freqs   (map (fn [[key secs]]  [key (frequencies secs)]) seconds)]
    (into {} freqs)))


POST

I think there's nothing wrong in using <code>let</code> bindings that are technically not necessary to improve readability and comprehensibility. 

But in your function, I think it is pretty clear what every step does: 

SUBMITTED

int log_fd

PRE

<hr> In <code>tp_vlog_write</code>

MAX_TIME_LEN and MAX_MSG_LEN seem generous for a log message.  Remember that
<code>msg</code> is on the stack and if you are in a restricted environment, 1500 bytes
might be too much.  <code>ctime</code> uses 26 bytes for the time/date, so I doubt your time
format needs 512.

<code>level</code> seems like it should be a <code>enum tp_log_level</code>

the switch could be done with if/else

I would extract the creation of a time string into a separate function.
Also, why abort if <code>localtime</code> fails?  This makes your code more fragile
than it needs to be - just don't call <code>strftime()</code> if <code>tm == NULl</code>.

your assert(log_fd) fails if <code>log_fd == 0</code>.  This should apply to the
TPLM_FILE mode only.

as I said before, printing the level text seems unnecessary.  If you need
it, use <code>strcpy</code> instead of <code>snprintf</code>.

printing "\n" could be done with <code>strcpy(msg+len, "\n")</code>

Personally, I have no objection to the use of varargs in this code.  @Lundin
is right that it is not type-safe, but sometimes it has its uses.  This
seems a legitimate use to me.

<hr> In <code>tp_log_close</code>

MID

log_fd == 0

POST

SUBMITTED

class Calculate

PRE

MID

Calculate

POST

SUBMITTED

void closeConnection(PreparedStatement preparedStatement, Connection[] dbConnection) {

        if (preparedStatement != null) {
            try {
                preparedStatement.close();
                preparedStatement = null;
            } catch (SQLException e) {
                LOG.error("Threw a SQLException in finally block of prepared statement " + getClass().getSimpleName(),  e);
            }
        }

        for (Connection con : dbConnection) {
            if (con != null) {
                try {
                    con.close();
                    con = null;
                } catch (SQLException e) {
                    LOG.error("Threw a SQLException in finally block of dbConnection " + getClass().getSimpleName(), e);
                }
            }
        }
    }

    /**
     * Attempts to establish a connection to the given database URL
     * 
     * @return the db connection
     */
    private Connection getDBConnection(String url, String username, String password, String driver) {

        Connection dbConnection = null;

        try {
            Class.forName(driver);

            long start = System.nanoTime();

            dbConnection = DriverManager.getConnection(url, username, password);

            long end = System.nanoTime() - start

PRE

<em>Effective Java, Second Edition, Item 45: Minimize the scope of local variables</em>

The <code>null</code> assignment is unnecessary here (in both cases):

MID

if (preparedStatement != null) {
    try {
        preparedStatement.close();
        preparedStatement = null;
    } catch (SQLException e) {
        LOG.error("Threw a SQLException in finally block of prepared statement " + getClass().getSimpleName(),
                e);
    }
}

for (Connection con: dbConnection) {
    if (con != null) {
        try {
            con.close();
            con = null;
        } catch (SQLException e) {
            LOG.error("Threw a SQLException in finally block of dbConnection " + getClass().getSimpleName(), e);
        }
    }
}


It only nulls a local variable/parameter which will be destroyed anyway at the end of the block/method. I guess you wanted to null the field, for that you need a <code>this.</code> prefix but as above, the fields could be local variables in <code>run</code>, so it's unnecessary.

A <a href="http://www.codinghorror.com/blog/2006/01/flattening-arrow-code.html" rel="nofollow noreferrer">guard clause could make the second loop flatten</a>:

for (Connection con: dbConnection) {
    if (con == null) {
        continue;
    }
    try {
        con.close();
    } catch (SQLException e) {
        LOG.error("Threw a SQLException in finally block of dbConnection " + getClass().getSimpleName(), e);
    }
}


LOG.error("Threw a SQLException in finally block of prepared statement " 
    + getClass().getSimpleName(), e);


POST

If you are using Logback or Log4j the <code>getClass().getSimpleName()</code> is unnecessary, you can set in the <code>log4j.xml</code> or <code>logback.xml</code> to log the class name for every log statement.

Instead of <code>System.nanoTime()</code>, you could use a stopwatch class, like <a href="http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/base/Stopwatch.html" rel="nofollow noreferrer">Guava <code>Stopwatch</code></a> or <a href="https://commons.apache.org/proper/commons-lang/javadocs/api-2.6/org/apache/commons/lang/time/StopWatch.html" rel="nofollow noreferrer">Apache Commons <code>StopWatch</code></a>).

You could extract out the increment part of this method for higher abstraction level:

SUBMITTED

mBook = book;
        mLastPageRequested = page

PRE

MID

page == mLastPageRequested

POST

SUBMITTED

exit();
                }
            }
                    //check

PRE

MID

$check

POST

SUBMITTED

ST&lt

PRE

MID

ST

POST

SUBMITTED

int&gt;();
        static public BlockingCollection&lt;int&gt; Finished = new BlockingCollection&lt;int&gt;();
        static public BlockingCollection&lt;Thread&gt; Threads = new BlockingCollection&lt;Thread&gt;();
        static public int QUCount = 0;
        static public int THCount = 0;
        static public int FNCount = 0;

        static void Main(string[] args)
        {
            BuildList();
            DateTime StartTime = DateTime.Now;

            QUCount = Queue.Count;
            THCount = Threads.Count;
            FNCount = Finished.Count;

            while (QUCount &gt; 0)
            {
                THCount = Threads.Count;
                if (THCount &lt

PRE

MID

static public BlockingCollection&lt;int&gt; Queue
static public BlockingCollection&lt;int&gt; Finished
static public BlockingCollection&lt;Thread&gt; Threads
static public int QUCount
static public int THCount
static public int FNCount


POST

There is no need to make any of these fields <code>public</code>. You shouldn't change the visibility from the default of <code>private</code> unless you have a reason to do it.

SUBMITTED

class Primes {

    public static boolean IsPrime(long num) {
        if (num%2==0){
            return false;
        }

        for (int i=3; i*i&lt

PRE

If you want to measure the distance between two moments, use <code>System.currentTimeMillis()</code>.

MID

for (int i=2; i&lt;Math.sqrt(num);i++)


This will most probably calculate the sqrt for every iteration. sqrt is one the more expensive operations. Do it once and save the result in a variable.<br>
And you do not need to test all divisors. You do not have to test with numbers, which are known not to be prime (This means, you do not have to test with any number 2*n, n>1. Only with numbers 2*n + 1, n>0. Or only with numbers 6n +- 1, n > 0. Or any similar approach around the local minimums of the euler phi function)

     int [] arr= new int[size];
     for (int i=0;i&lt;size;i++){
            arr[i]=arrtemp[i];

         } 


To copy an array, you can use <code>System.arraycopy(...)</code>.

for (int i=min;i&lt;max;i++){
         if (IsPrime(i)){
             arrtemp[size]=i;
             size++;
         }   
     }


POST

To find all primes, you could use the <a href="http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes" rel="nofollow">sieve of Eratosthenes</a>, which is one of the fastest ways inside the java integer range.

SUBMITTED

new

    if

PRE

MID

if

POST

SUBMITTED

prepare("SELECT

PRE

MID

SELECT

POST

SUBMITTED

FileDialogHelper.GetOpenFileName

PRE

MID

FileDialogHelper

POST

SUBMITTED

POST') {

$entries

PRE

MID

$entries[...]

POST

SUBMITTED

string::reverse_iterator iter;
    uInt64 remainder;

    while (decimal &gt; 0)
    {
        remainder = decimal % 2;

        if (remainder == 0)
            binary += '0';
        else if (remainder == 1)
            binary += '1';

        decimal

PRE

MID

remainder = decimal % 2;

if (remainder == 0)
    binary += '0';
else if (remainder == 1)
    binary += '1';


As remaining can only be 0 &lt;= <code>remainder</code> &lt;= 1, the <code>else if</code> is unnecessary. I would just use:

if (decimal % 2 == 0) {
    binary += '0';
} else {
    binary += '1';
}


You can use std::reverse (from <code>&lt;algorithm&gt;</code>) rather than your manual reversal loop.

Example:

std::string decimalToBinary(uint64_t decimal)
{
    std::string binary;
    while (decimal &gt; 0)
    {
        if (decimal % 2 == 0)
            binary += '0';
        else 
            binary += '1';
        decimal /= 2;
    }
    std::reverse(binary.begin(), binary.end());
    return binary;
}


POST

SUBMITTED

public override void Load(string elementText)
    {
        var ele = XElement.Parse(elementText);
        if (ele.Element("FunctionKeys").HasElements)
        {
            var funcs = ele.Element("FunctionKeys")
                .Descendants("Name")
                .Select(x=&gt;x.Value)
                .ToList();

            foreach (string s in funcs)
            {
                dliUnit.FunctionKeyList.Add(
                    (System.Windows.Forms.Keys)System.Enum.Parse(typeof(System.Windows.Forms.Keys),
                    s

PRE

Sticking with the approach you used how about this as an alternative.

MID

public override void Load(string elementText)
    {
        var ele = XElement.Parse(elementText);

        var xElement = ele.Element("FunctionKeys");
        if (xElement != null &amp;&amp; xElement.HasElements)
        {
            _dliUnit.FunctionKeyList.AddRange(xElement
                               .Descendants("Name")
                               .Select(x =&gt; EnumHelper.GetEnum&lt;Keys&gt;(x.Value))
                );
        }
    }


POST

I created a little Enum Extensions class just because I like typing GetEnum:

SUBMITTED

lt;- matrix

PRE

MID

matrix

POST

SUBMITTED

if File.exists?(filepath)
  puts "#{filename} already exists"
else
  puts "Downloading #{filename}..."
  begin
    content = open(url).read
  rescue OpenURI::HTTPError =&gt; e
    abort "Unable to download #{filename}: #{e.message}"
  end
  open(filepath, 'wb') do |file|
    file &lt;&lt; content
  end
  mail_to = options[:mailto]
  mail_from

PRE

For the first snippet there is no much room for improvement, but you can use <code>File.write</code>:

MID

begin
  content = open(url).read
  File.write(filepath, content)
rescue OpenURI::HTTPError =&gt; e
  abort "Unable to download #{url}: #{e.to_s}"
end


POST

For the options parsing part, I'd definitely recommend something better than optparse, for example <a href="https://github.com/jashmenn/trollop/" rel="nofollow">https://github.com/jashmenn/trollop/</a>

SUBMITTED

getConnection(DB_URL, DB_USERNAME,
                            DB_PASSWORD);
                    mConnection.setAutoCommit(false);       
                }catch (NullPointerException e) {                   
                    throw new Exception(errorString+":"+e.getMessage());
                }
                catch(SQLException

PRE

Usage of hardcoded magic numbers should be reduced as much as possible, in cases when it is not possible they should be defined as <code>final static</code> and given a meaningful name.

Catching of <code>NullPointerException</code>

MID

}catch (NullPointerException e) {                   
    throw new SQLException(errorString+":"+e.getMessage());
}


POST

Your code should not be catching an unchecked <code>NullPointerException</code> (indicating a programming error) and throw a check <code>SQLException</code> (indicating a database problem).

This is not a complete list, I think only when these few problems are fixed we can start working on the design of this application.

You can use one of the tools such as:

to further improve the quality of your code

SUBMITTED

if (\Models\Session::checkSession())
        {
            $controller = Config

PRE

The first thing I notice is that you are using the superglobals directly in your class. Normally you want to inject a request object into the class which contains all the info about the request.

The next thing I notice is the use of static methods, e.g.:

MID

\Models\Session::checkSession()


POST

and

SUBMITTED

function run

PRE

MID

run

POST

SUBMITTED

DoCommand(byte numCommand); //Executes a command
  byte GetCommand(char* command); //Gets the number of a command
  void CommandToLowerCase(); //Converts the

PRE

I am not familiar with Arduino, but as a general C++ developer, I've noticed the following issues (looking only at the code in the question, not the one behind links):

No const-correctness.

The biggest problem in the code, one which would cause me to return it back to the developer if I were reviewing this at work.

None of your member functions are classified as <code>const</code>, meaning they will not be callable on a <code>const</code> object of type <code>DomoS</code>, or such an object accessed through a <code>const</code>-qualified path (such as a <code>const DomoS &amp;</code>).

Even more importantly, your functions which take a pointer or reference parameter do not use <code>const</code> on the destination type either, which again means <code>const</code> objects or, even worse, temporaries cannot be used as arguments for those parameters. This way, you also deprive yourself of a great opportunity for self-documenting code, creating space for confusion of the user (or future maintainer) of the class. Example:

MID

byte GetCommand(char* command); //Gets the number of a command


POST

Based on its signature, this function:

SUBMITTED

Point::SetX(double x)
{
    _x = x;
}

double Point::GetY()
{
    return _y;
}

void Point::SetY(double y)
{
    _y = y

PRE

...with two separate constructors, the compiler would diagnose the problem fairly directly, but with one constructor and default arguments, it might not be quite so direct (especially if <code>h</code> could also take a second argument). Frankly, however, I think that's a remote enough possibility I'd probably live with it.

Then we get to the age-old question of whether you gain anything from using get/set pairs for your <code>x</code> and <code>y</code>. For a point, there's a better theoretical argument than with most types that you might eventually want to change representation and use polar coordinates instead of Cartesian coordinates. While theoretically sound, my experience is that this basically just doesn't happen. In code where it makes sense to <em>store</em> polar coordinates, you're generally working with polar coordinates externally as well, so your Cartesian-based interface is wrong anyway.

At the same time, using a <code>getter</code> means that (for example) to translate a point to the right by four units, you end up with something ugly like <code>my_point.set_x(my_point.get_x() + 4);</code> instead of just <code>my_point.x += 4;</code>.

Bottom line: using a getter/setter (accessor/mutator, if you prefer) for this job does a great deal more harm than good. The benefit runs right on the ragged edge between "purely theoretical" and "completely imaginary" while the harm happens essentially all the time in every piece of real code that uses such a class.

Based on what it actually accomplishes, you'd probably be better off with something much simpler, like:

MID

struct Point {
    double x;
    double y;

    explicit Point(double x = 0.0, double y=0.0) : x(x), y(y) {}
};


POST

That assures the members are initialized, and the compiler-synthesized copy constructor, destructor, copy assignment, move constructor, move assignment will all work fine. Direct access to the <code>x</code> and <code>y</code> members will clean up client code considerably.

SUBMITTED

function input_registration ($email, $password) {
$email_clean = htmlspecialchars($email);
$password_clean = htmlspecialchars($password);

$hash = md5($password_clean);

$db = new PDO("mysql:host=localhost;dbname=users", "root", "")

$statement = $db-&gt;prepare("INSERT into userinfo(email, hash) VALUES (:email, :hash)")

//continue with inputting info into database

PRE

<strong>input_registration</strong>:

Create the database connection in central place, so you don't have to change several files and functions, if the database (or your password) changes.

MID

function input_registration($db, $email, $password)
{
    $hash = md5($password); // Consider using a better hash algorithm
    $statement = $db-&gt;prepare("INSERT INTO userinfo(email, hash) VALUES (:email, :hash)");

    // Continue with inputting info into database
}


POST

Of course you have to change <code>validate_registration</code> to support the injection of the database dependency.

SUBMITTED

j=0,k=i;k&lt;len;k++,j++)
                dp[j][k]=(s[j]==s[k])?dp[j+1][k-1]:min(dp[j][k-1],dp[j+1][k])+1;
        printf("%d\n",dp[0][len-1]);
    }
    return

PRE

Don't use the function <code>min()</code>.

MID

dp[j][k]=(s[j]==s[k])?dp[j+1][k-1]:min(dp[j][k-1],dp[j+1][k])+1;


<code>min()</code> and <code>max()</code> functions are not included in standard C.  To make things simple for your code, use the standard math function <a href="http://en.cppreference.com/w/c/numeric/math/fmin" rel="nofollow"><code>fmin()</code></a>.

dp[j][k] = (s[j] == s[k]) ? dp[j+1][k-1] : fmin(dp[j][k-1], dp[j+1][k])+1;


POST

You have an implicit conversion that loses integer precision: 

SUBMITTED

urllib.urlretrieve(url, filename)

#Bdecoding the response

with open (str(filename), 'rb') as myfile:
           data=myfile.read()
           decoded = bencode.bdecode

PRE

Use of single-letter variables suggests lack of attention to clean code.

MID

#Bdecoding the response

with open (str(filename), 'rb') as myfile:


POST

<code>filename</code> is already a string.  Converting it to a string again suggests confusion as to what is going on.

SUBMITTED

self.currchain].append(ditemp)
            for k,v in self.dicolumns.iteritems():
                #idx

PRE

you should drop the <code>#.split('\n')</code>. Also, following PEP-8, put spaces after argument separating commas.

You use <code>iteritems()</code> unnecessarily as the standard iteration behavior of a dictionary is now assumed. Where you have <code>for k,v in self.dicolumns.iteritems():</code> the line

MID

for k, v in self.dicolumns:


POST

is equivalent. To bang on the "names are important" drum, every dictionary has <code>k</code> and <code>v</code>, using more descriptive names would tell me what the meaning of the keys and values are. For that matter I have no idea was a <code>dipolicy</code> or <code>dicolumns</code> are, they might be related or parallel lists but I don't know. You tend to use <code>if len(item)==0</code> when <code>if item</code> means the same thing.

I had to edit your entry because the class methods were not properly indented; this usually means that you are using a mix of tabs and spaces. Tell your editor to forget that the TAB character exists and to use only spaces, there are instructions for most editors on how to make it pretend that the TAB key behaves like you expect without putting literal <code>\t</code> characters in your source code.

The structure of <code>parseline()</code> is so deeply nested and has so many return points and un-elsed ifs that I really can't follow the logic of it. Read <a href="http://www.python.org/dev/peps/pep-0020/">The Zen of Python</a> and keep it wholly.

Finally, iptables is notoriously hairy. I strongly suggest that you use <a href="http://ldx.github.io/python-iptables/">python-iptables</a> or at least study its class structure. You might also want to look at <a href="http://en.wikipedia.org/wiki/Uncomplicated_Firewall">Uncomplicated Firewall</a> as it is designed to abstract iptables into something most humans can understand. It doesn't handle all possible uses, but it makes the typical cases comprehensible.

SUBMITTED

lt;section

PRE

MID

section

POST

SUBMITTED

queue
        var shift = this.queue.shift();
        if (shift) {
            this.running

PRE

MID

var shift = this.queue.shift();

var first ...

shift

POST

SUBMITTED

attach(RollPin);
    Pitch.attach(PitchPin);
    Yaw.attach(YawPin);
    Aux1.attach(Aux1Pin);
    Serial.begin(115200);
    for (byte x = 7; x &lt;= 12; x++)
    pinMode(x, OUTPUT);
    for (byte xy = 14; xy &lt;= 17; xy++)
    pinMode(xy, OUTPUT);

    setPowerPinsOn(false);
    setGroundPinsOn(true);

    pinMode(errorLED, OUTPUT);

}

int GetFromSerial()
{
    // wait until we have some serial data
    while (Serial.available() == 0) {
    if (millis() - lastSerialData &gt; 1000) {
        digitalWrite(errorLED, HIGH);
        readSonar();
        blinkingLed();
        autoLand();
    }
    }

    lastSerialData = millis();
    digitalWrite(errorLED, LOW);

    return Serial.read();
}

void loop()
{
    switch (GetFromSerial()) {
    case 't':
    temp = 0;
    temp = GetFromSerial() + 45;
    if (temp &gt;= 45 &amp;&amp; temp &lt;= 141)
        throttle = temp;    //45 to 141
    Throttle.write(throttle);
    break;
    case 'r':
    temp = 0;
    temp = GetFromSerial() + 45;
    if (temp &gt;= 45 &amp;&amp; temp &lt;= 141)
        roll = map(temp, 45, 141, 69, 117); //45 to 141
    if (roll &lt; (93 + range) &amp;&amp; roll &gt; (93 - range))
        roll = 93;

    Roll.write(roll);
    break;
    case 'p':
    temp = 0;
    temp = GetFromSerial() + 45;
    if (temp &gt;= 45 &amp;&amp; temp &lt;= 141)
        pitch = map(temp, 45, 141, 69, 117);    //45 to 141
    if (pitch &lt; (93 + range) &amp;&amp; pitch &gt; (93 - range))
        pitch = 93;
    Pitch.write(pitch);
    break;
    case 'y':
    temp = 0;
    temp = GetFromSerial() + 45;
    if (temp &gt;= 45 &amp;&amp; temp &lt;= 141)
        yaw = map(temp, 45, 141, 68, 117);  //45 to 141
    Yaw.write(yaw);
    break;
    case 'a':
    temp = 0;
    temp = GetFromSerial() + 45;
    if (temp &gt;= 45 &amp;&amp; temp &lt;= 141)
        aux1 = temp;    //45 to 141
    Aux1.write(aux1);
    break;
    }               // end switch
    if (throttle &lt;= 45)     //Connected but not flying
    circleLed();
    else if (throttle &gt;= 45 &amp;&amp; aux1 &gt; 45)
    headingLed();
}

void autoLand()
{
    if (throttle &lt;= 60 &amp;&amp; aux1 &gt;= 50) {
    throttle = 45;
    aux1

PRE

I'll write your <code>loop()</code> function something like this

MID

#define TEMP_RANGE(x,y) (temp &gt;= x &amp;&amp; temp &lt;= y)
#define CHECK_RANGE(x, y, z) ((y + z) &gt; x &amp;&amp; x &gt; (y - z))

void loop()
{
    temp = 0;
    temp = GetFromSerial() + 45;
    switch (GetFromSerial()) 
    {
        case 't':
            if (TEMP_RANGE(45,141))
                throttle = temp;
            Throttle.write(throttle);
            break;
        case 'r':
            if (TEMP_RANGE(45,141))
                roll = map(temp, 45, 141, 69, 117);
            if (CHECK_RANGE(roll, 93, range))
                roll = 93;
            Roll.write(roll);
            break;
        case 'p':
            if (TEMP_RANGE(45,141))
                pitch = map(temp, 45, 141, 69, 117);
            if (CHECK_RANGE(pitch, 93, range))
                pitch = 93;
            Pitch.write(pitch);
            break;
        case 'y':
            if (TEMP_RANGE(45,141))
                yaw = map(temp, 45, 141, 68, 117);
            Yaw.write(yaw);
            break;
        case 'a':
            if (TEMP_RANGE(45,141))
                aux1 = temp;
            Aux1.write(aux1);
            break;
    }

    if (throttle &lt;= 45) //Connected but not flying
        circleLed();
    else if (aux1 &gt; 45)
        headingLed();
}


POST

Note these

SUBMITTED

url_replace( '/news?b=2', { b

PRE

Some notes:

MID

url_replace( '/news' )

POST

SUBMITTED

Url){
    $resultant

PRE

MID

$resultant

POST

SUBMITTED

charAt( 1 ) );
            if( testMe &lt; 2 )            // if tens

PRE

Yes! Your code is more complicated than it needs to be.

MID

if (testMe &lt; 2) ...

POST

Here is a method I came up with, that returns a string:

SUBMITTED

defun init-texture (tex)
    (gl:bind-texture :texture-2d tex)
    (gl:tex-parameter :texture-2d :texture-min-filter :nearest)
    (gl:tex-parameter :texture-2d :texture-mag-filter :nearest)
    (print *test-texture*)
    (let* ((tex-w 16) (tex-h 16) (pixel-size 4) 
        (pixel-data (make-array (* (* tex-w tex-h) pixel-size) :element-type '(unsiged-byte 8) :adjustable nil :initial-element 0)))
    (loop for y from 0 to (- tex-h 1) do 
        (let ((line-offset (* (* tex-w pixel-size) y)))
            (loop for x from 0 to (- tex-w 1) do 
                (let ((x-offset (+ line-offset (* x pixel-size))) (c (if (oddp (+ x y)) 255 0)))
                    (setf (aref pixel-data x-offset) 255)
                    (setf (aref pixel-data (+ x-offset 1)) c)
                    (setf (aref pixel-data (+ x-offset 2)) c)
                    (setf (aref pixel-data (+ x-offset 3)) 255)))))
    (gl:tex-image-2d :texture-2d 0 :rgba tex-w tex-h 0 :rgba :unsigned-byte pixel-data

PRE

The you can write above as:

MID

(defun init-texture (tex &amp;aux (tex-w 16) (tex-h 16) (pixel-size 4))
  (gl:bind-texture :texture-2d tex)
  (gl:tex-parameter :texture-2d :texture-min-filter :nearest)
  (gl:tex-parameter :texture-2d :texture-mag-filter :nearest)
  (print *test-texture*)
  (let ((pixel-data (make-array (* tex-w tex-h pixel-size)
                                :element-type '(unsiged-byte 8)
                                :adjustable nil
                                :initial-element 0)))
    (loop for y below tex-h
          for line-offset = (* tex-w pixel-size y)
          do (loop for x below tex-w
                   for x-offset = (+ line-offset (* x pixel-size))
                   for c = (if (oddp (+ x y)) 255 0)
                   do (vector-put-at (pixel-data x-offset)
                        255 c c 255)
    (gl:tex-image-2d :texture-2d 0 :rgba tex-w tex-h 0 :rgba :unsigned-byte pixel-data)))


POST

SUBMITTED

dnn_htmlPan4").find("p").slideToggle("slow");

});
$("#dnn_htmlPan5.htmlPan").find(":header").click(function () {
    $("#dnn_htmlPan5").find("p").slideToggle("slow

PRE

Without knowing what your elements are or the html around them, i would say just combine the id's into one selector and use $(this).find in the click function. Example:

MID

$("#id1, #id2, #id3").find(':header').click(function(){
 $(this).find('p').slideToggle('slow')l
});


POST

SUBMITTED

require full_path
                unless eval("defined? #{class_name}")
                    @logger.error

PRE

You don't need <em>eval</em> here:

MID

unless eval("defined? #{class_name}")


instead:

unless defined?(class_name)


POST

Instead of this:

SUBMITTED

if (!preg_match("/^[A-Za-z '-]+$/i", $name)) {

    $errors

PRE

MID

/^[A-Za-z '-]+$/i

/^[A-Za-z]+\s[A-Za-z]+$/

POST

SUBMITTED

formated_ul):
    with

PRE

The highlights:

MID

with

POST

SUBMITTED

concurrent.Future

PRE

MID

Future

POST

<strong>ExecutorWithQueue</strong>

SUBMITTED

title
if

PRE

Ok, this might come across as blunt and hurtful, but it's meant to be helpful (code-review IMO should be harsh, <a href="https://codereview.meta.stackexchange.com/questions/810/guidelines-for-new-users-proposal-tag">here's why</a>):

<em>"I have been writing PHP programs in the MVC pattern for quite some time"</em><br/>
No, you haven't. Really. M-V-C stands for, as you well know: Model-View-Controller. The code you pasted just strings all three together in one single script. That's spaghetti-code (at best), not framework-like MVC code. Not even close.

<em>"I have this PHP file that prints a result in XML, and I put this file in 'model'"</em><br/>
Again: any file that generates output belongs in the <em>view</em>. As the name suggests, anything that is sent to the client (ie the client gets to <em>"see"</em>), is part of the clients <em>view</em> of your application. You really should read up on MVC, to find out what belongs where. (there's a link at bottom of my answer)

At the top, you set your header, then you process the request (without checking if there has been a POST request). Setting the headers as soon as possible (before anything has been sent to the client) is understandable. But in the context of the MVC pattern, it shouldn't really matter. In fact, it's one of the great things about the real MVC pattern: inside your controller and model layer, you're absolutely sure the headers haven't been sent yet, because the view is only generated (and sent to the client) at the very end of the request. <br/>
So, as your app sets about processing the request, and you hit a point where the client should be redirected, you can do so, almost blindly. Safe in the knowledge that the headers aren't sent yet. That's why MVC is so successful, and why redirects are mostly found in the controller. To clarify, look at this very simple graph (from cakePHP site, but it applies to MVC in general):

<a href="https://i.stack.imgur.com/CKvza.png" rel="nofollow noreferrer"><img src="https://i.stack.imgur.com/CKvza.png" alt="Simple MVC chart"></a><br>
<sub>(source: <a href="https://book.cakephp.org/2.0/en/_images/basic_mvc.png" rel="nofollow noreferrer">cakephp.org</a>)</sub>  

Here you see the flow of an MVC webapp:

MID

if

POST

SUBMITTED

i in range(1,w

PRE

MID

range(1, w)

POST

SUBMITTED

ByVal strParameterValue

PRE

MID

strParameterValue

POST

SUBMITTED

ns hangman.core                                                                                    
  (:import (java.net ServerSocket Socket SocketException)                                                
           (java.io PrintWriter InputStreamReader BufferedReader))                                       
  (:gen-class))                                                                                          

(defn guess [guess word]                                                                                 
  (apply str (map #(let [x (str %)] (if (.contains guess x) x "*")) word)))                              

(defn listen [port]                                                                                      
  (new ServerSocket port))                                                                               

(def word "clojure")                                                                                     

(defn conn-handler [conn]                                                                                
  (let [in (:in @conn)                                                                                   
        out (:out @conn)]                                                                                
    (.println out "Welcome to this simple hangman game.")                                                
    (def the-guess (atom ""))                                                                            
    (loop [conn conn]                                                                                    
      (.println out (str "Guess the word: " (guess @the-guess word)))                                    
      (.flush out)                                                                                       
      (let [g (str @the-guess (.readLine in))                                                            
            res (guess g word)]                                                                          
        (if (= word res)                                                                                 
          (do                                                                                            
            (.println out res)                                                                           
            (.println out "Correct!")                                                                    
            (.flush out))                                                                                
          (do                                                                                            
            (reset! the-guess g)                                                                         
            (recur conn)))))))                                                                           

(defn -main [&amp; args]                                                                                     
  (println "Server running…")                                                                            
  (with-open [server (listen 3456)]                                                                      
    (loop []                                                                                             
      (let [client (.accept server)                                                                      
          in (BufferedReader.(InputStreamReader.(.getInputStream client)))                               
          out (PrintWriter. (.getOutputStream client))                                                   
          conn (ref {:in in :out out})]                                                                  
        (println "Client connected")                                                                     
        (doto (Thread. #(conn-handler conn)) (.start))                                                   
        (recur

PRE

The following code contains the revised <code>conn-handler</code> and <code>-main</code> functions, including all the suggestions above, plus the cosmetic change of using the threading macro <code>-&gt;</code> instead of the <code>doto</code> form, which seems a bit clearer:

MID

(defn conn-handler []
  (println "Welcome to this simple hangman game.")
  (loop [the-guess ""]
    (println (str "Guess the word: " (guess the-guess word)))
    (flush)                                                                                       
    (let [g (str the-guess (readLine))                                                            
          res (guess g word)]                                                                          
      (if (= word res)                                                                                 
        (do                                                                                            
          (println res)                                                                           
          (println "Correct!")                                                                    
          (flush))                                                                                
        (do                                                                                            
          (recur g))))))                                                                           

(defn -main [&amp; args]                                                                                     
  (println "Server running…")                                                                         
  (with-open [server (listen 3456)]                                                                      
    (while true                                                                                             
      (let [client (.accept server)                                                                      
            in (BufferedReader.(InputStreamReader.(.getInputStream client)))                               
            out (PrintWriter. (.getOutputStream client))]                                                                  
        (println "Client connected")                                                                     
        (-&gt; #(binding [*in*  in
                       *out* out]
               conn-handler)
            (Thread.)
            (.start))))))


POST

SUBMITTED

key === 191) {
            // Ctrl+/
            e.preventDefault();
            Help();
        }
    }
    if (e.keyCode === 9 || e.which === 9) { // tab
        e

PRE

You can shave a few bytes by using <code>==</code> instead of <code>===</code>. Since you're comparing primitives, not objects, <code>==</code> and <code>===</code> function equivalently.

Using <code>===</code> (instead of <code>==</code>) is a good practice when you're not sure, but it is unnecessary in the places you are using it.

It looks like you didn't update your last check in the keydown callback

MID

if (e.keyCode === 9 || e.which === 9) { // tab


Can be rewritten as:

if (key == 9) { // tab


POST

SUBMITTED

k+1).toString

PRE

MID

.toString()

POST

SUBMITTED

x s' au (s:ex)) rs
        where rs = reach1From s

PRE

MID

rs = reach1From s au \\ ex

ex

ex

POST

SUBMITTED

replace('(','')
splash=splash.replace(')','')
splash=splash.split(',')
f.close()
splashlen=len(splash)
chc=random.randint(0,int(splashlen))
splash=splash[chc-1]
f=open

PRE

Here you read some settings/configurations. Better use the <a href="http://docs.python.org/2/library/configparser.html"><code>ConfigParser</code></a> module. It will make your code more readable and more easily to follow.

MID

splashlen=len(splash)
chc=random.randint(0,int(splashlen))
splash=splash[chc-1]


POST

To select a random element from as list, you can just use <code>random.choice</code>.

SUBMITTED

void main

PRE

MID

main()

POST

SUBMITTED

public interface IGYDataAccess
    {
        void GetUserInfo(Action&lt;GYUser, Exception&gt; act, string id);         
    }

public class GYWebData : IGYDataAccess
{
    public void GetUserInfo(Action&lt;GYUser, Exception&gt; act, string id)
    {
        GYUserAPI.GetInfo(id, (result, error) =&gt;
            {
                if (error != null)
                {
                    act.Invoke(null, error);
                    return;
                }

                act.Invoke(result.Result, null);
                GYLocalData gyLocalData = new GYLocalData();
                gyLocalData.UpdateUserInfo(result.Result);

            });
    }
}

 public class GYLocalData : IGYDataAccess
{
    private const string ConnectionString = @"isostore:/Cache.sdf";
    CacheDataContext DataBase;      
    CacheDataContextProfiles DataBaseProfiles;       

    private void CheckDataBase()
    {
        using (DataBase = new CacheDataContext(ConnectionString))
        {
            if (!DataBase.DatabaseExists())
            {
                DataBase.CreateDatabase();
            }
        }
    }


    public void GetUserInfo(Action&lt;GYUser, Exception&gt; act, string id)
    {
        CheckDataBase();

        using

PRE

You could use some <a href="https://stackoverflow.com/questions/130794/what-is-dependency-injection">Dependancy Injection</a> in your <code>GYWebData</code> class. You want to store everything that is took from the web API in a another storage. So the <code>GYWebdata</code> class should receive in the constructor a <code>GYLocalData</code> instance where you would store the information : 

MID

public class GYWebData : IGYDataAccess
{
    private GYLocalData storage;

    public GYWebData(GYLocalData storage)
    {
        this.storage = storage;
    }

    public void GetUserInfo(Action&lt;GYUser, Exception&gt; act, string id)
    {
        GYUserAPI.GetInfo(id, (result, error) =&gt;
            {
                if (error != null)
                {
                    act.Invoke(null, error);
                    return;
                }

                act.Invoke(result.Result, null);
                storage.UpdateUserInfo(result.Result);
            });
    }
}


POST

Now this isn't exactly Dependency Injection because I give a concrete class as parameter. You would need another interface, <code>IDataUpdater</code>, maybe : 

SUBMITTED

main()
{
    unsigned i,k=0,n;
    cout&lt;&lt;"n= "; cin&gt;&gt;n;

    while(k&lt

PRE

Same with this:

MID

cout &lt;&lt; "n= ";
cin &gt;&gt; n;


POST

Prefer <code>"\n"</code> to <a href="http://en.cppreference.com/w/cpp/io/manip/endl" rel="nofollow noreferrer"><code>std::endl</code></a> here (the latter flushes the buffer, which takes longer).  It's still okay to use the latter where <em>both</em> flushing and newlining are needed.

Always use descriptive names for variables.  Single-characters are best for loop counters (such as <code>i</code>).  This will vastly improve readability as you won't need comments to describe them.

It looks like you could use recursion instead of all these loops.  It may take longer (if you input a large number), but it should at least simplify the logic.

SUBMITTED

gt; jobsToExecute

PRE

MID

jobsToExecute

POST

SUBMITTED

i+1];
  }
  execv

PRE

MID

execv

POST

SUBMITTED

arr[i] &gt; largest) {
          secondLargest = largest; 
          largest = arr[i];

       } else if (arr[i] &gt; secondLargest &amp;&amp; arr[i] &lt;= largest) { 
          secondLargest = arr[i];
       }
    }
    return (largest + secondLargest

PRE

Is the signature of the function imposed ? Your solution would work for any kind of iterable objects and would be probably more idiomatic than passing a pointer and a size. Also, the logic would work for any (comparable) types and not just <code>int</code> so it might be worth making it a templated function.

In your search of the most common element, do you want to return the number of occurences or the element itself ?

In your sum of the two biggest, I think you can compare to <code>largest</code> only once.

You just need to do something like :

MID

   if (arr[i] &gt; secondLargest) {
       if (arr[i] &gt; largest) { 
           secondLargest = largest; 
           largest = arr[i];
       } else {
           secondLargest = arr[i]; 
       }
   }


POST

SUBMITTED

likes to visit", myCat);

// Method 2
Console.WriteLine("I have a wild " + myCat + " cat that likes to visit

PRE

Personally I opt for String.Format() because it does so much for so little.

Consider this example:

MID

Console.WriteLine("I have " + count.ToString() + " wild cats that like to visit");


Which results with this IL:

IL_0030: ldstr "I have "
IL_0035: ldloca.s count
IL_0037: call instance string [mscorlib]System.Int32::ToString()
IL_003c: ldstr " wild cats that like to visit"
IL_0041: call string [mscorlib]System.String::Concat(string, string, string)
IL_0046: call void [mscorlib]System.Console::WriteLine(string)


In comparison, using String.Format

Console.WriteLine(String.Format("I have {0} wild cats that like to visit", count));


...is slightly better.

IL_0096: ldstr "I have {0} wild cats that like to visit"
IL_009b: ldloc.1
IL_009c: box [mscorlib]System.Int32
IL_00a1: call string [mscorlib]System.String::Format(string, object)
IL_00a6: call void [mscorlib]System.Console::WriteLine(string)


Not convinced?  How about this realistic example with two substitution parameters including a date (I'm often inserting a date into log strings, for example).

The bad way:

Console.WriteLine("Today is " + System.DateTime.Now.ToString("M/d/yy") + " and I have " + count.ToString() + " wild cats that like to visit");


POST

Insane block of IL this time:

SUBMITTED

class FixedSet

PRE

MID

FixedSet

POST

SUBMITTED

edge&lt;-100
magicradius=.81
magicmargin=.01
width&lt;-(2*edge)+1

x&lt;-c(-edge:edge)
y&lt;-c(-edge:edge)

squarelist&lt;-c(1:((width^2)))

dim(squarelist)&lt;-c(width, width)

counter&lt;-0
for (i in 1:length(x)){
  for (j in 1:length(y)){
    counter&lt;-counter+1
    if( (((magicradius-magicmargin)*(edge))&lt;sqrt( x[i]^2 + y[j]^2  ) )
        &amp;(((magicradius+magicmargin)*(edge))&gt;sqrt( x[i]^2 + y[j]^2 ) ) ){
      squarelist[counter]&lt;-sqrt( x[i]^2 + y[j]^2)
    } else {
      squarelist[counter]&lt;-0

    }      
  }
}

gg&lt;-matrix(squarelist,nrow=width,ncol=width)

image(gg

PRE

A vectorized solution using <code>outer</code> (Outer Product of Arrays):

MID

edge &lt;- 100
magicradius &lt;- .81
magicmargin &lt;- .01
width &lt;- (2*edge) + 1

x &lt;- -edge:edge
y &lt;- -edge:edge

mat &lt;- outer(x, y, function(x,y) sqrt(x^2 + y^2))
ind &lt;- mat &gt; ((magicradius-magicmargin)*edge) &amp;
       mat &lt; ((magicradius+magicmargin)*edge)
image(ind, asp=1)


POST

<img src="https://i.stack.imgur.com/KkIks.png" alt="enter image description here">

The aspect ratio in <code>image()</code> can be set with the <code>asp</code> argument (see the <em>Details</em> section in <code>?plot.window</code>)

SUBMITTED

gt; m){
        min = m;
    }
    else {
        min = n;
    }
    return min;
}


public ArrayList&lt

PRE

You probably should have used <a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Math.html" rel="nofollow"><code>Math.min()</code></a>. Even if it was requested by the interviewer to not use anything else besides <code>ArrayList</code>, <code>min</code> can be written much more concise as

MID

return n &lt;= m ? n : m


POST

(1 line of code vs. 8)

This loop is little bit ugly:

SUBMITTED

newValue;
       }

        _timer.Start();

   }

   public event PropertyChangedEventHandler PropertyChanged;

    private void RaisePropertyChanged

PRE

I like to avoid <code>null</code> checks on events by making sure there always is at least one subscriber:

MID

public event PropertyChangedEventHandler PropertyChanged = delegate { };


POST

But this is not really a common technique.

Creating multiple timers is okay, they execute on thread pool threads. This means that if several timers tick at the same time, they will be (most likely) executed concurrently by different threads.

In general, polling like this is not ideal. It would be better if you could get a notification whenever the value actually changes. But it seems like this is not possible in your case.

You shouldn't shorten the names of your variables. So, <code>_value</code> is better than just <code>_val</code>.

SUBMITTED

using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Threading.Tasks;

namespace LattitudeDocumentationOrganizer
{
    internal class Program
    {
        private static readonly string connString = LattitudeDocumentationOrganizer.Properties.Settings.Default.ConnectionString;

        private static void Main()
        {
            int fileCount = 0;
            int errorCount = 0;
            bool RunLoop = true;
            //List&lt;Task&gt; tasks = new List&lt;Task&gt;();

            while (RunLoop)
            {
                Console.Clear();

                using (SqlConnection connection = new SqlConnection(connString))
                {
                    connection.Open();
                    // Run through
                    const string Sql = @"select top 1 d.UID, d.CreatedDate, d.Location, m.number from master m with (NOLOCK)
                                    inner join documentation_attachments da with (NOLOCK)
                                        on m.number = da.accountid
                                    inner join documentation d with (NOLOCK)
                                        on da.documentid = d.uid
                                    where m.qlevel = 999
                                    and d.location is not null
                                    and uid not in (select documentid from JM_DocumentationIssues)
                                    order by m.number desc";
                    using (SqlCommand command = new SqlCommand(Sql, connection))
                    using (SqlCommand updateCommand = CreateUpdateCommand(connection

PRE

Try this Query

MID

const string Sql = @"select top 1 d.UID, d.CreatedDate, d.Location, m.number from master m with (NOLOCK)
                     inner join documentation_attachments da with (NOLOCK)
                         on m.number = da.accountid
                     inner join documentation d with (NOLOCK)
                         on da.documentid = d.uid
                     LEFT JOIN JM_DocumentationIssues WITH (NOLOCK) 
                         ON d.UID = JM_DocumentationIssues.UID
                 where m.qlevel = 999
                       and d.location is not null
                       -- and uid not in (select documentid from JM_DocumentationIssues)
                 order by m.number desc";


POST

I think that I have the correct join in there

If you use the <code>NOT IN</code> or the <code>&lt;&gt;</code> in the where statement it can cause issues with large queries because it has to run the nested query every time that it goes through a record.

With this query you should be able to do the <code>SELECT TOP 50000</code> or whatever, which is what you should do.

The code needs to be changed. you need the DataReader to call a Query that returns more than 1 row and then go row by row, maybe do a mass update. this would speed up the application and/or SQL Query and release a lot of resources. 

You should be looping through the returned records and not calling the SQL 500,000 times. That is what is slowing down the SQL Database.

You need to look at what you are doing here, because your two if blocks of code are the only place where you can break out of the while loop.

You set a boolean variable <code>RunLoop</code> to <code>True</code> and then tell a while loop to run while that boolean is <code>True</code> but never set it to <code>False</code>

Inside your While loop you have a bunch of using statements that if they fail, the exception is never caught.  There is no Exception Handling going on at all. 

<strong>I am sure that one of your loops is probably doing more work than you think it is.</strong>

It also looks like you are using <code>LogError</code> to log the results of the application and not actually logging errors

Inside your <code>UpdateDocument</code> you execute a command with out exception handling again.

I think that you should take out all of the <code>Console.WriteLine()</code> nonsense and actually log that stuff to a text file or something maybe,

<code>Console.WriteLine()</code> takes a lot of time, I wish that I could remember the post where I saw this, the post actually gave the times of a <code>Console.WriteLine</code>  and it wasn't pretty.   

Maybe just start out by calling <code>Console.WriteLine()</code> less by merging the strings together.

To Elaborate what @rolfl said in his answer.
all of your <code>using</code> blocks should be outside of your <code>while</code> loop

Your <code>while</code> loop should be inside of your <code>SqlDataReader</code> using block

SUBMITTED

readLine()) != null) {
    //                    dictionary.add(line.split(":")[0]);
    //                }
    //
    //            } finally {
    //                br.close();
    //            }
    //        } catch (Exception e) {
    //            throw new RuntimeException("Error while reading dictionary");
    //        }

        }

        private CatToDog () { };

        public static List&lt;String&gt; listWords(String startWord, String endWord) {
            final Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;();
            final Map&lt;String, String&gt; backTrack = new HashMap&lt;String, String&gt;();
            queue.add(startWord);
            backTrack.put(startWord, null);

            while (!queue.isEmpty()) {
                String currentWord = queue.poll();
                if (currentWord.equals(endWord)) {
                    return mapToList(backTrack, endWord);
                }
                addValidOneChangeWords(currentWord, queue, backTrack);
            }
            return Collections.EMPTY_LIST;
        }

        private static void addValidOneChangeWords(String startWord, Queue&lt;String&gt; queue, Map&lt;String, String&gt; backTrack) {
            for (int i = 0; i &lt; startWord.length(); i++) {
                char[] endWord = startWord.toCharArray();
                for (char ch = 'a'; ch &lt; 'z'; ch++) {
                    endWord[i] = ch;
                    String word = new

PRE

A default constructor is provided by Java already, only use that if you need to put something in there.

MID

public static List&lt;String&gt; listWords(String startWord, String endWord) {
    final Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;();
    final Map&lt;String, String&gt; backTrack = new HashMap&lt;String, String&gt;();
    queue.add(startWord);
    backTrack.put(startWord, null);

    while (!queue.isEmpty()) {
        String currentWord = queue.poll();
        if (currentWord.equals(endWord)) {
            return mapToList(backTrack, endWord);
        }
        addValidOneChangeWords(currentWord, queue, backTrack);
    }
    return Collections.EMPTY_LIST;
}


How do you know this is the shortest path? It feels a lot like depth first search, but I think you want to implement Dijkstra's algorithm instead to be able to notice shorter subpaths.

private static void addValidOneChangeWords(String startWord, Queue&lt;String&gt; queue, Map&lt;String, String&gt; backTrack) {
    for (int i = 0; i &lt; startWord.length(); i++) {
        char[] endWord = startWord.toCharArray();
        for (char ch = 'a'; ch &lt; 'z'; ch++) {
            endWord[i] = ch;
            String word = new String(endWord);
            if (validate(word, backTrack, startWord)) {
                queue.add(word);
                backTrack.put(word, startWord);
            }
        }
    }
}


POST

You're only focusing on one-letter edits here, but what about deletions, insertions and even transpositions (dog -> dgo)? The Damerau-Levenshtein distance handles them. 

And finally, <code>mapToList</code> is poorly named: I already know that the type change, I want to know about semantics! Something like <code>editPath</code> would be better.

SUBMITTED

c) {
            if (s.answerCorrect === false) {
                var ic = $(".js

PRE

Slight issue in your JavaScript. I can't find <code>s</code> declared. I assume it should have been <code>settings</code>.

String concatenation inside a loop is not a good idea for performance. I'd also try to keep the addition to the DOM till after the loop.

you can treat some values as truthy/falsey instead of <code>===</code> if you know you have set them.

MID

if(s.answerCorrect === false)


is more confusing than writing

if(!s.answerCorrect)


Similarly I'd change

s.answerCorrect = u === c ? true : false;


to

s.answerCorrect = u === c;


POST

I'd say your level of abstraction is bordering on too much. for example:

SUBMITTED

bin/bash

PRE

MID

bin

POST

SUBMITTED

void largestNumbers(float[] numbers) {

    float largeNumber

PRE

In this case, your performance will not be terrible, but, for really large arrays you may run in to problems.

Also, there <strong>is</strong> a bug in your code... what if the input array is empty? Then you will get an <code>ArrayIndexOutOfBoundsException</code> on:

MID

float largeNumber = numbers[0];


POST

There is always more than one way to do things, but, I want to post an answer here because one possible solution (which may or may not be faster than your solution depending on data size) has a really close relationship to another CodeReview question posted recently. When I answered that question I could only think of artifical examples of when it was 'right' to use pre/post-increments. <strong>This is a good example of when....</strong>

See this answer here: <a href="https://codereview.stackexchange.com/a/36910/31503">Is it bad practice to increment more than one variable in a for loop declaration?</a>

So, here is a good example of how and when a <code>count</code> and an <code>index</code> are related in a for loop and the way they can be incremented. I have some notes at the end:

SUBMITTED

CLEARED = 0;
    private

PRE

MID

private

POST

SUBMITTED

for (var i = 0; i &lt; data['categories'].length; i++) {
    var comma = document

PRE

same for creating the comma node, create it outside the loop.

you don't need to wrap <code>i + 1</code> in parenthesis, and this is just my preference, but you should be consistent with spaces. You could also use <code>&lt;</code> instead of <code>!=</code> which is more consistent with the for loop. (These are fairly minor nits)

MID

if (i + 1 &lt; data.categories.length)


POST

Why are you using double dashes and underscores in your element IDs? 

Comments are helpful to explain what your for loop and if statement is doing, since it's probably easier/quicker to understand the comment than figure out the for loop.

Maybe I'm getting overkill at this point, but a way to write really descriptive, easy to read code is to break it into functions whose name makes sense:

SUBMITTED

require 'Board

PRE

MID

Board

POST

Or, I'd roll the functionality into board itself; it can be shortened considerably, so it won't seem like a burden. For instance, the <code>Inspector#current</code> method could be:

SUBMITTED

prev = NULL;
        temp-&gt;data = NULL;
        return temp;
}

struct node *create_node(void *key){
        void *copy = malloc(sizeof(void *));
        memcpy(copy, key, sizeof(key));
        struct node *temp = create_empty_node();
        temp-&gt;data

PRE

Double pointers are necessary only when you need to change a pointer
(as opposed to what the pointer locates) in the calling function.

Your idea of data storage is odd.  In your <code>key</code> parameters you seem
to want to store just an integer value (as all of the data you store
in your tests is smaller or equal to a <code>void*</code>).   In <code>create_node</code>
you make a copy of the <code>key</code>.

MID

struct node *create_node(void *key){
        void *copy = malloc(sizeof(void *));
        memcpy(copy, key, sizeof(key));


POST

This might be what you intended but all the same it looks wrong. Your
<code>node</code> structure contains a <code>void *data</code> field and you are allocating
another <code>void*</code> to hang off that, so at a minimum the allocation is
redundant.  But more to the point if you wanted to store only data up
to the size of a pointer, you should just declare <code>data</code> differently.
It would be much simpler just to store an <code>int</code> or <code>long</code> and cast integer types to that, but if you really want to store varying data types, you might use a union (although unions are not widely used):

SUBMITTED

_GET['user'],md5($_POST

PRE

MID

$_POST['user']

filter_var($_POST['user'], FILTER_VALIDATE_EMAIL)

POST

SUBMITTED

_ball;
        label4.DataContext = _rightPad;

        var timer = new DispatcherTimer

PRE

I don't think you should be setting <code>DataContext</code> for each control like this. Instead, you should have a <em>view model</em> object that you set as the <code>DataContext</code> of the whole window. That view model would contain all the context objects that you need and you would use binding in your XAML to get to them.

Also, <code>label4</code> is a very bad name, you should use descriptive names for everything.

And if you do it this way, shouldn't <code>label9</code> be here too? (If the first label was called something like <code>LeftPadYPosition</code>, then it would be much easier to see that the label for right pad is missing here.)

MID

var timer = new DispatcherTimer();


POST

I believe this timer will be collected as soon as the garbage collector runs, which means it will stop ticking then. You should keep the timer in a field.

SUBMITTED

second);
                    data.clear();
                    break;
                }
            }
            if (it == MyFileMap.end() || MyFileMap.empty())
            {
                cout &lt

PRE

Again the input is one word each instead of lines. Data which includes the word <code>"pme"</code> would trigger the end.

MID

if (it == MyFileMap.end() || MyFileMap.empty())


POST

The second condition is redundant. If <code>MyFileMap.empty()</code> is <code>true</code>, then also <code>it == MyFileMap.begin() == MyFileMap.end()</code> at this point.

SUBMITTED

function paard

PRE

<strong>Extracting code into functions</strong>

MID

paard

POST

SUBMITTED

def punch(User user, User source) {
    user.userVersion++
    punch(user, source, null, null)
  }


 def punch(User user, User source, String latitude, String longitude) {

     UserPunch userPunch = new UserPunch()
     userPunch.punchClockStatus = user.punchClockStatus
     userPunch.user = user
     userPunch.job = user.job
     userPunch.task = user.task
     userPunch.date = new Date()
     userPunch.source = source
     userPunch.save(flush: true)
     if (latitude != null) {
        userPunch.latitude = latitude
        userPunch.longitude = longitude
     }
     if (userPunch

PRE

Controller actions may not be overloaded but non-action methods can be. So you can do something like this to keep the code as similar to the original as possible:

MID

def punch(User user, User source, String latitude, String longitude) {
    if (latitude != null) punchImpl(user, source, latitude, longitude)
    else punchImpl(user, source)
}

protected punchImpl(user, source) {
    ...
}

protected punchImpl(user, source, latitude, longitude) {
    ...
}


POST

Then you may as well think about putting the punch method overloads inside a service since controllers shouldn't contain "business" logic anyway.

SUBMITTED

static final long serialVersionUID = 1L;

    private static final String SETTING_A = "settingA";
    private

PRE

here you have the exact same functionality as you did before.... if the user wants to, they can compile-time type-check their values when they set them (by ensusuring the <code>Class&lt;T&gt;</code> parameter matches the <code>T setting</code> value

When they retrieve the value, they can cast the result to the specified type, or return null if it is not castable.

The functionality in <code>MyConfiguration</code> is unchanged, but, I recommend you use constants for the keys:

MID

private static final String SETTINGA = "settingA";
....


POST

Finally, you may want to consider your <code>DefaultConfiguration</code> extending something like HashMap directly.... like:

SUBMITTED

var customer = function(req){
    var customer = false;
    if(req.method == "POST") customer = req.body;
    if(req.method == "GET") customer = req.query;
    return customer;            
}

middleware.customer = function(req, res, next){
    req.customer = customer(req);
    return next

PRE

I think B is the best of the three, but here's another alternative using a simple lookup:

MID

middleware.customer = function(req, res, next){
  var methods = {POST: req.body, GET: req.query};
  req.customer = methods[req.method] || false;
  return next();
}


POST

SUBMITTED

Filter

PRE

You have presented similar code to this before, and while some of the recommendations I had have been implemented, others have not... ;-) This is fine, presumably you have your reasons, but the one that sticks out is the <code>public void includeInIfNeed(Filters filters)</code> method, which is redundant....

As for naming, I have a few recommendations:

MID

Filter

POST

SUBMITTED

OrderBookContainer::iterator it = buyContainer.insert(price_).first

PRE



MID

auto it = sellContainer.insert(price_).first;


POST

SUBMITTED

labelStyle.color = "red";
    }

    scoreContainer.textContent = "Score: " + score + " right answers out of " +
      quiz.length + " possible.";
  } else { // move to next question
    // setting up so

PRE

MID

scoreContainer.textContent = "Score: " + score + " right answers out of " +
  quiz.length + " possible.";

POST

SUBMITTED

println("Found string Item :  " + itemNo);

            // /GET

PRE

MID

Found string Item :

POST

SUBMITTED

var result = arr.map(function(item){return some_action(item);}).filter(function(item){return other_action

PRE

Your “functional” approach is overly complicated. Notice that this is completely equivalent:

MID

var result = arr.map(some_action).filter(other_action);


I.e. If you're only delegating to another function, you can specify that function directly. Also, an <code>== true</code> test is superfluous.

Your “procedural” variant is not equivalent, that would have to be:

var result = [];
arr.forEach(function(item){
    var changedItem = some_action(item);
    if (other_action(changedItem))
        result.push(changedItem);
});


Note that both variants have the same <em>algorithmic complexity</em>, and that the cost of iteration is likely negligible compared with the cost of <code>some_action</code> and <code>other_action</code>.

Functional programming does not mean unreadable code. Even if you're not just delegating to another function, you could improve formatting, e.g. to

var result = arr.map(function (item) {
  return some_action(item);
}).filter(function (item) {
  return other_action(item);
});


POST

SUBMITTED

fout.write(lineOut

PRE

MID

fout.write

POST

SUBMITTED

member[1], rate)


def mutate_pool(pool, rate=1):
    return [mutate_member(member, rate) for member in pool]


def create_random_gene():
    return random.choice([0, 1])


def create_random_genes(size):
    return [create_random_gene

PRE

Use generators instead of list-expressions:

MID

def mutate_pool(pool, rate=1):
    for member in pool:
        yield mutate_member(member, rate)


Yay, lazy lists! (kind of...)

Write code for the next person which will be reading it. You shouldn't put comments only where you had some trouble ("[::2] selects one gene out of two") but try to make any function easy to understand and modify in isolation.

Prefer longer functions and document them using docstrings. A nice function name is usually <strong>not</strong> enough for documentation:

def mutate_genes(genes, rate):
    """
    Given a list of genes, flip some of them according to rate.
    """
    for gene in genes:
        yield 1 - gene if random.random() &lt;= rate else gene

def mutate_pool(pool, rate=1):
    """
    Returns a new pool of member where every bit in every gene could have been
    flipped according to rate.
    """
    for member in pool:
        yield member[0], mutate_genes(member[1], rate)


POST

Of course those examples are a bit artificial but they do feel more pythonic. You don't have to document every function, just think about your readers. :)

Read nice Python code. I'd recommend <a href="https://github.com/django/django/blob/master/django/core/cache/backends/memcached.py" rel="nofollow">Django</a> and <a href="https://github.com/scikit-learn/scikit-learn/blob/master/sklearn/cross_decomposition/pls_.py" rel="nofollow">scikit-learn</a> (Those are links to specific files that I chose randomly.)

I think it's worthwhile to try to force yourself to write pythonic code for some time so that you can tell what's nice in "the Python way" and what's actually better in a functional style.

SUBMITTED

write_log(me)
  @log &lt;&lt; DateTime.now.to_s + " : " + me.to_s

PRE

The <code>@</code> variable prefix should only be used inside a class to denote instance variables. That said, for a script like this, you might like to wrap all the logic in a class (or rather a module since you don't need multiple instances).

Use string interpolation. So instead of

MID

DateTime.now.to_s + " : " + me.to_s


you can write

"#{DateTime.now} : #{me}"


POST

SUBMITTED

gt;Number

PRE

MID

Number

POST

SUBMITTED

Queue)malloc

PRE

MID

malloc

POST

Tell me about it, that is how I did it at first, and it turned out that the main function gave me a billion errors because apparently the first element of the queue should only be a pointer to the first real element.

I tested the above code by adding the following statement to the end of main:

SUBMITTED

lt;PL

PRE

MID

PL[]

List&lt;PL&gt;

Collection&lt;PL&gt;

POST

Your test case isn't really comprehensive. I've found the most robust tests to be of the following format:

SUBMITTED

require 'celluloid

PRE

MID

require

POST

SUBMITTED

call the

PRE

MID

the

the

POST

SUBMITTED

expression);
 
       
        } else if (expression.indexOf(&quot;*&quot;) &gt; 0 | expression.indexOf(&quot;/&quot;) &gt; 0) {
 
            int multPos = expression.indexOf(&quot;*&quot;);
            int divPos = expression.indexOf(&quot;/&quot;);
 
            pos = Math.min(multPos, divPos);
            if (multPos &lt; 0) pos = divPos; else if (divPos &lt; 0) pos = multPos; 
                //If one value of
                //*Pos will be

PRE

(<a href="http://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/StringUtils.html#containsAny%28java.lang.CharSequence,%20java.lang.CharSequence%29" rel="nofollow noreferrer">from Apache Commons Lang</a>)

The following lines also could be replaced with <code>StringUtils</code>:

MID

int multPos = expression.indexOf("*");
int divPos = expression.indexOf("/");

pos = Math.min(multPos, divPos);
if (multPos &lt; 0)
    pos = divPos;
else if (divPos &lt; 0)
    pos = multPos;


POST

Use <a href="http://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/StringUtils.html#indexOfAny%28java.lang.CharSequence,%20java.lang.CharSequence...%29" rel="nofollow noreferrer"><code>indexOfAny</code></a>:

SUBMITTED

h,WHITE_FADE_TEXT);
  }

  BOOL setTextColor(HANDLE h, WORD c)
  {
      return SetConsoleTextAttribute(h,c

PRE

If you're going to define your own enum then use it in your function declaration, i.e.:

MID

BOOL setTextColor(HANDLE h, COLOR c)


... not ...

BOOL setTextColor(HANDLE h, WORD c)


I'd usually use mixed-case e.g. <code>Color</code> instead of <code>COLOR</code> for an enum; and I'd worry that it's already been defined in a header file.

Also I'd split it into two parameters instead of doubling the number of enum values, for example:

BOOL setTextColor(HANDLE h, ConsoleColor foregound, ConsoleColor background)
{
    WORD color = foregound | (background &lt;&lt; 4);
    return SetConsoleTextAttribute(h, color);
}


POST

SUBMITTED

NULL,
  `postcode

PRE

MID

postcode

POST

SUBMITTED

right = NULL

PRE

MID

NULL

POST

SUBMITTED

numberorder = $row_Recordset5['MAX(numberorder)'] + 1 ;
}
else {  
    $numberorder

PRE

This is not so much a question about mysqli and php, but about databases and database theory.

Consider two simultaneous accesses to your page... they will both get the same result for:

MID

$numberorder = $row_Recordset5['MAX(numberorder)'] + 1 ;


POST

and they will both try to insert with the same ID value, and one of them will fail.

The AUTOINCREMENT system is designed to be concurrently safe, and guarantees that just one record has the value.

Depending on who you read/listen/pay attention to, you will get different answers, but, in your case, you really have to question: <em>Why do you need a special primary key?</em>. If the answer is because you want a value that fits some other format, well, then, there are other solutions.... for example, you can do the following:

SUBMITTED

System.out.println(new StringBuilder(new Integer(new Scanner(System.in).nextInt()).toString()).reverse().toString

PRE

In Java, and in Code Review, the preference is for creating both highly readable, and highly efficient code.

It is an almost bizarre fact, that one leads to the other.

your code has one efficiency, and that is space-on-disk.... it is neither readable, nor high-performance.

MID

System.out.println(new StringBuilder(new Integer(new Scanner(System.in).nextInt()).toString()).reverse().toString());


For a start, having to scroll off the page means you have to read with your mouse, not with your eyes.

Secondly, it is very hard to evaluate what parenthesis match when they are all clumped together.

Breaking your code down (which should not be necessary), we have:

int valinput = new Scanner(System.in).nextInt();
String stringinput = new Integer(valinput).toString();
String reversed = new StringBuilder(stringinput).reverse().toString();
System.out.println(reversed);


Now, you need error handling on the Scanner, and it needs to be closed as well. Without that, you have a program that is ugly when a user types in <code>123.0</code>.

Since you have no error handling, you may as well just junk the lines with the Integer...

And, there is no reason to convert the StringBuilder to a String directly...

Without error handling, you can:

System.out.println(new StringBuilder().append(scanner.nextInt()).reverse());


POST

That is, effectively equivalent to your code, but it has different error-condition characteristics..

Also, it is, suprisingly, quite readable, and fast.

Now, all you need is the try/catch for the scanner, and you are sorted.

SUBMITTED

ulong)enu.Current[propertyName]);
        }
    }

    private ulong BytesToMegaBytes(ulong bytes)
    {
        return bytes / (ulong)1024;
    }
}

public class Win32ComputerSystem
{
    public string GetName()
    {
        return GetProperty("Name");
    }

    public string GetManufacturer()
    {
        return GetProperty("Manufacturer");
    }

    public string GetModel()
    {
        return GetProperty("Model");
    }

    private string GetProperty(string propertyName)
    {
        ManagementObjectSearcher moSearcher = new ManagementObjectSearcher
            ("SELECT " + propertyName + " FROM Win32_ComputerSystem");
        using (var enu = moSearcher.Get().GetEnumerator())
        {
            if (!enu.MoveNext()) return "Unable to retrieve " + propertyName + " from Win32_ComputerSystem!";
            return enu.Current[propertyName].ToString

PRE

Should I keep them separated in different classes based on the Win32 class for organizational purposes?

Clean Code also suggest small classes. They have different <a href="https://en.wikipedia.org/wiki/Single_responsibility_principle" rel="nofollow">responsibility</a>, so I think they are fine.

(<em>Clean Code</em> by <em>Robert C. Martin</em>: <em>Chapter 10: Classes</em>, <em>Classes Should Be Small!</em>)

Should I use a parent partial class and split these into different files?

Please don't! It would be useful to remove the duplication of <code>GetProperty</code> but using inheritance for that is an overkill. There is a better solution: composition. Create a <code>PropertyGetter</code> class and move the getter logic into that:

MID

public class PropertyGetter {

    public string GetStringProperty(string propertyName, string tableName)
    {
        ManagementObjectSearcher moSearcher = new ManagementObjectSearcher
            ("SELECT " + propertyName + " FROM " + tableName);
        using (var enu = moSearcher.Get().GetEnumerator())
        {
            if (!enu.MoveNext()) {
                return "Unable to retrieve " + propertyName + " from " + tableName;
            }
            return enu.Current[propertyName].ToString();
        }
    }

    private ulong GetUlongProperty(string propertyName, string tableName) {
        ...
    }
}


POST

The use that class from <code>Win32ComputerSystem</code> and <code>Win32OperatingSystem</code>:

SUBMITTED

counts.get((seq[i], seq[i + 1]), 0) + 1
    states = list(set(k[0] for k in counts.keys()))
    for s in states:
        if reverse:
            sCounts = dict((k,v) for (k,v) in counts.items() if k[1] == s

PRE

(If you are concerned about memory use, then you could use  <a href="http://docs.python.org/3/library/itertools.html#itertools.islice"><code>itertools.islice</code></a> and write <code>islice(seq, 1, None)</code> instead of <code>seq[1:]</code> to avoid the copy.)

In this code:

MID

for s in states:
    sCounts = dict((k,v) for (k,v) in counts.items() if k[0] == s)


POST

you iterate over the whole of <code>counts</code> for every state, collecting the ones you want. It would be more efficient to iterate only over the transitions from <code>s</code>. See below for how this would look.

SUBMITTED

have the exact same
     * number of arguments as the given event template.
     */
    template&lt;typename... Args&gt;
    void operator()(Args... args)
    {
        for (typename std::list&lt;Delegate&gt;::iterator i = events.begin(); i != events.end(); ++i)
        {
            (*i)(args...);
        }
    }

private: // Private variables
    std::list&lt;Delegate&gt; events;

public:
    class Delegate
    {
    private: // Type

PRE

The first is obvious, the second is slightly misleading, and the third is completely wrong (I know you meant <code>std::shared_ptr</code>, but having an incorrect comment is worse than no comment at all).

Your <code>operator()</code> should probably be using perfect forwarding instead of passing a copy of all the arguments. Also, since you're already using lambdas and variadic templates, you might as well take advantage of auto and/or range based for loops:

MID

template&lt;typename... Args&gt;
void operator()(Args... args)
{
    for (typename std::list&lt;Delegate&gt;::iterator i = events.begin(); i != events.end(); ++i)
    {
        (*i)(args...);
    }
}


I'd change this to:

template&lt;typename... Args&gt;
void operator()(Args&amp;&amp;... args)
{
    for (auto i = events.begin(); i != events.end(); ++i)
    {
        (*i)(std::forward&lt;Args&gt;(args)...);
    }
}


POST

Similarly for the <code>operator()</code> in <code>Delegate</code>.

Instead of using <code>new</code> in:

SUBMITTED

var applyData

PRE

You are using the built-in <code>sort</code> of <code>Array</code>, which is not guaranteed to be stable per the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort" rel="nofollow">documentation</a>. You will have to write your own sort algorithm from scratch.

Other than that, 

MID

var

POST

SUBMITTED

printf("\n");
    return 0;
}

int gotenough(void) {
    static int n = 0;
    n += 1;
    return (n == 10);
}

int main(void) {
    unsigned afewseconds = 3;
    char

PRE

This isn't a standard way to do a counter.

MID

int gotenough(void) {
    static int n = 0;
    n += 1;
    return (n == 10);
}


Is your method <code>killdata()</code> trying to erase your <code>struct</code>?

int killdata(struct ConnData *cd) {
    /* nothing to do */
    (void)cd;
    return 0;
}


POST

Throwing your data into a <code>void</code> container doesn't "kill" it.  You need to go through each of the <code>struct</code> members and set them to <code>NULL</code>. 

I've re-written your code completely into a more portable program, that accomplishes the basic functionality that your program does.  As you can see from the length of my program to your program, this isn't a very hard task to accomplish without using the internet.

SUBMITTED

var input = '',
  guess = '',
  montyPswrd = 'Cheese',
  montyUser = 'Monty',
  chipUser = 'Chip',
  chipPswrd = 'Gadget';

var

PRE

This is tagged <a href="/questions/tagged/programming-challenge" class="post-tag" title="show questions tagged &#39;programming-challenge&#39;" rel="tag">programming-challenge</a>, but just to be sure it's said: This obviously is <strong>not</strong> secure in any sense; the passwords are in the source.<br>
Anyway, I'm assuming security isn't the point.

First of all: Spellcheck. "<em>useranme</em>" and "<em>Your</em> not chip/monty".

Secondly, my question is "why 2 users?" What if it's 3? Or 6,123,345? Right now you'd have to duplicate <em>everything</em> in your code to accommodate more users. Obviously that'll be extremely cumbersome.

A much better approach is to write code to check <em>any</em> given user/password against a <em>list</em> of users (rather than named variables).

So, first we'll need a list of users (or, in this case, a JS object):

MID

var users = {
  'Monty': 'Cheese',
  'Chip':  'Gadget'
};


POST

Then, some login logic (this can be a function, or several functions, or many other things - this is just a simple implementation)

SUBMITTED

int[] a1

PRE

MID

a1

POST

SUBMITTED

lt;Node

PRE

<code>Graph</code>, as other data structures in general, should be declared 
<code>public</code>. Because you want them to be able to be used outside of the 
package they are declared in. 

<code>nodes</code>, <code>vertices</code> should be <code>private</code> so that you <em>can</em> know that they 
are not changed outside the <code>Graph</code> class. 

<code>nodes</code> should not be a <code>LinkedList</code>. You must depend on abstractions as 
much as possible. You should prefer <code>interface</code>s such as <code>List</code> over 
specific implementations <code>LinkedList</code>.

Nodes of a graph is not a <code>List</code>, it is a <code>Set</code>. A standard graph cannot 
have multiple copies of a node. You should prefer a <code>Set</code> to represent a 
set unless you have a good reason. 

MID

Node

POST

All of the above points also apply to <code>Node</code>. Apart from those: 

<code>AdjacenctNode</code> should be named <code>adjacentNode</code> by Java naming 
convention. 

Feel free to remove parameterless call to <code>super();</code>, although Eclipse 
adds it by default, it's just noise. 

SUBMITTED

lt; std:: endl;
        return

PRE

MID

std::endl

endl

POST

SUBMITTED

private List&lt;SomeClazz&gt; populateBeansWithErrors(final Map&lt;SomeClazz, Errors&lt;String&gt;&gt; errorsMap) throws FinancialsSystemRuntimeException {
        final List&lt;SomeClazz&gt; someObjs = new ArrayList&lt;&gt;();

        for ( final Entry&lt;SomeClazz, Errors&lt;String&gt;&gt; entry : errorsMap.entrySet() )
        {
            SomeClazz someObj = entry.getKey();
            final Errors&lt;String&gt; errors = entry.getValue();
            populateErrorColumns(someObj, errors);
            someObjs.add(someObj);
        }

        checkAndSetErrorColumnsForValidRecords

PRE

For naming here:

MID

private List&lt;SomeClazz&gt; populateBeansWithErrors(final Map&lt;SomeClazz, Errors&lt;String&gt;&gt; errorsMap)
        throws FinancialsSystemRuntimeException {
    final List&lt;SomeClazz&gt; someObjs = new ArrayList&lt;&gt;();
    ...
    return someObjs;
}


POST

I'd rename to <code>someObjs</code> to <code>result</code> to express its purpose.

The name of the following variables are too similar to each other:

SUBMITTED

png');
elem = document.getElementById('directions');
directionSlide();
}

//Creates a

PRE

You are actually storing a reference to an element here:

MID

elem = document.getElementById('directions');


POST

However, you should call <code>elem</code> differently, probably <code>directions</code>. Also, you should consider caching <code>document.getElementById('jajo')</code> since you use it a ton of times.

There is a clear mapping in your code between key presses and images, you could write your <code>keydown</code> handler like this:

SUBMITTED

cardnumber &gt; 9999999999999)
    {
        printf("INVALID\n");
        return 0;   
    }

    char creditcard[17];
    sprintf(creditcard, "%f", cardnumber);
    char* ptr_cc;
    ptr_cc = strtok(creditcard,".");
    int card_size = strlen(ptr_cc);
    int sum = 0;
    for(int i = 1; i &lt; card_size; i+=2)
    {
        int x = creditcard[card_size-1-i] - '0';
        int prod = 2 * x;
        if(prod&gt;=10)
        {
            prod = prod%10 + prod/prod%10;
        }
        sum += prod;      
    }
    for(int i = 0; i &lt; card_size; i+=2)
    {
        int x = creditcard[card_size-1-i] - '0';
        sum += x;      
    }
    if(sum%10 != 0)
    {
        printf("INVALID\n");
        return 0; 
    }
    else if(creditcard[0] == '4')
    {
        printf("VISA\n");
        return 0; 
    }
    else if(creditcard[0] == '3' &amp;&amp; (creditcard[1] == '7' || creditcard[1] =='4'))
    {
        printf("AMEX\n");
        return 0; 
    }
    else if(creditcard

PRE

As @Keith says, credit card numbers should be treated as strings, not numbers, and definitely not floating-point numbers.  If you want to ensure that the input contains only digits (and maybe spaces), use <code>strspn()</code>.  Squeeze out any spaces, then validate the length using <code>strlen()</code>.

The Luhn checksum check should be in its own function.  The loop indexes would be more natural counting down, I think, since you are taking every other digit starting from the right.

MID

int is_valid_luhn(const char *creditcard)
{
    int card_size = strlen(creditcard);
    int sum = 0;
    for(int i = card_size - 2; i &gt;= 0; i -= 2)
    {
        int digit = creditcard[i] - '0';
        int prod = 2 * digit;
        sum += prod / 10 + prod % 10;      /* No special case needed */
    }
    for(int i = card_size - 1; i &gt;= 0; i -= 2)
    {
        sum += creditcard[i] - '0';
    }
    return sum % 10 == 0;
}


POST

SUBMITTED

_POST['params']))
    {
        if (sizeof($_POST['params']) &gt; 1)
        {
            $method = filter_input(INPUT_POST, 'method', FILTER_SANITIZE_STRING);
            $class = filter_input(INPUT_POST, 'class', FILTER_SANITIZE_STRING);
            $params = filter_input(INPUT_POST, 'params', FILTER_DEFAULT, FILTER_REQUIRE_ARRAY);
            $methodToCall = $class . "::" . $method

PRE

For now, here is what I have noticed. I'll come back when I get some time to take a better look.

I'm seeing some repetition in that initial try statement too. It looks as though you can take

MID

$method = filter_input(INPUT_POST, 'method', FILTER_SANITIZE_STRING);
$class = filter_input(INPUT_POST, 'class', FILTER_SANITIZE_STRING);
$methodToCall = $class . "::" . $method;


POST

and place it outside of the <code>if</code> statements.

Also, to better organize your errors, and keep a better record of error recording, I'd consider you create your own exception classes that extend the built-in <code>Exception</code> object, or use the SPL exceptions.

For instance, you could, in <strong>Controller.php</strong>, throw a  <code>InvalidParameterCallException</code>, <code>MethodExistanceException</code>, and a <code>FunctionCallException</code>. In your first file, you can use multiple <code>catch</code> statements to properly handle anything that's thrown. Like:

SUBMITTED

if self._finished:
            raise self.StopExecution()
        elif call(self._value) or self._fall_through:
            self

PRE

I like your trick to create this syntactic sugar.  The implementation is also pretty good, as are the doctests.

I think it would be nice if a <code>case()</code> could test for multiple values.   A <code>case('jack', 'queen', 'king')</code> should match if the <code>Switch</code> was created with any of those three strings.

It would also be nice if there were a <code>case.match()</code> that performed a regular expression match.

If execution ends up inside <code>case.call()</code> due to fall-through, then I would expect the test function not to be called at all, as a kind of short-circuiting behaviour.  Specifically,

MID

elif call(self._value) or self._fall_through:


should be reversed and written as

elif self._fall_through or call(self._value):


POST

Having a parameter named <code>call</code> when the method is also named <code>call</code> is confusing.  I suggest renaming the parameter to <code>test</code>.

Avoid testing variables for equality with <code>True</code> and <code>False</code> explicitly.  Just use boolean expressions.  For example, in <code>__exit__()</code>, change

SUBMITTED

case Actions.Idle:
                Idle();
                return;

            case Actions.MoveDown:
            case Actions.MoveLeft:
            case Actions.MoveRight:
            case Actions.MoveUp:
                Animate(action);
                return;
        }
    }

    public void Idle()
    {
        foreach (var sprite in sprites)
        {
            sprite.Idle();
        }
    }

    public void Animate(Actions action)
    {
        foreach (var sprite in sprites)
        {
            sprite.Animate(action

PRE

Looks pretty neat overall, I merely glanced at your code (favorited, I want to look at this more deeply, as I'm [<em>playing with</em> | <em>learning</em>] XNA myself, your XNA posts are very useful!).

One thing I've noticed, I don't think you need this <code>switch</code> block:

MID

public void Listen(Actions action)
{
    switch (action)
    {
        case Actions.Idle:
            Idle();
            return;

        case Actions.MoveDown:
        case Actions.MoveLeft:
        case Actions.MoveRight:
        case Actions.MoveUp:
            Animate(action);
            return;
    }
}


Instead, I'd probably do this:

public void Listen(Actions action)
{
    Animate(action);
}


POST

...and in <code>Animate(Actions)</code> I'd add the call to <code>Idle()</code> and exit <code>if (action == Actions.Idle)</code>. "Being idle" <em>does</em> involve choosing a location on the sprite sheet, I don't see why it would be handled in <code>Listen</code> when everything else is in <code>Animate</code>.

Also in <code>switch</code> blocks you should use <code>break;</code>, and let the function <code>return</code> by itself.

SUBMITTED

exploded-state-2"]');
    var CloseButton = $('.button-close');
    ExplodedEl.hide(); // default exploded content is hidden
    ExplodedEl2.hide();
    CloseButton.hide();
    ExplodedContentWidget.on('click',function(){
            ExplodedEl

PRE

This : 

MID

ExplodedEl.hide(); // default exploded content is hidden
ExplodedEl2.hide();
CloseButton.hide();


POST

I would have addressed with a css class that hides these elements

SUBMITTED

property
def risk_status(self):
    """ This function assigns numeric weight to risks. It returns an over all integer score. """

    # Build a string of risks, ie "High Risk@At Risk@@Extreme Risk"
    raw_string_of_risks = self.si_risk + '@' + self.aggbs_risk + '@' + self.cfimb_risk + '@' + self.cfiab_risk + '@' + self.cei_risk

    # Build a list ["High Risk", "At Risk", "Extreme Risk"]
    risks = raw_string_of_risks.split('@')

    # Formula for over all risk status. ["High Risk", "At Risk", "Extreme Risk"] =&gt; 2+1+3 = 6
    status = risks.count("At Risk")*1 + risks.count("High Risk")*2 + risks.count("Extreme Risk")*3

    return status

PRE

Concatenating an splitting seems like you're making extra work for yourself.  I suggest summing the results of a string-to-integer translation.

MID

from collections import defaultdict

_RISK_SCORE = defaultdict(int, [('Extreme Risk', 3), ('High Risk', 2), ('At Risk', 1)])

@property
def risk_status(self):
    """ This function assigns numeric weight to risks. It returns an overall integer score. """
    return sum(self._RISK_SCORE[r] for r in (
        self.si_risk,
        self.aggbs_risk,
        self.cfimb_risk,
        self.cfiab_risk,
        self.cei_risk,
    ))


POST

SUBMITTED

Fake head

PRE

MID

head

POST

SUBMITTED

Child.prototype

PRE

MID

prototype

POST

Other than that,

SUBMITTED

applyToEveryPair :: ((a,a) -&gt; [(a,a)]) -&gt; [a] -&gt; [[a]]
applyToEveryPair f (xs) = do i&lt;-[0..length xs - 1]
                             j&lt;-[0..length xs - 1]
                             guard (i /= j)
                             (x',y') &lt;- f (xs !! i, xs !! j)
                             return . setList i x' . setList j y' $ xs

-- | setList n x xs replaces the nth element in xs by x                             
setList :: Int -&gt; a -&gt; [a] -&gt; [a]
setList = go 0 where
    go _ _ _ [] = []
    go i n x' (x:xs) | i == n    = x':xs
                     | otherwise = x:(go (i

PRE

Using the <code>.~</code> operator, the value of a lens can be set. So to remove need for the <code>setList</code> funtion, just use this:

MID

applyToEveryPair2 :: ((a,a) -&gt; [(a,a)]) -&gt; [a] -&gt; [[a]]
applyToEveryPair2 f (xs) = do i&lt;-[0..length xs - 1]
                              j&lt;-[0..length xs - 1]
                              guard (i /= j)
                              (x',y') &lt;- f (xs !! i, xs !! j)
                              return . (ix i .~ x') . (ix j .~ y') $ xs


POST

The other thing to notice about your code is it will call every pair of elements twice: eg it will call the supplied function with the item at index 2 and 5, then with the items at indexes 5 and 2. I'm not sure if this is intended.

SUBMITTED

paddle.png", "paddle", renderer);

//starting speed and directions
xSpeed = rand() % 8 + 5;
ySpeed = rand() % 8 + 5;

reset();

m_Running = true;

return

PRE

Checking error codes is also somewhat old fashioned. I would recommend throwing exceptions instead.

I see that you are using <code>rand()</code> right here.

MID

//starting speed and directions
xSpeed = rand() % 8 + 5;
ySpeed = rand() % 8 + 5;


POST

I do not see you using <a href="http://www.cplusplus.com/reference/cstdlib/srand/" rel="nofollow noreferrer">srand()</a> anywhere though. Without <code>srand()</code>, your random number generator seed will always be the same and you will always get the same results.

Even better, since you are using C++11, I would recommend using functions from the new <a href="http://www.cplusplus.com/reference/random/" rel="nofollow noreferrer"><code>&lt;random</code>> header</a>. Since you are looking for a random number in the range [5,12], here is a rough example:

SUBMITTED

replaceAll

PRE

Here you can see, that because of four regex replaces, you create four times a <code>StringBuffer</code>, which is synchronized, and a <code>String</code> object, which can count up if you are processing tons of tweets.

There are two things you can do:

MID

replaceAll

POST

SUBMITTED

myListener1;
  }

  @Override
  public void onResult(String result){
    myListener1.onResult(id, result

PRE

A listener and callback mechanism is a common pattern in many places in Java.

The logical place to look for examples is in the Swing API. Will get back to that in a second, but, there are two items that are useful first:

Instead of using an <code>int</code> value to track the source of the event/Task, you should use the task itself.

MID

   public void onResult(String result){
     myListener1.onResult(this, result);
   }


The Listener itself should implement an interface, something like: <code>TaskResultListener</code>:

 public interface TaskResultListener {
     public onResult(Task task, String result);
 }


POST

and the constructor for the Task should take an instance of a <code>TaskResultListener</code> instead of a <code>MyListener1</code>

For examples of how this is used, consider the <code>ActionListener</code> interface and usage in Swing:

In the Swing API, it is common to have support for multiple listeners. You have just one. That is OK.

SUBMITTED

monitor.getServerInfo().then().printDetails

PRE

Anyway: You can't get this code

MID

monitor.getServerInfo().then().printDetails()


because that would be <em>synchronous</em>, not asynchronous. The interpreter would have to wait in the middle of the chain before it could call <code>printDetails</code>. And it doesn't wait - that's the point of asynchronicity.

And that's why <code>then()</code> always returns a promise object (and nothing else), because it can return that right away without any waiting.

So your current code

monitor.getServerInfo().then((monitor) -&gt; monitor.printDetails())


POST

is the way to do it. Of course, it doesn't make much sense to have a <code>printDetails</code> method in your <code>Monitor</code>, if it doesn't always work. Right now, you can just call

SUBMITTED

gt; SupportedDiagnostics

PRE

MID

SupportedDiagnostics

POST

SUBMITTED

var leftTemp = mergeSort(left);
  var rightTemp = mergeSort(right);

  var result = merge(leftTemp, rightTemp)

  result

}

}

def merge(left: ArrayBuffer[Int], right: ArrayBuffer[Int]): ArrayBuffer[Int] = {

var result = ArrayBuffer[Int

PRE

The expression <code>merge(x,y)</code> will always return a value. <code>val r = merge(x,y)</code> stores the value so that you can use it again.

You could write your code 

MID

var leftTemp = mergeSort(left);
var rightTemp = mergeSort(right);

var result = merge(leftTemp, rightTemp)

result


as

merge(mergeSort(left),mergeSort(right))


POST

It is a matter of preference if you wish to use <code>leftTemp</code> and <code>rightTemp</code> like this, but the use of <code>result</code>, and then returning it on the next line is not idiomatic Scala.

You must assign values to an identifier when you want to use them more than once (as you do with <code>temp</code> in your final example). But as I said above you may want to do this for other reasons such as readability and keeping down line lengths.

SUBMITTED

index)
    {
        if (!range.contains(index)) {
            final TextRange textRange = decoder.getRange(index);
            range = textRange.getCharRange();
            buffer = loader.load(textRange);
        }
        return buffer.charAt(index - range.getLowerBound

PRE

and change the visibility in <code>CurrentBuffer</code>, it's a private nested class so you're not breaking encapsulation any way. This will put less strain on the GC.

Also, if there is any reason to believe that <code>charAt()</code> is progressing even roughly linearly through the indices, a pre-fetch running in the background would speed things up.

So with the stats from the comments, the lines executed 99% of the time is:

Not thread safe:

MID

    if (!range.contains(index)) {
        // Branch not taken
    }
    return buffer.charAt(index - range.getLowerBound());


Thread safe:

    final CurrentBuffer buf = CURRENT_BUFFER.get();
    if (buf.containsIndex(index)) // Branch taken
        return buf.charAt(index);
    ... stuff on the stack ...


<em>Set speculation hat: On</em>

The JIT should inline expand the function calls to <code>buf.containsIndex()</code> and <code>buf.charAt</code>, it should also not do anything with the stack variables (not even initializing). So the remaining difference is <code>CURRENT_BUFFER.get()</code> and the book keeping associated with the <code>buf</code> variable which could make or break here as you're only doing a few instructions to fetch the data every time. Adding a few book keeping instructions on the <code>buf</code> variable could have a big impact in your case. I would investigate if I could get rid of it somehow, maybe encapsulate it somehow so the same instance is used in all calls. 

Now if you doubt your JVM is good, you can try to inline the two function calls manually and restructure the thread safe variant like this:

    final CurrentBuffer buf = CURRENT_BUFFER.get();
    if (!buf.containsIndex(index)){
        final TextRange textRange = decoder.getRange(index);
        final IntRange range = textRange.getCharRange();
        final CharBuffer buffer = loader.load(textRange);
        CURRENT.set(new CurrentBuffer(range, buffer));
        return buffer.charAt(index - range.getLowerBound());
    }
    return buf.charAt(index);


POST

just in case the JVM is unable to deduce that those stack variables shouldn't be initialized unless you actually get there. 

SUBMITTED

var idx

PRE

MID

idx

POST

SUBMITTED

accountCount = 0;
                //prepare list of abonnementen to save;
                List&lt;acm_abonnement&gt; updatedAbonnements = new List&lt;acm_abonnement&gt;();
                //Loop over all accounts;
                foreach (Account crmAccount in crmAccounts)
                {
                    ExtractAbonnementenFromCrmAccount(crmAccount, ref updatedAbonnements, ref abonnementen, ref accountCount

PRE

The <code>XmlQueryBuilder&lt;TEntity&gt;.ToString()</code> method could use some Linq-to-Xml to produce the XML string in a strongly-typed way. In two words: <em>avoid magic strings</em> ;)

<sub><em>(I might implement such a class later, and put it up for review ;)</em></sub>

It's not clear whether your API is French, English or German:

MID

//Loop over all accounts;
foreach (Account crmAccount in crmAccounts)
{
    ExtractAbonnementenFromCrmAccount(crmAccount, ref updatedAbonnements, ref abonnementen, ref accountCount);
}


POST

<code>crmAccount</code> and <code>accountCount</code> both sound English, <code>updatedAbonnements</code> is <em>Frenglish</em>, <code>abonnementen</code> sounds German, and <code>ExtractAbonnementenFromCrmAccount</code> looks like a mix of English and German, which isn't ideal. I'd try to stick to a single language, as much as possible. It looks like you have to cope with a somewhat multilingual API though.

The naming conventions aren't clear either. I'd stick to the C# conventions for everything I have control over, and use <em>PascalCase</em> for types and public/exposed members, and <em>camelCase</em> for locals and parameters - <em>alllowercase</em> isn't an option! Also, drop the random single-letter prefixes, like <code>s</code> on <code>sBuilderContract</code> - a typical name for a <code>StringBuilder</code> instance is just <code>builder</code>. <code>oResponseAccount</code> is also not clear about why it needs a &quot;o&quot; prefix (is that for &quot;object?&quot; - <strong>everything</strong> in .NET is an <code>object</code>!)...

I think there's too much <code>static</code> going on here. It's static that blew up the <a href="http://en.wikipedia.org/wiki/Hindenburg_disaster" rel="nofollow noreferrer">Hindenburg</a> - it's best to avoid <code>static</code> classes and methods, and to instantiate your service instead, so that you can reduce <em>coupling</em> and run unit tests that isolate and control these dependencies, if possible.

SUBMITTED

size)
        mp_release

PRE

MID

mp_release

POST

Within <code>mp_release</code>, there is no error checking.  This might be OK if we're looking for extreme performance, but it might be nice to have at least a debug version that checks that <code>mem</code> actually points to a slot.  For that to work, of course, you'll have to add at least one more variable to the structure to contain the <code>size</code> parameter.

SUBMITTED

Rooney")

A1

PRE

MID

A1

POST

SUBMITTED

clock()
            if (tonePlayed):
                print

PRE

Avoid using parenthesis in if conditions. Replace 

MID

if (tonePlayed):


with 

if tonePlayed:


Write the main routine inside a <code>main()</code> function and call this function like the following

if __name__ == "__main__":
   main()


POST

SUBMITTED

self, fbUser="me"):

    profile = self.readTag(fbUser, "")
    self

PRE

Similarly, since the default tag is <code>""</code> in your <code>readTag</code> method, you could simplify this:

MID

profile = self.readTag(fbUser, "")


to simply:

profile = self.readTag(fbUser)


POST

In this and another loop, I don't see the loop variable <code>pages</code> used at all:

SUBMITTED

nothing
  }

  light_ptr(light_ptr const&amp; other) { *this = other; }

  light_ptr(light_ptr&amp;&amp; other) noexcept

PRE

For some reason your destructor is in the middle. So you have some constructors on either side. 

Copy constructor:

MID

light_ptr(light_ptr const&amp; other) { *this = other; }


POST

That's not the copy and swap idiom (seems to be the inverse). May throw a few people. If you are not going to use standard idioms them you should have a go at explaining why.

Not sure this is helpeful:

SUBMITTED

read ds), "")]
  where (ns, (_:ds)) = break (=='/') r

reduce :: Rational' -&gt; Rational'
reduce a = Rational' (n `div` common) (d' `div` common)
  where (Rational' n d) = a
        d'
          | (d == 0)    = divByZero n
          | otherwise   = d
        common = (gcd n d') * (signum d

PRE

I would define <code>reduce</code> like this

MID

reduce (Rational' n 0) = divByZero n
reduce (Rational' n d) = Rational' (n `div` common) (d `div` common)
  where common = (gcd n d) * (signum d)


POST

SUBMITTED

int size

PRE

MID

size

POST

SUBMITTED

def addlist(LL1, LL2):
    storage = []
    multiplier = 1
    total = 0
    while LL1 != None:
        storage.append(LL1.data)
        LL1 = LL1.next
    for i in storage[::-1]:
        total += i*multiplier
        multiplier *= 10
    storage = []
    multiplier = 1
    while LL2 != None:
        storage.append(LL2.data)
        LL2 = LL2.next
    for j in storage[::-1]:
        total += j*multiplier
        multiplier *= 10
    return total

PRE

Your method has the same code duplicated twice in it. You should always try to eliminate this kind of duplication, for example like this:

MID

def addlists(LL1, LL2):
    return sumlist(LL1) + sumlist(LL2)

def sumlist(LL1):
    storage = []
    multiplier = 1
    total = 0
    while LL1 != None:
        storage.append(LL1.data)
        LL1 = LL1.next
    for i in storage[::-1]:
        total += i*multiplier
        multiplier *= 10
    return total


The logic can be simplified, a lot:

def sumlist(ll):
    total = 0
    while ll:
        total *= 10
        total += ll.data
        ll = ll.next
    return total


POST

I also simplified the <code>None</code> comparison, instead of <code>if ll != None</code> you can write simply <code>if ll</code>

The convention is to use lowercase variable names, so it would be better to change <code>LL1</code> and <code>LL2</code>.

SUBMITTED

params) 
    cars

PRE

MID

cars

POST

SUBMITTED

DROP PROCEDURE IF EXISTS sp_RealAmtPayment;
DELIMITER //
CREATE PROCEDURE sp_RealAmtPayment()

BEGIN
-- declare a counter
SET @start = (SELECT MIN(payment_id) FROM payment);
SET @stop  = (SELECT MAX(payment_id) FROM payment);

WHILE @start &lt;= @stop
DO
    UPDATE payment AS p
        INNER JOIN customer AS c
            ON p.customer_id = c.customer_id
    SET real_payment = (p.amount * c.multiplier)
    WHERE p.payment_id = @start;
    SET @start = @start + 1;
END WHILE;
END//
DELIMITER

PRE

I've never played with <a href="/questions/tagged/mysql" class="post-tag" title="show questions tagged &#39;mysql&#39;" rel="tag">mysql</a>, so this may be completely wrong, but if I get it right the <code>WHILE</code> loop would be the equivalent of a T-SQL <code>CURSOR</code>, which is inherently slow.

You're essentially looping on <code>payment_id</code>, incrementing at each iteration - this <em>assumes</em> the ID's are contiguous, which isn't a safe assumption to make with data: if records were deleted, you have more iterations than records:

MID

SET @start = (SELECT MIN(payment_id) FROM payment);
SET @stop  = (SELECT MAX(payment_id) FROM payment);

WHILE @start &lt;= @stop
DO
    UPDATE payment AS p
        INNER JOIN customer AS c
            ON p.customer_id = c.customer_id
    SET real_payment = (p.amount * c.multiplier)
    WHERE p.payment_id = @start;
    SET @start = @start + 1;
END WHILE;


POST

In pseudo-code, this can read as follows:

SUBMITTED

class UserRepo

PRE

MID

UserRepo

POST

SUBMITTED

division
import urllib, json

#bio_dict is

PRE

Different module <code>import</code>s should not go on the same line:

MID

import urllib, json


POST

They should have their own line. If you are importing submodules, then you can have multiple imports on the same line:

SUBMITTED

namespace WindowsFormsApplication1
    {
      public interface ICarfactory
      {
        ICar getCar(CarType carType);
      }

      public interface ICar
      {
      }

      public class

PRE

First thing that pops in my head is that <em>camelCase</em> for methods (<code>getCar</code>) is not actually usable in <a href="/questions/tagged/c%23" class="post-tag" title="show questions tagged &#39;c#&#39;" rel="tag">c#</a>, in my opinion it looks really ugly and makes it look like <a href="/questions/tagged/java" class="post-tag" title="show questions tagged &#39;java&#39;" rel="tag">java</a> code. You should use <em>PascalCase</em> for all public members:

MID

public interface ICarfactory
{
    ICar GetCar(CarType carType);
}


POST

More info on <a href="http://msdn.microsoft.com/en-us/library/x2dbyw72%28v=vs.71%29.aspx" rel="nofollow">MSDN</a>.

SUBMITTED

def addactions

PRE

First off, your code is looking a lot better than what I remember seeing it before. You've taken a nice step towards good code.

Now onto my suggestions:

MID

addactions

POST

SUBMITTED

ProcCountLines(Me.Name, vbext_pk_Proc)
    Else
        RaiseObjectNotIntializedError
    End If
End Property

Public Sub Initialize(Name As String, CodeMod As CodeModule)
    Me.Name = Name
    Me.ParentModule = CodeMod
End Sub

Public Property Get Lines() As String
    If isParentModSet And isNameSet Then
        Lines = Me.ParentModule.Lines(Me.startLine, Me.CountOfLines)
    Else
        RaiseObjectNotIntializedError
    End If

PRE

Also you're using <code>camelCase</code> for <code>Private</code> procedures and functions, which is confusing. I wouldn't make that distinction between <code>Private</code> and <code>Public</code>, and use <code>PascalCase</code> for all members, regardless of their accessibility.

The <code>vbeProcedure</code> class <em>desperately wants</em> to be immutable, unfortunately unless you make the setters (<em>letters?</em>) <code>Friend</code> and compile them into their own DLL (which VBA can't do), there's no way this can work, so you're stuck with settable properties that are meant to be get-only.

You've done well extracting the <code>RaiseObjectNotInitializedError</code> and <code>RaiseReadOnlyPropertyError</code> code into their own methods, however I'd push the DRY-ing up a step further and create a <code>Private Sub ValidateIsInitialized()</code> procedure whose responsibility would be to call <code>RaiseObjectNotInitializedError</code> when <code>ParentModule</code> is <code>Nothing</code> (no need to check for an empty name then), and then this:

MID

Public Property Get Lines() As String
    If isParentModSet And isNameSet Then
        Lines = Me.ParentModule.Lines(Me.startLine, Me.CountOfLines)
    Else
        RaiseObjectNotIntializedError
    End If
End Property


Can turn into that:

Public Property Get Lines() As String
    ValidateIsInitialized
    Lines = Me.ParentModule.Lines(Me.StartLine, Me.CountOfLines)
End Property


POST

The <code>Name</code> property setter (<em>letter</em>?) can simply throw an error if the new value is <code>vbNullString</code>, as part of regular value validation.

I'm surprised this works:

SUBMITTED

Integer
Dim strCOMP_NAME1 As String
Dim strPAR1 As String
Dim strREF2 As String
Dim strREFnew As String
Dim intNB2 As Integer
Dim strCOMP_NAME2 As

PRE

First and foremost, use <code>Option Explicit</code> in all of your code modules. It forces you to declare all of your variables. You have about 20 declarations at the top of your module, but haven't declared your recordsets at all. 

These are never used I didn't check the rest of them:

MID

Dim strCOMP_NAME As String
Dim strCOMP_NAME1 As String
Dim strCOMP_NAME2 As String


POST

The hungarian notation isn't necessary either. Things like <code>lngCurrDocTblRecordCount</code> aren't necesary in the modern IDE. I'm sure you read somewhere that it's best practice, but it's just clutter. I <em>do</em> like that I know exactly what that variable is though. It's a little long, but its meaning is clear.

I'll reiterate what @Malachi said about the <code>Do While Not</code> loops. <code>Do Until</code> is easier to understand.

On the other hand, this <code>If Right(strCOMMENT2, 1) &lt;&gt; "~" Then</code> is probably more understandable as

SUBMITTED

connection params

PRE

MID

$params

POST

SUBMITTED

class Job

PRE

MID

Job

POST

SUBMITTED

copir) &lt; 2: 
                res = item
        else:
                res = ''
                for pre,var in map(None,copir[::2],copir

PRE

Now onto some improvements:

In your <code>nameresolv</code> function, you have a for loop where you use <code>map</code> with a <code>None</code> function. What this does according to the docs is:

If function is None, the identity function is assumed;

So your code works. However, in Python 3.X this actually errors. Essentially what you want to do is get pairs of consecutive elements in an iterable. To do this, we can use the <code>zip</code> function:

MID

for pre, var in zip(copir[::2], copir[1::2]):


POST

Because we now use the <code>zip</code> function, we can remove the <code>None</code> check and simply append <code>pre</code> each time. This is because <code>pre</code> will either be a necessary string or it will be <code>''</code>. Either way it is fine to append to <code>res</code>.

Inside the for loop described above, you can combine multiple of your if statements:

SUBMITTED

private T value;

    private BiConsumer&lt;T, T&gt; beforeSet = (u, v

PRE

MID

BiFunction&lt;T, T, T&gt;

BinaryOperator&lt;T&gt;

POST

It could potentially be useful to use the <code>afterSet</code> as a <code>BiConsumer</code>, to also let it know about what the previous value was.

What if a previous function has been set for <code>afterSet</code>/<code>beforeSet</code>/etc.? I think you should do a null-check there and either throw an exception if it has already been set, or auto-add it (using the default methods that exists on the interfaces), such as <code>this.afterSet = this.afterSet.andThen(afterSet);</code>

I'm not a big fan of the <code>onGet</code> feature. In my experience, getters should do what they do best: Get the <em>actual</em> value. Having the possibility to modify the value that should be returned seems risky. Doing conversion like <code>String.toLowerCase()</code> for example should lie where it is being used, or the property should be set to lower case right from the start IMO.

Actually, thinking about it... I'm not sure about any of the get-features... I just don't see a specific real use case for them.

I'm going to list a couple of good things and a couple of bad things with this approach:

Good things:

(One time for the <code>beforeSet</code> feature, once for the <code>onSet</code> and once for <code>afterSet</code>. Three-in-one)

Bad things:

Primitive types needs to be wrapped into it's non-primitive type, like <code>int</code> -> <code>Integer</code>. This leads to slower code as there will be some auto-boxing, and it will allow the value <code>null</code> where you might not want that value, or you have to handle the <code>null</code> with a <code>beforeSet</code> or similar. Although you could potentially separate classes for  <code>IntProperty</code>, <code>BooleanProperty</code>, etc. I don't think you'd want to do all those classes.

When should I make my Java classes use this approach or not? Should I introduce them when I feel like I need them or should I play safe and use this approach on all my properties, even though when I will probably never need them? I can imagine there will be some headache going on no matter what option I would choose.

It's breaking the Java beans style, which isn't a bad thing by itself. It can cause a bit of a problem when using libraries that depends a lot on reflection, but there are normally ways to work around that. (I.e. telling the library to ignore the <code>private</code> property and use the getters and setters provided).

Consider Google's <a href="http://code.google.com/p/guava-libraries/wiki/EventBusExplained" rel="nofollow">EventBus</a> code. With the right event classes, this can accomplish the same things. Example code following: (not tested, but something similar would work)

SUBMITTED

_breaker.Execute

PRE

MID

Execute

POST

SUBMITTED

SELECT vote_candidate candidate, original_votes votes, surplus_redistribution redistribution, (original_votes + surplus_redistribution) votes_after_redistribution
FROM (
    SELECT c.vote_candidate, (
        SELECT (
            (MAX(votes_above_the_threshold) - (
                SELECT FLOOR((COUNT(*) / (2 + 1)) + 1) threshold
                FROM votes
            )) / MAX(votes_above_the_threshold)
        ) ratio
        FROM (
            SELECT vote_candidate vote_candidate, COUNT(*) votes_above_the_threshold
            FROM vote_orders
            WHERE vote_order = 1
            GROUP BY vote_candidate
            HAVING votes_above_the_threshold &gt;= (
                SELECT FLOOR((COUNT(*) / (2 + 1)) + 1) threshold
                FROM votes
            )
        ) t
        WHERE votes_above_the_threshold = (
            SELECT MAX(votes_above_the_threshold)
            FROM vote_orders
        )
    ) surplus_ratio, c.original_votes, LEAST(0,t.threshold - c.original_votes) surplus_redistribution
    FROM (
        SELECT o.vote_candidate, COUNT(*) original_votes
        FROM vote_orders o
        WHERE o.vote_order = 1
        GROUP BY o.vote_candidate
    ) c
    CROSS JOIN (
        SELECT FLOOR((COUNT(*) / (2 + 1)) + 1) AS threshold
        FROM votes
    ) t

PRE

Convoluted reasoning that looks almost circular.  For example, in the first two dozen lines…

MID

SELECT c.vote_candidate, (
    SELECT (
        (MAX(votes_above_the_threshold) - (
            SELECT FLOOR((COUNT(*) / (2 + 1)) + 1) threshold
            FROM votes
        )) / MAX(votes_above_the_threshold)
    ) ratio
    FROM (
        SELECT vote_candidate vote_candidate, COUNT(*) votes_above_the_threshold
        FROM vote_orders
        WHERE vote_order = 1
        GROUP BY vote_candidate
        HAVING votes_above_the_threshold &gt;= (
            SELECT FLOOR((COUNT(*) / (2 + 1)) + 1) threshold
            FROM votes
        )
    ) t
    WHERE votes_above_the_threshold = (
        SELECT MAX(votes_above_the_threshold)
        FROM vote_orders
    )
) surplus_ratio,


POST

<code>votes_above_the_threshold</code> is defined as a column of <code>t</code>. <code>t</code> is filtered through a <code>HAVING</code> clause.  It is further filtered by <code>WHERE votes_about_the_threshold = (SELECT MAX(votes_above_the_threshold) FROM vote_orders)</code>, but <strong>there is no <code>votes_above_the_threshold</code> column in <code>vote_orders</code></strong>!  I'd also try removing the <code>HAVING</code> condition in <code>t</code> favour of the <code>WHERE</code> condition of the <code>surplus_ratio</code> subquery.

SUBMITTED

bw

PRE

MID

bw

POST

SUBMITTED

Namespace
        (function (HOTEL) {
            // Reuseable controller
            var controllerPrototype = {
                greet: function () {
                    this.model.view.innerHTML = '"' + this.model.greeting + '"';
                },
                acceptTip: function

PRE

in my mind should be wired by the controller,  that is, the linking of UI elements to data and UI changes

This:

MID

greet: function () {
    this.model.view.innerHTML = '"' + this.model.greeting + '"';
},


POST

has your controller access data straight in your view, updating the DOM. This is wrong in my mind. The view should have functions that the controller can call with either the model as a parameter or already passed in advance.

<code>Object.create(controllerPrototype);</code> &lt;- Any reason you are eschewing <code>new</code> and <code>prototype</code> ? 

Not that it truly matters but, <code>method === "model"</code> will not catch <code>new String('model')</code>

<code>args = [].slice.call(arguments, 1);</code> works as well as the ternary

All in all, I think this could use some more polishing.

SUBMITTED

function userIsLoggedIn()
{
if ($_SERVER["REQUEST_METHOD"] == "POST") {
  if (isset($_POST['action']) and $_POST['action'] == 'login') {
  if (!isset($_POST['user']) or $_POST['user'] == '' or !isset($_POST['password']) or $_POST['password

PRE

It's reduces unnecessary nesting. Apply the same for <code>if ($_SERVER[&quot;REQUEST_METHOD&quot;] == &quot;POST&quot;)</code>.

MID

if (!isset($_POST['user']) or $_POST['user'] == '' or !isset($_POST['password']) or $_POST['password'] == '')


could be simplified to

if (!isset($_POST['user'], $_POST['password']) or empty($_POST['user']) or empty($_POST['password']))


It's just easier to read.

In your minimum time check between form submissions, you've added an <code>else</code>, but because the initial condition would return false, an else is completely unnecessary. It also nests your code one more layer, which isn't too great if it can be avoided.

$user = test_input($_POST['user']);


POST

The variable here is very ambiguous. I suggest calling something more appropriate such as <code>$username</code> or something that describes what the value is.

SUBMITTED

mysqli;

class Users {
    protected $db;
    public function __construct() {
        $this-&gt

PRE

Why are you starting a new database connection for each class? Pass in a database connection object to the constructor:

MID

public function __construct(mysqli $dbConnection) {


POST

This allows your class to work without worrying about actually doing the connection. The class's job is to handle users, not handle database connections!

You not only said <code>LIMIT 1</code> in your query, but you also check that <code>$query-&gt;num_rows</code> is 1, and then you even loop over the results (even though there's only one). This sort of triple check is redundant and unreadable. You <em>know</em> there's either 1 or 0 results because you <code>LIMIT</code>ed the query!

Your hashing algorithm is not secure. Use PHP 5.5's <strong><a href="http://www.php.net//manual/en/function.password-hash.php" rel="nofollow"><code>password_hash()</code></a></strong>, or if you don't use 5.5 (And you should!!!) use <strong><a href="https://github.com/ircmaxell/password_compat" rel="nofollow">Password Compat</a></strong>, a library written by the same guy who wrote the <code>password_hash()</code> function for PHP's core.

<strong>Do not limit your users' password length</strong> - Setting a minimum length is good. Setting a maximum length is a kitten killing crime. Don't.

Your <code>login()</code> method returns <code>false</code> on error, but nothing on success. Either <code>return true</code> on success, or simply <a href="http://il1.php.net/manual/en/language.exceptions.php" rel="nofollow">throw an exception</a> on errors.

Your <code>UserData</code> class is not a class, it's a namespace. You only use it for static functions (even though you don't declare them as <code>static</code> in your class!).

What does your <code>getAndSet</code> method does? It's not clear. Use a proper name or add documentation.

Your <code>UserUtil</code> class does absolutely nothing.

Generally, I'd say you can improve the structure of your code by having the following 3 classes:

SUBMITTED

val -is [__ComObject]) {
        try {
            $valstr = [string]::Format(@'
Control = {0} = 0x{0:X8

PRE

Your code looks pretty good to me.

You can replace this:

MID

[string]::Format('{0} = 0x{0:X8}', $val)


with this:

'{0} = 0x{0:X8}' -f $val


POST

Empty "catch all" catch blocks are not a good idea:

SUBMITTED

models.py #####

#coding=utf-8

from django.db import models
from .utils import LEVELS, GENDER,SCHOOL_YEAR
from django_countries.fields import CountryField
from django.utils import timezone
from django.forms import Form, ModelForm
from datetime import datetime
import string
import random

class Applicant(models.Model):
    first_name=models.CharField('Nombres',max_length=30)
    last_name=models.CharField('Apellidos',max_length=30)
    gender=models.CharField('Género',max_length=2,choices=GENDER)
    grade_applied_for=models.CharField('Grado al que aplica',max_length=6,choices=LEVELS)
    birth_date=models.DateField('Fecha de nacimiento')
    birth_place=CountryField('País de nacimiento')
    residence_place=CountryField('País de residencia')
    address=models.CharField('Dirección',max_length=80)
    rep_name=models.CharField('Nombres del representante',max_length=40)
    rep_email=models.EmailField('Correo electrónico del representante')
    rep_landline=models.CharField('Número de teléfono convencional',max_length=20)
    rep_mobile=models.CharField('Número de teléfono móvil',max_length=10)
    prev_school_name=models.CharField('Insitución Educativa previa',max_length=20,blank=True)
    prev_school_place=models.CharField('Lugar de la insitución',max_length=20,blank=True)
    last_approved_year=models.CharField('Ultimo año lectivo aprobado',max_length=4,choices=SCHOOL_YEAR,blank=True)
    invoice_name=models.CharField('Razón Social',max_length=20)
    invoice_id_number=models.CharField('Nómero de cédula o RUC',max_length=10)
    invoice_address=models.CharField('Dirección',max_length=40)
    invoice_phone=models.CharField('Teléfono',max_length=15)
    pub_date = models.DateTimeField('Fecha de aplicacion',default=datetime.now,unique=True)

    confirmation_code = models.CharField('código de confirmación',max_length=6)
    confirmation_status=models.BooleanField(default=False)

    def __unicode__(self):
        return self.first_name+" "+self.last_name


#### views.py #####

from django.shortcuts import render, get_object_or_404, render_to_response
from applications.models import Applicant
from applications.forms import ApplicantForm, ConfirmationCode
from django.http import HttpResponse
from django.template import RequestContext, loader
from django.core.mail import send_mail
import string
import random

def random_confirmation(size=6,chars=string.digits):
    return ''.join(random.choice(chars) for _ in range(size))


def index(request):

    latest_application = Applicant.objects.all().order_by('-pub_date')
    context = {'latest_application':latest_application}
    return render(request,'applications/index.html',context)

def add_applicant(request):
    context = RequestContext(request)
    if request.method == 'POST':
        if 'last_name' in request.POST:
            form = ApplicantForm(request.POST)
            if form.is_valid():
                applicant = form.save(commit=False)
                applicant.confirmation_code = random_confirmation()
                applicant.save()
                send_mail('Confirmacion de aplicacion','Su codigo de confirmacion es %s' %applicant.confirmation_code,'xxxx@xxxx.org',[applicant.rep_email],fail_silently = True)
                form2 = ConfirmationCode(initial={'confirmation_id':applicant.pk})
                return render_to_response('applications/confirmation.html',{'applicant':applicant,'pub_date':applicant.pub_date,'confirmation_code

PRE

One thing that concerns me about this approach is that <code>Applicant</code> is huge. I'd consider splitting this into a few different models. At the very least I'd imagine that I'd want to split out the details for a person and contact information:

MID

class Person(models.Model):
    """Information for a person"""
    first_name=models.CharField('Nombres',max_length=30)
    last_name=models.CharField('Apellidos',max_length=30)
    gender=models.CharField('Género',max_length=2,choices=GENDER)
    birth_date=models.DateField('Fecha de nacimiento')
    birth_place=CountryField('País de nacimiento')
    residence_place=CountryField('País de residencia')

class ContactInfo(models.Model):
    """Contact information for a Person"""
    address=models.CharField('Dirección', max_length=80)
    rep_name=models.CharField('Nombres del representante', max_length=40)
    rep_email=models.EmailField('Correo electrónico del representante')
    rep_landline=models.CharField('Número de teléfono convencional', max_length=20)
    rep_mobile=models.CharField('Número de teléfono móvil', max_length=10)

class Applicant(models.Model):
    """Information about an application"""
    person = models.ForeignKey(Person)
    contact_info = models.ForeignKey(ContactInfo)
    prev_school_name=models.CharField('Insitución Educativa previa', max_length=20, blank=True)
    prev_school_place=models.CharField('Lugar de la insitución', max_length=20, blank=True)
    last_approved_year=models.CharField('Ultimo año lectivo aprobado', max_length=4, choices=SCHOOL_YEAR, blank=True)
    invoice_name=models.CharField('Razón Social', max_length=20)
    invoice_id_number=models.CharField('Nómero de cédula o RUC',max_length=10)
    invoice_address=models.CharField('Dirección', max_length=40)
    invoice_phone=models.CharField('Teléfono', max_length=15)
    pub_date = models.DateTimeField('Fecha de aplicacion', default=datetime.now, unique=True)


POST

I also added some <a href="http://en.wikipedia.org/wiki/Docstring">docstrings</a> here as I think that's generally speaking a very good idea as it can let people get familiar with the structure of your code faster and can allow you to use documentation generation tools.

Another thing you can do to reduce code duplication is to instantiate forms like this:

SUBMITTED

securityA, $sum

PRE

MID

$sum

POST

SUBMITTED

socket
      except (ValueError, KeyError, TypeError):
        logging.debug("JSON

PRE

Now, onto some style comments. 

I enjoy reading and understanding 'low-level' (sockets, OS stuff, etc.) code like this. However, for some reason, most of the code that I read that is this low-level, has one glaring problem: the writers truncate EVERYTHING: a simple socket becomes <code>sock</code>, an address becomes <code>addr</code>, etc.

Many of these names have become conventionalized through constant and consistent use. However, this goes against the general Python convention that its better to be too verbose instead of too terse. Instead of <code>sock</code> take the time to type the two extra characters to make <code>socket</code>.

Also, make sure your variable/function names describe what they hold/do. The name <code>p</code> tells us nothing about what it holds and your function name <code>trnm_thr</code> is so condensed I have no clue what it is supposed to do. Don't sacrifice clarity and readability for conciseness.

<a href="http://legacy.python.org/dev/peps/pep-0008/#other-recommendations" rel="nofollow noreferrer">Don't use inline statements after if statements</a>. This breaks the flow of the program and can throw readers off. <a href="http://legacy.python.org/dev/peps/pep-0008/#inline-comments" rel="nofollow noreferrer">The same goes for inline comments</a>.

Technically your indentation level is fine. However, Pythonic convention is to use 4 spaces.

Be as specific with your <code>except</code> blocks as possible. Unfortunately, I don't know enough about what errors <code>json.loads</code> throws, so I cannot suggest anything better for:

MID

except (ValueError, KeyError, TypeError):


POST

than the general case mentioned above.

Here is a PEP8 compliant version of your code (with my other recommendations):

SUBMITTED

_xhr = new XMLHttpRequest();
                _xhr

PRE

MID

new XMLHttpRequest();

POST

SUBMITTED

cards.index

PRE

MID

index

POST

SUBMITTED

BlasenSuche(ref

PRE

MID

ref

POST

You don't need to use the <code>ref</code> keyword anywhere. Please see <a href="http://msdn.microsoft.com/en-us/library/8f1hz171.aspx" rel="nofollow noreferrer">Method Parameters</a> and <a href="http://msdn.microsoft.com/en-us/library/3ewxz6et.aspx" rel="nofollow noreferrer">Types</a> on MSDN.

Please try to follow C# <a href="http://msdn.microsoft.com/en-us/library/ms229045(v=vs.110).aspx" rel="nofollow noreferrer">naming</a> and <a href="http://msdn.microsoft.com/en-us/library/ms229043(v=vs.110).aspx" rel="nofollow noreferrer">capitalization</a> conventions.

Use the version of <code>Convert.ToDouble</code> that takes an <code>IFormatProvider</code>. The sample file you gave has numbers in the form <code>0,0421216848673947</code>, which will be converted differently depending on the current thread's culture. On my machine, that string is converted to 421216848673947.

You will want something like this:

SUBMITTED

contacts
    for (int index = 0; index &lt; self.addressBook.allContacts.count; index++) {

       // Create contactRef from current contact
        self.currentContact.contactRef = (__bridge ABRecordRef)(self.addressBook.allContacts[index]);

      // Loop through all of the current contact's phone numbers
        int index2;
        for (index2 = 0; index2 &lt; self.currentContact.phoneNumbers.count; index2++) {
            if (self.currentContact.firstName) {
                // Add current contact's phone number to array
                [self.potentiaFriendsPhoneNumberArray addObject:self.currentContact.phoneNumbers[index2]];

                // Add current contact's first name to array
                [self.potentiaFriendsNotInParseFirstNamesArray addObject:self.currentContact.firstName

PRE

But... with that said, I did take a look at the <code>requestAccess</code> method in the link.  Strictly speaking, it's not in the question and so it's not strictly up for review, but, I'm quite certain it will always return <code>NO</code>, as the return is synchronous but the variable being returned is only set in an asynchronous block, and as such, will always be set too late.

MID

int index2;
for (index2 = 0; index2 &lt; self.currentContact.phoneNumbers.count; index2++) {
    if (self.currentContact.firstName) {
        // Add current contact's phone number to array
        [self.potentiaFriendsPhoneNumberArray addObject:self.currentContact.phoneNumbers[index2]];

        // Add current contact's first name to array
        [self.potentiaFriendsNotInParseFirstNamesArray addObject:self.currentContact.firstName];
    }
}


First, we can declare our iterator variable in the for loop initialization statement.  Remember, you did this a few lines up.  But perhaps more importantly, why don't we use a <code>forin</code>?

for (id phoneNumber in self.currentContact.phoneNumbers) {
    [self.potentialFriendsPhoneNumberArray addObject:phoneNumber];
    [self.potentialFriendsNotInParseFirstNamesArray addObject:self.currentContact.firstName];
}


POST

We should also move the <code>if</code> check outside the loop so that the entire loop can be circumvented in the case that we're never going to add anything anyway.  Embed the loop within the <code>if</code>.

Also, it doesn't make a ton of sense to me for there to be two separate arrays. I understand that you'll want a name associated with all the phone numbers, however it's better to do this with a single array, either by filling it with dictionaries with a key for the phone number and a key for the name, or by creating a custom object that will hold both of these parts. 

SUBMITTED

url[1];

    foreach

PRE

MID

foreach

POST

SUBMITTED

attack = 5 + self.level
        self.defense = 5 + self.level
        self.name = ''
        self.xp = 0

    def name_self(self):
        self.name = raw_input("What do you call yourself, anyway? ")
        if self.name == "":
            self.name_self()

    def heal_self(self):
        amount = self.xp * .2
        self.hp

PRE

Use looping rather than recursion for input validation (see e.g. <a href="https://stackoverflow.com/a/23294659/3001761">this SO community wiki</a>):

MID

def name_self(self):
    while True:
        self.name = raw_input("What do you call yourself, anyway? ")
        if self.name != "":
            break


POST

Consider structuring your functions differently, such that they call each other, to cut down multiple lines of calls at the top level. For example: <code>Game.__init__</code> could call <code>populate</code> and <code>look</code>; <code>Hero.__init__</code> could call <code>name_self</code> and <code>look_self()</code>; and you could add <code>Game.play_round</code> to call <code>handle_input()</code>, <code>game.update()</code> and <code>game.output()</code>.

Put the top-level code in an <code>if __name__ == '__main__':</code> block (see e.g. <a href="https://stackoverflow.com/q/419163/3001761">this SO question</a>).

SUBMITTED

init];
    HALUserDefaults

PRE

MID

HALUserDefaults

POST

First of all, the calls to <code>synchronize</code> can probably be eliminated.  It's quite rare that you actually have to make this call in order for the data to properly persist, and making the call every time you store something in defaults completely eliminates any advantage you'd gain by using NSUserDefaults.

NSUserDefaults persists the stored data in memory until the device can find an efficient time to write the data to permanent memory on a background thread.  Calling <code>synchronize</code> forces the app to write to permanent storage right then and there.

But there's a bigger problem with <code>HALUserDefaults</code>.  The 4 methods that exist within the class are written as instance methods, but they're stateless methods.  Their function doesn't depend on any thing about the state of the instance of the <code>HALUserDefaults</code>.  And even if it did, there's no state to set.

Furthermore, the only reason to instantiate a <code>HALUserDefaults</code> object is to call these methods.

There are two solutions here.  We can swap these over to class methods (change the <code>-</code> to a <code>+</code>) so we still maintain the &quot;namespace&quot; of <code>HALUserDefaults</code>, or we can change them to C-Style functions.

This is something first noticed in <code>HALUserDefaults</code> but applies to all instances where you're using a literal string as a key or notification name (or a lot of other things).  If there's even a small possibility that you'll use a string literal more than once, it should be declared as a <code>NSString * const</code> and used that way.  This is especially true for literal strings used across multiple files (such as the notification names).

SUBMITTED

zeroCreate tImageByteLength

            do Marshal.Copy(tImageRGBValues, 0, tIntPtr, tImageByteLength)

            do pBitmap.UnlockBits(tBitmapData)

            tImageRGBValues, pBitmap.Width, pBitmap.Height

PRE

MID

do Marshal.Copy(tImageRGBValues, 0, tIntPtr, tImageByteLength)

do pBitmap.UnlockBits(tBitmapData)


POST

You don't need to write <code>do</code> here. (Actually, <a href="https://stackoverflow.com/q/24779957/41071">I was surprised you <em>can</em> write <code>do</code> here</a>.)

SUBMITTED

function add_tax($data){
            $result = [];
            foreach($data as $product =&gt; $details) {
                $details['tax'] = 0;
                $result[$product] = $details;
                } 
            return $result

PRE

You could try something along these lines:

MID

function add_tax($data){
        foreach($data as $product =&gt; $details) {
            $data[$product]['tax'] = 0;
        }
        return $data;
}


EDIT 1:

After a bit more researching on <a href="http://php.net/manual/en/control-structures.foreach.php" rel="nofollow" title="Foreach">foreach</a> I have come up with the following alternative:

function add_tax(&amp;$data) {
    foreach($data as &amp;$details)
        $details['tax'] = 0;
}


POST

In reference to Alex L: I apologize, the original answer was rushed. The first snippet was simply a way of answering the question, that yes, it is possible to iterate through <code>$data</code> without generating a new variable. Also, to MikeiLL, yes, that would be a waste of memory. This second snippet passes both variables by reference, which does not require any excess usage of memory. It is the most optimal format of this process.

<strike>NOTE: The unset in the function is not exactly necessary, but as your question referenced memory usage, unset breaks the reference and releases that memory.</strike>

EDIT 2:

Due to very strong backing in the comments, I've removed the call to unset (truth be told I'd never use it myself, but wanted to reference it's usage within the function)

SUBMITTED

View

PRE

There are at least two places in your code where it looks like you wanted to use an object's attributes, but you say <code>$attribute</code> rather than <code>$this-&gt;attribute</code>.  PHP requires <code>$this-&gt;</code> before property accesses.  If it's not there, PHP assumes there's a local variable.  Setting stuff that way will have no effect, and trying to read it will trigger a notice about undefined variables.  In fact, i'd be rather surprised if the code works at all.

But with the brokenness set aside, it looks like your three classes are quite confused about their jobs.  Let's review what each part of an MVC triad is supposed to do:

Now, let's take a look at your classes.

MID

View

POST

SUBMITTED

getSupportFragmentManager().beginTransaction().add(R.id.main_container, new FirstFragment()).addToBackStack(null).commit();
        }
    }

    @Override
    public void firstFragmentCallback()
    {
        getSupportFragmentManager().beginTransaction().replace(R.id.main_container, new SecondFragment()).addToBackStack(null).commit

PRE

It's excellent that you're logging this and re-throwing the exception, I would however log the canonical name (<code>some.package.SomeActivity</code>) and not just the simple name (<code>SomeActivity</code>).

An alternative here though would be to provide a <code>setCallback</code> method. I am not sure what the best practice is actually with regards to this, but well... it's an alternative. It would add some flexibility as the activity itself doesn't have to be the one implementing the callback.

MID

FirstFragment fragment = new FirstFragment();
fragment.setCallback(new FirstFragment.Callback(){ ... });
getSupportFragmentManager().beginTransaction().add(R.id.main_container, fragment).addToBackStack(null).commit();


POST

SUBMITTED

ReadOptions.ReadUntilCellError

PRE

MID

ReadUntilCellError

POST

You could go one step further and only check the flag just before, or with, the null value check.

SUBMITTED

private IEnumerable&lt;MyObject&gt; GetOnDemandInputsBy(int key)
        {
            var inputs = new List&lt;MyObject&gt;();
            //This is actually called 13 times with different parameter variables (the parameter called parameter) and a different static dictionary 
            inputs.Add(AssembleMyObject(key, "@BeginTime", MyObjectPropertyConstants.BeginTime()));
            inputs.Add(AssembleMyObject(key, "@EndTime", MyObjectPropertyConstants

PRE

MID

var inputs = new List&lt;MyObject&gt;();
inputs.Add(AssembleMyObject(key, "@BeginTime", MyObjectPropertyConstants.BeginTime()));
inputs.Add(AssembleMyObject(key, "@EndTime", MyObjectPropertyConstants.EndTime()));

return inputs;


You could rewrite this to make it more DRY using LINQ into:

return new Func&lt;Dictionary&lt;string, string&gt;&gt;[]
{
    MyObjectPropertyConstants.BeginTime,
    MyObjectPropertyConstants.EndTime
}.Select(f =&gt; AssembleMyObject(key, "@" + f.Name, f()).ToList();


POST

SUBMITTED

readLine(Fd, &amp;Buffer

PRE

That picture tells me everything I need to know about what you are trying to accomplish — you need hardly explain further.  Conversely, <em>not</em> having that picture makes me work a lot harder to reverse-engineer your code.

MID

&amp;Buffer[0]

Buffer

You repeat the <code>readLine()</code> call — once before entering the loop, once at the end of the loop.  This is a good opportunity to make use of C's support for side-effects.

while (0 == (Ret = readLine(Fd, Buffer))) {
    …
}


POST

Since <code>ARP_CACHE</code> is a compile-time constant string, you can just write

SUBMITTED

isPaused  = false;
        $this-&gt;lapCount  = 0;
    }

    public function start() {
        $this-&gt;setRunningPaused( true, false );
        $this-&gt;startTime

PRE

And then instead of

MID

public function start() {
    $this-&gt;setRunningPaused( true, false );
}


we use constants to set the state:

public function start() {
    $this-&gt;state = Timer::RUNNING;
}


Reads better, and you don't have the worry about the edge case where somehow the timer is running and paused at the same time <code>setRunningPaused(true, true);</code>

when I call $t->end(); it returns the summary. why? this seems undesirable. I want to end the timer, not get the summary. I didn't know it was returning the summary after I looked into the code. Simply remove the return there.

for instance your lap method. You are creating a $lapTime variable, but you aren't really using it. Only to pass it to the array. This will do the job aswell:

$this-&gt;laps[] = array(
    "start" =&gt; $this-&gt;getCurrentTime()
);


In the endlap, you calculate the current position of the array pointer. There is afunction for that: <a href="http://php.net/manual/en/function.key.php" rel="nofollow">key</a>
So:

$lapCount = key($this-&gt;laps);


POST

another option here would be to use a pointer reference instead of accessing the laps array multiple time. But this should only be done if it reads easier:

SUBMITTED

Node ptrNext

PRE

Nice code. I'm assuming that you read Vogel612 comment and it is doing what you want it to do. 

MID

ptrNext

POST

SUBMITTED

import java.util.*;
import java.util.logging.*;
import javax.mail.*;

public class EmailSession {

    private Session session;
    private Store store;
    private Folder inbox;
    private int messageCount;
    private int unreadMessageCount;
    private List&lt;Message&gt; unreadMessages;

    public EmailSession() {
        Properties props = new Properties();
        props.setProperty("mail.store.protocol", MyProps.getProperty("mail.store.protocol"));
        try {
            session = Session.getInstance(props, null);
            store = session.getStore();
            store.connect(MyProps.getProperty("mail.host"), MyProps.getProperty("mail.user"), MyProps.getProperty("mail.password"));
            inbox = store.getFolder(MyProps.getProperty("mail.foldername"));
            inbox.open(Folder.READ_ONLY);
            messageCount = inbox.getMessageCount();
            List&lt;Message&gt; messages;
            if (messageCount &gt; 100) {
                Logger.getLogger(EmailSession.class.getName()).log(Level.WARNING, 
                        "More than 100 messages");
                messages = Arrays.asList(inbox.getMessages(1, 100));
            } else {
                messages = Arrays.asList(inbox.getMessages());
            }
            unreadMessages = new ArrayList&lt;&gt;();
            unreadMessageCount = 0;
            for (Message message : messages) {
                boolean isUnreadMessage = true;
                for (Flags.Flag flag : message.getFlags().getSystemFlags()) {
                    if (flag == Flags.Flag.SEEN) {
                        isUnreadMessage = false;
                        break;
                    }
                }
                if (isUnreadMessage) {
                    unreadMessages.add(message);
                    unreadMessageCount++;
                }
            }
            inbox.close(true);
        } catch (NoSuchProviderException ex) {
            Logger.getLogger(EmailSession.class.getName()).log(Level.SEVERE, null, ex);
        } catch (MessagingException ex) {
            Logger.getLogger

PRE

With these helper methods and the other suggestions above, you could simplify the constructor:

MID

public EmailSession() {
    Properties props = new Properties();
    props.setProperty("mail.store.protocol", MyProps.getProperty("mail.store.protocol"));
    Session session = Session.getInstance(props, null);
    try {
        store = session.getStore();
        store.connect(MyProps.getProperty("mail.host"), MyProps.getProperty("mail.user"), MyProps.getProperty("mail.password"));
        inbox = store.getFolder(MyProps.getProperty("mail.foldername"));
        inbox.open(Folder.READ_ONLY);
        messageCount = inbox.getMessageCount();
        List&lt;Message&gt; messages = getMessages(inbox, messageCount);
        inbox.close(true);
        unreadMessages = getUnreadMessages(messages);
    } catch (NoSuchProviderException ex) {
        LOGGER.log(Level.SEVERE, null, ex);
    } catch (MessagingException ex) {
        LOGGER.log(Level.SEVERE, null, ex);
    }
}


POST

I also moved <code>inbox.close</code> higher to close it immediately when you don't need it anymore.

Wildcard imports like <code>import java.util.*</code> are <a href="https://stackoverflow.com/questions/147454/why-is-using-a-wild-card-with-a-java-import-statement-bad">considered bad practice</a>. Try to avoid it, it's better to clean up all of these:

SUBMITTED

function (global) {
    'use strict';

    var scalePrefix = ['m', 'b', 'tr', 'quadr', 'quint', 
            'sext', 'sept', 'oct', 'non', 'dec'];

    var digits = ['', 'one', 'two', 'three', 'four',
            'five', 'six', 'seven', 'eight', 'nine'];

    var tens = ['', 'ten', 'twenty', 'thirty', 'forty', 'fifty',
            'sixty', 'seventy', 'eighty', 'ninety'];

    var teens = { 0: 'ten', 1: 'eleven', 2: 'twelve', 
            3: 'thir', 5: 'fif', 8: 'eigh' };

    function nameDigit(digit) {
        return digits[digit];
    }

    function nameTenToNineteen(number) {
        var prefix = teens[number] || digits[number];

        return number &lt; 3 ? prefix : prefix + 'teen';
    }

    function nameTripletScale(digitCount) {
        return  digitCount &lt; 3 ? '' :
                digitCount &lt; 6 ? 'thousand' :
                scalePrefix[digitCount / 3 - 2] + 'illion';
    }

    function nameTripletHead(number) {
        return +number ? (nameDigit(number) + ' hundred') : '';
    }

    function nameTripletTail(digitPair

PRE

Other than that I think you went a little overboard in some places to achieve the ultimate DRYness.

This:

MID

var digits = ['', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine'];
var tens = ['', 'ten', 'twenty', 'thirty', 'forty', 'fifty', 'sixty', 'seventy', 'eighty', 'ninety'];
var teens = { 0: 'ten', 1: 'eleven', 2: 'twelve', 3: 'thirteen', 5: 'fifteen', 8: 'eighteen' };

function nameDigit(digit) {
    return digits[digit];
}

function nameTenToNineteen(number) {
    return teens[number] || digits[number] + 'teen';
}


POST

(ignore the removed newlines) puts the <code>'teen'</code> back in the <code>teens</code> array, you no longer need a temporary variable or encode that you do not have the add <code>'teen'</code> for 10,11 and 12. This has less characters, and less complexity.

The same ( though I am not sure this would reduce character count here ) can be said for <code>scalePrefix</code>, it took me a while to figure that this was supposed to return <code>m</code>illlion, <code>b</code>illion etc. If you were to add <code>''</code>, <code>'thousand'</code> and <code>'illion'</code> at the end of existing entries, then your <code>nameTripletScale</code> could be

SUBMITTED

raise IndexError

PRE

MID

IndexError

POST

SUBMITTED

public static boolean validate(byte[] bytes) {

    int length = bytes.length;

    if (length &lt; 1 || length &gt; 6)
        return false;

    byte b = bytes[0];

    if (length == 1)
        return (b &amp; (1 &lt;&lt; 7)) == 0;

    int n;

    if ((b &amp; 0xFF) &gt;&gt; 1 == (byte) 0b1111110)
        n = 5;
    else if ((b &amp; 0xFF) &gt;&gt; 2 == (byte) 0b111110)
        n = 4;
    else if ((b &amp; 0xFF) &gt;&gt; 3 == (byte) 0b11110)
        n = 3;
    else if ((b &amp; 0xFF) &gt;&gt; 4 == (byte) 0b1110)
        n = 2;
    else if ((b &amp; 0xFF) &gt;&gt; 5 == (byte) 0b110)
        n = 1;
    else
        return false;

    if (length-1 != n)
        return false;

    for (int i = 1; i &lt; length; i++)
        if ((bytes[i] &amp; 0xFF) &gt;&gt; 6 != (byte) 0b10)
            return false;

    return true

PRE

Never omit the optional braces like that.  Think of yourself as a contributing factor to a future <a href="https://www.imperialviolet.org/2014/02/22/applebug.html" rel="noreferrer">coding accident</a>.  If you really want to omit braces, then put the statement on the same line, so that there is no possibility of misinterpretation.

The function does not check for <a href="http://en.wikipedia.org/wiki/UTF-8#Overlong_encodings" rel="noreferrer">overlong encodings</a>, <a href="http://en.wikipedia.org/wiki/UTF-8#Invalid_byte_sequences" rel="noreferrer">invalid byte sequences</a>, or <a href="http://en.wikipedia.org/wiki/UTF-8#Invalid_code_points" rel="noreferrer">invalid code points</a>.  Those caveats should be declared in JavaDoc.

I would eliminate the <code>length &gt; 6</code> check, as 6 is a magic number.  You don't need that special case anyway.

I would also incorporate the <code>length == 1</code> special case into the regular logic.

In general, text is more likely to contain shorter UTF-8 sequences than longer ones, so you might as well handle the shorter cases first to save a few CPU cycles.

Rather than setting <code>n</code> to be the number of trailing bytes, set it to be the expected length of the array.  I'd rename <code>n</code> → <code>expectedLen</code> to be more descriptive.  That makes the code more readable (and saves one pointless subtraction).

Eliminate the bit-shifting.  Just AND with the bitmask to specify which bits you are interested in inspecting.

MID

public static boolean validate(byte[] bytes) {
    int expectedLen;
    if      (bytes.length == 0)                     return false;
    else if ((bytes[0] &amp; 0b10000000) == 0b00000000) expectedLen = 1;
    else if ((bytes[0] &amp; 0b11100000) == 0b11000000) expectedLen = 2;
    else if ((bytes[0] &amp; 0b11110000) == 0b11100000) expectedLen = 3;
    else if ((bytes[0] &amp; 0b11111000) == 0b11110000) expectedLen = 4;
    else if ((bytes[0] &amp; 0b11111100) == 0b11111000) expectedLen = 5;
    else if ((bytes[0] &amp; 0b11111110) == 0b11111100) expectedLen = 6;
    else    return false;

    if (expectedLen != bytes.length) return false;

    for (int i = 1; i &lt; bytes.length; i++) {
        if ((bytes[i] &amp; 0b11000000) != 0b10000000) {
            return false;
        }
    }

    return true;
}


It's rarely useful to validate a single character: usually, you'll want to validate a whole string.  You should name your function to avoid giving the impression that it checks for multi-character strings.

In Java, functions that perform a test and return a boolean are conventionally named <code>isSomething()</code> or <code>hasSomething()</code>.  A function named <code>validate()</code> suggests that it performs an action as a side-effect, perhaps throwing an exception on failure.

Therefore, I'd rename your function to <code>isValidChar(byte[] bytes)</code>.

So, what if I need to validate a string?  I'd have to somehow chunk it up into right-sized byte arrays first.  That's not really possible without examining the string using similar logic to what is in the function itself.  Even then, it would be wasteful to construct a byte array just for the function call.  Therefore, I think that it would be more useful to provide a function that validates a string.  To go further, you could make such a function return something more informative than just a boolean.

/**
 * Returns the number of UTF-8 characters, or -1 if the array
 * does not contain a valid UTF-8 string.  Overlong encodings,
 * null characters, invalid Unicode values, and surrogates are
 * accepted.
 */
public static int charLength(byte[] bytes) {
    int charCount = 0, expectedLen;

    for (int i = 0; i &lt; bytes.length; i++) {
        charCount++;
        // Lead byte analysis
        if      ((bytes[i] &amp; 0b10000000) == 0b00000000) continue;
        else if ((bytes[i] &amp; 0b11100000) == 0b11000000) expectedLen = 2;
        else if ((bytes[i] &amp; 0b11110000) == 0b11100000) expectedLen = 3;
        else if ((bytes[i] &amp; 0b11111000) == 0b11110000) expectedLen = 4;
        else if ((bytes[i] &amp; 0b11111100) == 0b11111000) expectedLen = 5;
        else if ((bytes[i] &amp; 0b11111110) == 0b11111100) expectedLen = 6;
        else    return -1;

        // Count trailing bytes
        while (--expectedLen &gt; 0) {
            if (++i &gt;= bytes.length) {
                return -1;
            }
            if ((bytes[i] &amp; 0b11000000) != 0b10000000) {
                return -1;
            }
        }
    }
    return charCount;
}


POST

That's a more versatile function, for about the same amount of code.

SUBMITTED

while (state.World.Looping(reqComponents))
{
    TimerComponent timer = state.World.GetComponent(TimerComponent.Type);

    if (timer.IsActive)
    {
        timer.TimeLeft -= gameTime.ElapsedGameTime.TotalSeconds;

        if (timer.IsFinished)
        {
            timer.IsActive = false

PRE

Basically, this code controls everything except the body of the loop: initialization, increment, and destruction. This suggests that the actual <code>while</code> should be inside <code>State.World.Looping</code>, and it should take another parameter, an <code>Action</code> or equivalent delegate, which the caller should pass in. For instance, the call would be rewritten:

MID

state.World.Looping(reqComponents, () =&gt;
{
    TimerComponent timer = state.World.GetComponent(TimerComponent.Type);

    if (timer.IsActive)
    {
        timer.TimeLeft -= gameTime.ElapsedGameTime.TotalSeconds;

        if (timer.IsFinished)
        {
            timer.IsActive = false;
        }
    }
});


POST

and <code>Looping</code> itself could be modified to:

SUBMITTED

orange", "bg-green"];

$("#try-me").click(function() {
    $("#content")
        .hide()
        .removeClass()
        .addClass(font[Math.floor(Math.random()*font.length)]) // Font
        .addClass(color[Math.floor(Math.random()*color.length)]) // Color
        .fadeIn(600);

    $("html")
        .removeClass()
        .addClass(background[Math.floor(Math.random()*background.length)]); // Background

PRE

The repetition of getting a random font, color, background class cries to be extracted to a utility function:

MID

function pickRandom(arr) { 
    return arr[Math.floor(Math.random() * arr.length)];
}

$("#try-me").click(function() {
    $("#content")
        .hide()
        .removeClass()
        .addClass(pickRandom(font))
        .addClass(pickRandom(color))
        .fadeIn(600);

    $("html")
        .removeClass()
        .addClass(pickRandom(background));
});


I also agree with <a href="https://codereview.stackexchange.com/users/11074/mainma">@MainMa</a> about defining <code>background</code> in terms of <code>color</code>.

Other than that, I think it's nice code!

If you want to make sure that each font/color/background are different every time the user clicks on the button, then perhaps you can create another helper:

function pickRandomExcept(arr, previous) { 
    while (true) {
        var pick = arr[Math.floor(Math.random() * arr.length)];
        if (pick != previous) {
            return pick;
        }
    }
}


However, in the caller you will need to keep track of the previous picks of each. For example:

var picked_color;

$("#try-me").click(function() {
    picked_color = pickRandomExcept(color, picked_color);
    $("#content")
        .hide()
        .removeClass()
        .addClass(pickRandom(font))
        .addClass(picked_color)
        .fadeIn(600);


POST

SUBMITTED

import csv

# Imports a file as a dictionary with csv
def csv_import(filename):
    dictionary = {}
    for key, value in csv.reader(open(filename)):
        dictionary[key] = value
    imported_dictionary = dictionary
    return imported_dictionary

# Saves a dictionary as a file with

PRE

In general, you've done a pretty good job breaking down the problem into functions.

You've written a comment describing every function.  That's good, but you <strong>might as well write the comments as docstrings instead.</strong>

You have a probable file descriptor leak in <code>csv_import()</code> and <code>csv_export()</code>, because you call <code>open()</code> but not <code>close()</code>.  An even better habit, though, would be to <strong>always use open() in the context of a <code>with</code> block.</strong>

Furthermore, <code>csv_import()</code> could be simplified by using a dict comprehension:

MID

def csv_import(filename):
    with open(filename) as f:
        return {key: value for key, value in csv.reader(f)}


POST

The <code>auto_width()</code> function seems suspiciously long, for what should be simple functionality.  For one thing, <strong>everything is done twice:</strong> once for the keys, once for the values.  That led to a <strong>copy-and-paste bug:</strong> <code>value_len = len(max(dictionary.itervalues()))</code> finds the length of the value that comes last in alphabetical order, rather than the length of the longest value.  The <code>int()</code> conversions for <code>key_len</code> and <code>value_len</code> are superfluous.  The <code>int()</code> conversions for <code>min_len</code> and <code>max_len</code> should have been done when reading / validating the user input.

Renaming the results to <code>adjusted_key_len</code> and <code>adjusted_value_len</code> is also unnecessary.  In general, you have a habit of <strong>needlessly renaming variables just before returning.</strong>

SUBMITTED

var extras = {};
        if (similar) {
            extras.similar = true;
        }
        if (list) {
            extras.list = true

PRE

Be consistent with your method naming; don't mix <code>camelCase</code> and <code>snake_case</code>, pick one and stick with it. I would recommend picking <code>camelCase</code> as there are a lot of JavaScript projects out there which use it as a convention, but feel free to go with whatever is most readable to you.

I would define your <code>extras</code> object as so; falsey values shouldn't be picked up on the server side code anyway:

MID

var extras = {
    list: list,
    similar: similar
}


POST

As Backbone depends on underscore, don't be afraid to tidy up your code with underscore's methods:

SUBMITTED

Vector {
public:

    typedef T* Iterator;

    Vector

PRE

Your code is C++03 like (ie there are no move constructors or move assignment operators). You should definitely think about updating your class to be move aware.

The first thing about the interface is that the assignment operator is not close to the constructors. Since these are highly linked I like to place the assignment operators very close to the constructors (see rule of three/five).

Using <code>_</code> as a prefix is a bad idea. You <strong>don't</strong> break any rules (but was this on purpose or just an accident?). The rules are sufficiently complex that prefix <code>_</code> on identifiers is a bad idea for user space code. Others have suggested a prefix like <code>m_</code> personally I think that is old school advice. As long as the naming is clear there should be no issues.

My personal convention with identifiers is that anything that can be an object starts with a lowercase letter. Anything that is a type begins with an uppercase letter. Others will disagree with this convention as the standard does not follow it and this can lead to other conflicts.

Here is one of those exceptions to my rules.

MID

    typedef T* Iterator;


POST

You should probably have iterator with a lowercase <code>i</code>. This is because a lot of the algorithms will use the type.

Good start.

SUBMITTED

Implements IRepository

PRE

MID

IRepository

IRepository

POST

SUBMITTED

value);
    }

    public void InsertValue(Node currentNode, int value)
    {

        int comparison = value.CompareTo(currentNode.Value);

        if (comparison == -1)
        {
            if (currentNode.LeftNode == null)
            {
                currentNode.LeftNode

PRE

I don't quite understand what is the intended behavior of this "empty node", since it looks like the empty node behaves just like any other node. Instead, I think that empty nodes shouldn't be allowed, but empty tree (i.e. one where <code>RootNode</code> is <code>null</code>) should.

MID

int comparison = value.CompareTo(currentNode.Value);

if (comparison == -1)
{
    …
}
else if (comparison == 1)
{
    …
}


POST

<a href="http://msdn.microsoft.com/en-us/library/y2ky8xsk"><code>int.CompareTo()</code></a> is not guaranteed to return -1, 0 or 1, it can return any <code>int</code>, so you should use <code>comparison &lt; 0</code> and <code>comparison &gt; 0</code> here.

Also, if you're going to stick with <code>int</code>s (see below), I think just using <code>value &lt; currentNode.Value</code> and <code>value &gt; currentNode.Value</code> is much clearer.

SUBMITTED

bool AddOrUpdate

PRE

MID

AddOrUpdate()

POST

SUBMITTED

String promptNameOrg = "159;1234";

    String simplePromptName = extractSimplePromptName(promptNameOrg);
    Assert.assertEquals("1234", simplePromptName);
}

private String extractSimplePromptName(String promptNameOrg) {
    String simplePromptName = "";
    if (promptNameOrg != null) {
        if

PRE

Often, when performing text manipulation, Regular Expressions can do the work for you. Your solution is essentially manually building a text parser and stripper, when a regular expression will do the work in a much more concise way.

The regular expression would be to remove all text up to the last <code>\</code> or <code>;</code> character, which would be written as:

MID

private String extractSimplePromptName(String promptNameOrg) {
    return promptNameOrg == null ? "" : promptNameOrg.replaceAll("^.*(\\\\|;)", "");
}


POST

SUBMITTED

AN 1
        BTW Froot will run 1 through 100

      BOTH SAEM 0 AN MOD

PRE

I like how you have declared the Fizz and Buzz 'constants'. It makes the code more readable.

The comments are useful too, though, for consistency, the second comment should be changed from:

MID

BTW Froot will run 1 through 100


to

BTW Froot runs 1 through 100


POST

The idea of generating <code>Froot</code> from <code>Frootz</code> is also good, because it reduces the computations later in the code.

I only wish you used a better name than <code>Frootz</code> because it conflicts with <code>Froot</code>. The similarity is.... uncanny.

I would suggest the name <code>Loopz</code>:

SUBMITTED

static final

PRE

MID

final

POST

What's the point of the <code>final</code> modifier on a <code>private static</code> method like this one:

SUBMITTED

user
    printf("Enter a message: \n");
    //store it in str

PRE

The deallocation should still be done in <code>main()</code> since the allocation was done in there.  Also, the last output can be put into <code>checkForPalindromes()</code> since it's part of that functionality.

I also have some additional notes:

If you need a separate variable like <code>len</code>, consider giving it a more accurate name so that it's known <em>which</em> length is being stored.  You have two strings, so the reader could easily forget which string to which it belongs.  Adding additional strings would then make it worse.

Instead of using <code>printf()</code> for unformatted outputs:

MID

printf("Enter a message: \n");


use <a href="http://www.tutorialspoint.com/c_standard_library/c_function_puts.htm" rel="nofollow"><code>puts()</code></a>:

puts("Enter a message: ");


POST

It also gives you a newline, so you can leave out yours (unless you want two).

It's clearer to have each declaration or initialization done on a separate line, so instead of this:

SUBMITTED

parent("#signup div").hide

PRE

MID

#signup div

POST

Regarding your submit handler: earlier, you used the verbose but readable <code>.length === 0</code>. Why, then, are you using <code>!$.trim(...)</code> instead of <code>$.trim(...) === ""</code>?

I'm not a fan of iterating to check for empty fields twice. Instead, how about iterating through it once, using <code>if (emptyFields++ === 0) { $(this).select(); }</code>?

To expand on the last point: you use the following structure twice:

SUBMITTED

depth=1, max_depth

PRE

<em>Use internal function to hide inner implementation details</em> - It could be argued that this is a good candidate for using a function within the function. This internal function could be the one actually handling the recursion, and only having the parameters <code>path</code> and <code>depth</code>.

In other words, you could hide some of the inner workings of your function using a inner function, and let the outer function be a simple call to the inner function doing the work for you. Notice also that the inner function has full access to the outer functions variables, so need to pass them around (or treat as globals). 

<em><strong>BUG:</strong> Your code doesnt' respect the <code>max_depth</code> variable</em> – You don't have anything bailing out if the depth is too high...

MID

max_depth

POST

Here is the code when applying most of this comment to it:

SUBMITTED

gt;&gt;
  class comparator: protected GetKey, protected Less
public:
    const GetKey&amp

PRE

There is no need for this. The comparator operator should compare two objects. This seems to suggest that you're underlying class that you are using them is designed in such a way that you were lazy in deciding which type of value you were using and you overload every single combination to get rid of the compiler errors. 

While we have this class:

MID

class comparator: protected GetKey, protected Less


POST

Why are we inheriting from GetKey or Less? Neither of these classes have virtual interfaces where inheritance would make it sensible to inherit from them.

It is much easier to use composition in this case.

SUBMITTED

int cost, ArrayList cabins)
    {
        this.booker = booker;
        this.cost = cost;
        this.cabins = cabins;
    }

    public Reservation(Customer booker, int cost, room theCabin)
    {
        this.booker = booker;
        this.cost = cost;
        cabins.Add(theCabin);
    }
    public int getCostofBooking ()
    {
        return this.cost

PRE

Also, in the real world, a <code>cost</code> (or price) will rarely be a nice neat integer. <a href="https://stackoverflow.com/a/693373/3198973">Decimal is the proper datatype</a>. 

While I'm on the topic, I <em>think</em> that this should be named <code>Price</code>, not <code>Cost</code>. A cost is usually a cost to the business, whereas a price is what is charged to the customer. (Please disregard if I'm misreading your code.)

I like the flexibility the constructor overload gives, and I feel it reflects the very real possibilities of a person booking a single room, or many, but there some issues. 

MID

public Reservation(Customer booker, int cost, ArrayList cabins)
{
    this.booker = booker;
    this.cost = cost;
    this.cabins = cabins;
}

public Reservation(Customer booker, int cost, room theCabin)
{
    this.booker = booker;
    this.cost = cost;
    cabins.Add(theCabin);
}


POST

First off, you're duplicating the code that sets <code>this.booker</code> and <code>this.cost</code>. Create a private method to set these.

SUBMITTED

HashMap to store the key value pairs  **/
    private ConcurrentHashMap&lt;String , ConcurrentHashMap&lt;String,String&gt;&gt; session =  new  ConcurrentHashMap&lt;String , ConcurrentHashMap&lt;String,String&gt;&gt;();

    /** Used to create a new Map when new call ivr is established in the first vxml

PRE

This is pretty simple code, with not a lot of room for improvement.

You can make the <code>session</code> variable <code>final</code>, and it's good to do so:

MID

private final ConcurrentHashMap&lt;String, ConcurrentHashMap&lt;String, String&gt;&gt; session = new ConcurrentHashMap&lt;String, ConcurrentHashMap&lt;String, String&gt;&gt;();


You can simplify <code>createSession</code> a bit by dropping the pointless local variable:

public void createSession(String callId) {
    session.putIfAbsent(callId, new ConcurrentHashMap&lt;String,String&gt;());
}


POST

Some of the comments are really pointless, for example these:

SUBMITTED

x-2; i++) {
         lucas=lucas

PRE

MID

lucas=lucas

lucas = lucas

POST

SUBMITTED

this.$node;
    this.steps = options.steps;
    this.current = 0; // current step
    this.previousClickedCallback = options.previousClicked;
    this.draw(); // populate $node
    $(this.id).append(this.$node); // append $node to the DOM

PRE

Warning, side-effects and mixed responsibilities:

MID

this.draw(); // populate $node
$(this.id).append(this.$node); // append $node to the DOM


POST

So <code>draw</code> builds an element hierarchy in memory. But it doesn't return it. It assigns it to a variable, which some other code then has to go grab it from. But that only makes sense if <code>draw</code> has for sure been called. And called only once! Otherwise things break.<br>
Point is, it's a tangled mess. A better approach would be to have <code>draw</code> be in charge of inserting the elements, or make <code>draw</code> simply return the elements it creates like a factory function. Right now, it's neither here nor there. Personally, I'd pick the latter, call the function <code>build</code> rather than "draw", and not make it a prototype method, but an internal private function in the constructor.  

Then again, I'd much rather define my checklist in the HTML as a regular <code>ol</code> element, and simply use the JS to add the behavior (not the content or structure) for that list. Right now, you have HTML in you JavaScript, when those things should be kept separate. Structure in markup, style in CSS, and behavior in JavaScript. Yes, the lines do of course blur a lot, and many widgets do inject large chunks of HTML, but I'm wary of those approaches. One might ask why it doesn't inject all the CSS too, while it's at it.<br>
I'm not saying you should throw it all out, but do consider separating things.

Don't leave <code>console.log</code> statements in production code. At least not without safety checks/polyfills to ensure that <code>console.log</code> actually exists and is a function. Sure you only targeting a few browsers, but I'll get into that later.

Why is there only a callback option for going back? Why not use events instead, and fire them off for <em>any</em> state change? jQuery provides a nice, simple custom event API you can use. If you want callbacks instead of events, then I'd say add them now. You say it's easy to add such things, so why not? You may find it's not as easy as you think, or that a different interface might be even better.<br>
Besides, there's something weird going on with <code>previousClick</code> being a function that gets called only by external code - but which then invokes a callback, that's also defined externally. Why is the <code>ProgressBar</code> involved in that at all? And why does it pass a bunch of HTML as a string to the callback? Also, it'll fail immediately, if you call <code>previousClick</code> but haven't passed in a callback when instantiating the object.

Outside the code, this caught my eye.

So... your code is actually <em>very</em> coupled to the app after all. It may not be coupled though individual parts of the code, but the result is the same: You're prevented from easily using the widget elsewhere, and maintainability may be a hassle (if, say, the rest of the app gets updated to run on more browsers, you have that much more code to test/update). Pretty much the same things that'd apply if the code was tightly coupled to the app. Portability is basically decoupling on a larger scale.

Some of your decisions, like only having a callback for going backwards also betray coupling. Coupling in the sense that if you didn't need it for this particular app, in this particular context, you just didn't add it. Again, that's fair, but don't then say it's got low coupling.

Specifically because you aimed for a self-contained little widget that should be all the more reason to also aim for compatibility and portability. Sure, there's the usual cost/benefit weighing you'll have to do, and maybe it really doesn't make sense to support more browsers. However, the smaller and the mode self-contained the project, the easier it is to ensure good browser support. In fact, I'd wager the JS will run just fine on most browsers as-is; any issues will likely all be CSS-related. If I were you, I'd at least have tested it in other browsers, just out of curiosity.

At any rate, don't trick yourself into thinking it's decoupled, because in a sense it really, really isn't.

SUBMITTED

Static blogs generator.
#See https://github.com/st-kurilin/blogator for details.
#
#Main script. Used to build final script using build.py script.
#

###Files operations
#separated to make testing easier

"""Default values for some files.
   Used to distribute script as a single file.
   Actual values filled by build.py script."""
PREDEFINED = {}

def read(path):
    """Reads file content from FS"""
    if path in PREDEFINED:
        return PREDEFINED[path]
    with open(path.as_posix()) as file:
        return file.read()

def write(path, content):
    """Writes file content to FS"""
    with open(path.as_posix(), 'w') as

PRE

Those functions only complicate your code since the abstraction offered is not enough to compensate the added complexity.

MID

"""Default values for some files.
   Used to distribute script as a single file.
   Actual values filled by build.py script."""
PREDEFINED = {}

def read(path):
    """Reads file content from FS"""
    if path in PREDEFINED:
        return PREDEFINED[path]
    with open(path.as_posix()) as file:
        return file.read()


This one wouldn't be needed with a standard way to distribute your file. Also, the <a href="https://docs.python.org/3/library/pathlib.html" rel="nofollow">pathlib documentation</a> advises <code>str(path)</code> instead of <code>path.as_posix()</code>.

def write(path, content):
    """Writes file content to FS"""
    with open(path.as_posix(), 'w') as file:
        file.write(content)


Since you're in the context of your application, is it possible to give a more meaningful name to the <code>write</code> function?

def copy(from_p, to_p):
    """Copies file content"""
    import shutil
    shutil.copyfile(from_p.as_posix(), to_p.as_posix())

def file_exist(path):
    """Check if file exist for specified path"""
    return path.is_file()


POST

Think what you want about the clarity of <code>path.is_file()</code>, but those two functions complicate the code (I need to lookup what they do), while <code>shutil.copyfile</code> and <code>is_file()</code> are standard and more likely to be known by other developers.

SUBMITTED

pass1, String pass2){
        StringBuilder

PRE

This is not going to work well: if any of the passwords were null, you would get a NullPointerException when you check length.

Also, a better way to check if a string is empty is using <code>pass1.isEmpty()</code>.

Also, this is pointless and potentially confusing:

MID

pass1 = pass2;


POST

It would be better and more efficient to create <code>private final Pattern</code> members that are compiled regular expressions, and reusable multiple times:

SUBMITTED

then
               usage
            fi
            ;;
        *)
            usage
            ;;
    esac
done
shift $((OPTIND-1))

if [ -z "${BIT_SIZE}" -a "true" == ${isHardened} ]; then
    BIT_SIZE=4096
elif [ -z "${BIT_SIZE}" ]; then
    BIT_SIZE=$DEFAULT_BIT_SIZE
fi

ok "â¯â¯â¯ Generating DH elliptic curve key.  It

PRE

You evaluate <code>-z "${BIT_SIZE}"</code> twice, unnecessarily:

MID

if [ -z "${BIT_SIZE}" -a "true" == ${isHardened} ]; then
    BIT_SIZE=4096
elif [ -z "${BIT_SIZE}" ]; then
    BIT_SIZE=$DEFAULT_BIT_SIZE
fi


You can simplify the logic, and using <code>[[ ... ]]</code> also helps:

if [[ ! $BIT_SIZE ]]; then
    if [[ $isHardened = true ]]; then
        BIT_SIZE=4096
    else
        BIT_SIZE=$DEFAULT_BIT_SIZE
    fi
fi


POST

The formatting is strange here, and it makes your script harder to read:

SUBMITTED

The dummy table columns are
 * num INT, text VARCHAR, other VARCHAR
 */
//Using insert() method
$dbconnection-&gt;insert(array('num'=&gt;4,'text'=&gt;'New insert','other'=&gt;'This is a text'),'dummy');
//Using LastId() method
echo "&lt;pre&gt;";
//Using Result()
var_dump($dbconnection

PRE

<strong>General Approach</strong>

For me, your example calls: 

MID

insert(array('num'=&gt;4,'text'=&gt;'New insert','other'=&gt;'This is a text'),'dummy')
select("num, text, other",'dummy','num = 4')


are a bit hard to read. You could instead implement a query builder to make them look something like this:

new QueryBuilder().select("num", "other").from("dummy").where("num = ?", 4)


POST

Note also that the <code>4</code> is separate from the sql syntax, thus making it easier to use prepared statements when executing such a query.

For ideas for a querybuilder interface, you could look at existing once, such as <a href="http://fluentpdo.com/documentation.html" rel="nofollow noreferrer">FluentPDO</a> or the <a href="http://doctrine-dbal.readthedocs.org/en/latest/reference/query-builder.html" rel="nofollow noreferrer">QueryBuilder of Doctrine</a>. You could also take a look at the <a href="https://github.com/lichtner/fluentpdo/tree/master/FluentPDO" rel="nofollow noreferrer">source code of FluentPDO</a> to get some ideas (it's just a couple of files).

SUBMITTED

LabourHours as decimal(8, 2), @LabourRate as decimal(8, 2), @Stock as integer

AS
BEGIN

/* Update Record */
UPDATE Product SET CategoryID = @CategoryID,
Description = @Description, 
FullDescription = @FullDescription, 
Price = @Price,
MarkupPer = @MarkupPer,
 LabourHours = @LabourHours,
LabourRate = @LabourRate,
 Stock = @Stock
 WHERE ProductID = @ProductID
END

PRE

This indentation is inconsistent:

MID

UPDATE Product SET CategoryID = @CategoryID,
Description = @Description, 
FullDescription = @FullDescription, 
Price = @Price,
MarkupPer = @MarkupPer,
 LabourHours = @LabourHours,
LabourRate = @LabourRate,
 Stock = @Stock
 WHERE ProductID = @ProductID
END


The comments are just noise, it's pretty obvious from the way the code reads to figure out what it does. Especially comments like this:

/* Update Record */
UPDATE Product SET CategoryID = @CategoryID,


Vertical white space would make your code easier to read. For example:

ALTER PROCEDURE [dbo].[Product_SaveRecord] 
@ProductID as int, @CategoryID as tinyint, @Description as varchar(80),       @FullDescription as         varchar(240), @Price as decimal(8, 2), @MarkupPer as   decimal(8, 2), @LabourHours as decimal(8, 2), @LabourRate as decimal(8, 2), @Stock as integer


Compare to:

ALTER PROCEDURE [dbo].[Product_SaveRecord] 
    @ProductID as int, 
    @CategoryID as tinyint, 
    @Description as varchar(80),       
    @FullDescription as varchar(240), 
    @Price as decimal(8, 2), 
    @MarkupPer as   decimal(8, 2), 
    @LabourHours as decimal(8, 2), 
    @LabourRate as decimal(8, 2), 
    @Stock as integer;


Also, consistency would be good in how you capitalize keywords. Either do all caps, or all lower caps; it's less confusing that way. 

<strong>End your SQL statements</strong>

Not using the delimiter <code>;</code> throughout your query makes it more difficult to understand the logic of your code. Use <code>;</code> and even <code>GO</code> if need be. MS SQL Server is forgiving on syntax errors (try PostgreSQL for fun), that doesn't mean you shouldn't follow good practices of ending statements properly. 

You're trying to insert a row and then use the ID of the row you inserted. <a href="http://msdn.microsoft.com/en-us/library/ms187342.aspx" rel="nofollow">There is an easier way to do this</a> using <code>@@IDENTITY</code> in Transact-SQL.

Here would be a simpler way to do this your way, with above advice applied:

ALTER PROCEDURE [dbo].[Product_GetID] 
    @ProductID AS INT, 
    @CategoryID AS TINYINT, 
    @Description AS VARCHAR(80),       
    @FullDescription AS VARCHAR(240), 
    @Price AS DECIMAL(8, 2), 
    @MarkupPer AS DECIMAL(8, 2), 
    @LabourHours AS DECIMAL(8, 2), 
    @LabourRate AS DECIMAL(8, 2), 
    @Stock AS INTEGER
AS
BEGIN
INSERT INTO Product (CategoryID, Description, Price)
VALUES (0, '', 0);
UPDATE Product 
SET CategoryID = @CategoryID,
Description = @Description, 
FullDescription = @FullDescription, 
Price = @Price,
MarkupPer = @MarkupPer,
LabourHours = @LabourHours,
LabourRate = @LabourRate,
Stock = @Stock
WHERE ProductID = @@IDENTITY;
END


Why do you not simply insert your parameters within one single <code>INSERT</code> transaction?

ALTER PROCEDURE [dbo].[Product_GetID] 
    @ProductID AS INT, 
    @CategoryID AS TINYINT, 
    @Description AS VARCHAR(80),       
    @FullDescription AS VARCHAR(240), 
    @Price AS DECIMAL(8, 2), 
    @MarkupPer AS DECIMAL(8, 2), 
    @LabourHours AS DECIMAL(8, 2), 
    @LabourRate AS DECIMAL(8, 2), 
    @Stock AS INTEGER
AS
BEGIN
INSERT INTO Product(
    CategoryID,
    Description, 
    FullDescription, 
    Price,
    MarkupPer,
    LabourHours,
    LabourRate,
    Stock
) VALUES (
    @CategoryID,
    @Description, 
    @FullDescription, 
    @Price,
    @MarkupPer,
    @LabourHours,
    @LabourRate,
    @Stock
);
END


POST

SUBMITTED

nil? or

PRE

MID

or

POST

SUBMITTED

Application\AuthenticationStorage

PRE

MID

AuthenticationStorage

<strong>Misc</strong>

AuthenticationStorage:authenticateUser()

POST

SUBMITTED

Option Explicit

Public Enum LogLevel
    TraceLevel = 0
    DebugLevel
    InfoLevel
    WarnLevel
    ErrorLevel
    FatalLevel
End Enum

Public Enum LogManagerError
    DuplicateLoggerError = vbObjectError + 1098
    LoggerNotRegisteredError
End Enum

Private Type TLogManager
    Loggers As New Dictionary
End Type

Private this As TLogManager

Public Sub Register(ByVal logger As ILogger)
    If Not this.Loggers.Exists(logger.Name) Then
        this.Loggers.Add logger.Name, logger
    Else
        Err.Raise LogManagerError.DuplicateLoggerError, "LogManager.Register", "There is already a logger registered with name '" &amp; logger.Name &amp; "'."
    End If
End Sub

Public Sub UnregisterAll()
    this.Loggers.RemoveAll
End Sub

Public Function IsEnabled(ByVal level As LogLevel) As Boolean

    Dim logger As ILogger
    Dim item As Variant
    For

PRE

As I was looking through this code the duplicate registration was rubbing me the wrong way, so I investigated it a little bit because I was thinking to myself, what if I want to re-register the logger?

That is when I noticed that you don't have a method for releasing (un-Registering) one single logger, you can only release (un-register) all or nothing.

MID

Public Sub Register(ByVal logger As ILogger)
    If Not this.Loggers.Exists(logger.Name) Then
        this.Loggers.Add logger.Name, logger
    Else
        Err.Raise LogManagerError.DuplicateLoggerError, "LogManager.Register", "There is already a logger registered with name'" &amp; logger.Name &amp; "'."
    End If
End Sub

Public Sub UnregisterAll()
    this.Loggers.RemoveAll
End Sub


POST

I don't necessarily want to release one as I might want to reset it, but both methods would be helpful I think.

What if I just want to dispose the logger?  Maybe I am going too far here for VBA...

Okay, so I am looking at <code>TestTraceLoggerEnablesAllLogLevels</code> and at first I couldn't make heads or tails of what is supposed to pass and what is supposed to fail, but I think that I figured that out.

So what I would do first is create a fun array and go through this in a for loop or use a list (<em>if I have that functionality in VBA</em>)

I guess what I would do is take the already created Enum <code>LogLevels</code> and iterate through that asserting what is true...

I probably changed the code slightly because I don't think I have the right syntax, but here is what I am thinking

SUBMITTED

Release();

    CoUninitialize();

    while(true)
    {
        Sleep(1000);
    }

    return

PRE

<code>pComObject</code> has to be <code>NULL</code> at this point, so there is no reason for this check.

MID

while(true)
{
    Sleep(1000);
}


POST

If you want to wait forever, <a href="http://msdn.microsoft.com/en-us/library/ms686298" rel="nofollow">the documentation</a> says you should be able to use <code>Sleep(INIFINITE);</code>.

SUBMITTED

series;
  while (ifs.good()) {
    string line;
    getline(ifs, line);
    series += line;
  }
  ifs.close();
  // take the product of the first 13 elements

PRE

This is probably not a good idea:

MID

while (ifs.good()) {
  string line;
  getline(ifs, line);
  series += line;
}


You should be checking the stream itself, not the current state of the stream.  This can be done by putting the stream read (<code>getline()</code> in this case) inside the loop statement.

Also, as <code>getline()</code> (which uses <code>line</code>) will be moved out of scope after this change, you'll need to initialize <code>line</code> before the loop.

string line;

while (getline(ifs, line)) {
    series += line;
}


POST

This will both attempt the read and determine if it was successful.  If it wasn't, specifically if the end of the file has been reached, then it will fail, and the loop will terminate.  See <a href="https://stackoverflow.com/a/4324667/1950231">this answer</a> for more info.

Your compiler should've warned you about this type-mismatch:

SUBMITTED

loop

    inFile.close();
}//end

PRE

Don't manually close a file:

MID

    inFile.close();


POST

see:  <a href="https://codereview.stackexchange.com/q/540/507">My C++ code involving an fstream failed review</a>

As noted above:

SUBMITTED

class JunctionRule

PRE

MID

JunctionRule

POST

SUBMITTED

RED)
                    {
                        errors.Add(student.Value._Name

PRE

MID

student.Value._Name

POST

SUBMITTED

id, $oConni

PRE

MID

oConni

POST

SUBMITTED

Process myProcess

PRE

<strong>Misc</strong>

MID

myProcess

POST

SUBMITTED

Looks in a dictionary for a key called parameterName
    ModelState modelState = ViewData.ModelState.FirstOrDefault(x =&gt; x.Key.Equals(parameterName)).Value;
    //If I could find it I look for any error associatd to that and I return it as a single string
    return modelState != null &amp;&amp; modelState.Errors.Any(x =&gt; !string.IsNullOrEmpty(x.ErrorMessage

PRE

Not only is this difficult to read, it's also <em>inefficient</em>.

Cache your duplicate LINQ lookup to save time and make it more readable.

As for using the ternary operator, that's up to you, but I prefer to use a full if statement when the line gets too long.

Additionally swap out "" for String.Empty, it shows your intent better, and also makes it more strongly contrast against " "

MID

var state =ViewData.ModelState.FirstOrDefault(x =&gt; x.Key.Equals(parameterName));

if(state.Value != null &amp;&amp; 
    state.Value.Errors.Any(x =&gt; !string.IsNullOrEmpty(x.ErrorMessage)))
{
    return string.Empty;
}
else
{
    return " ";
}


I'm assuming this next bit executes elsewhere, because the two return statements above would otherwise make this unreachable code.

Use var when the type is obvious from the right hand side of the assignment (although in this case it's a little debatable, I'd personally use var here because the variable name mimics the type).

You have a typo in your second comment.

//Looks in a dictionary for a key called parameterName
var modelState = ViewData.ModelState.FirstOrDefault(x =&gt; x.Key.Equals(parameterName)).Value;
//If I could find it I look for any error associated to that and I return it as a single string
if(modelState.Value != null &amp;&amp; 
    modelState.Value.Errors.Any(x =&gt; !string.IsNullOrEmpty(x.ErrorMessage)))
{
    return string.Empty;
}
    else
{
    return " ";
}


Finally, structure-wise I'd recommend converting the if-statement above into a separate method, since you call it in multiple places. This will leave a single point to modify during refactoring.

private string ConvertModelStateErrorsToString(ModelState modelState)
{
    if(modelState.Value != null &amp;&amp; 
        modelState.Value.Errors.Any(x =&gt; !string.IsNullOrEmpty(x.ErrorMessage)))
    {
        return string.Empty;
    }
        else
    {
        return " ";
    }
}


Leaving your other code samples as:

var state =ViewData.ModelState.FirstOrDefault(x =&gt; x.Key.Equals(parameterName));

return ConvertModelStateErrorsToString(state);


And the other sample:

//Looks in a dictionary for a key called parameterName
var modelState = ViewData.ModelState.FirstOrDefault(x =&gt; x.Key.Equals(parameterName)).Value;
//If I could find it I look for any error associated to that and I return it as a single string
return ConvertModelStateErrorsToString(modelState);


POST

SUBMITTED

suffixes :: [a

PRE

Looks good to me. The only thing I would change is

MID

suffixes [] = [] : []


to

suffixes [] = [[]]


POST

as it's a bit more readable.

When re-inventing functions, it can be instructive to look up their definition using <a href="http://www.haskell.org/hoogle/?hoogle=tails">Hoogle</a>. Following the links, we find this definition in <a href="http://hackage.haskell.org/package/base-4.7.0.1/docs/src/Data-List.html#tails"><code>Data.List</code></a>:

SUBMITTED

width */
    {
        target.x = j;
        total++;
        if(spl_total(sources, count, target) &gt; LIMIT)
            danger++;
    }
}
printf("Points sampled

PRE

… but you wouldn't use that, since arrays in C are indexed starting from 0.

Mixing the two patterns, as you have done, is weird, and will likely lead to off-by-one errors when a future collaborator works on your code — if it isn't already a bug.

<code>total</code> could just be <code>(SIZE + 1) * (SIZE + 1)</code>.

Omitting optional braces is bad practice.  Think of it as an act contributing to a future <a href="https://www.imperialviolet.org/2014/02/22/applebug.html" rel="nofollow">coding accident</a>.  If you don't like wasting two lines of vertical space for braces, then adopt the more compact K&amp;R-style braces.  If you <em>really</em> want to omit braces for some reaons, then put the body on the same line as the test.

MID

    if (spl_total(sources, count, target) &gt; LIMIT) {
        danger++;
    }


or

    if (spl_total(sources, count, target) &gt; LIMIT) danger++;


POST

SUBMITTED

class MultiSet
  include Enumerable

  def initialize enum=[]
    @members = {}
    raise ArgumentError, "enum must include the 'Enumerable' module" unless enum.kind_of? Enumerable
    enum.each do |item|
      add item
    end
  end

  def each &amp;blk
    @members.each &amp;blk
  end

  def == other
    @members.to_h == other.to_h
  end

  def eql? other
    self == other
  end

  def members
    @members.dup
  end  

  def to_a
    a = []
    @members.each do |key, count|
      count.times { a &lt;&lt; key }
    end  
    a
  end  

  def to_set
    Set.new members.keys
  end

  def remove item
    if include? item
      @members[item] = @members[item] - 1
      @members.delete item if @members[item] &lt; 1
    end
    self
  end

  def add item
    if include? item
      @members[item] += 1
    else
      @members[item] = 1
    end
    self
  end

  def clear
    @members.clear
  end

  def multiplicity item
    include?(item) ? @members[item] : 0
  end

  def include? item
    @members.include? item
  end

  def cardinality
    @members.values.reduce(0,:+)
  end

  def | other
    union = self.class.new(self.to_a)
    other.each do |key, count|
      count.times { union.add key }
    end
    union
  end

  def &amp; other
    intersection = self.class.new
    @members.each do |key, count|
      if other.include? key
        max_count = [count, other.multiplicity(key)].min
        max_count.times { intersection.add key }
      end  
    end
    intersection
  end

  alias_method :to_h, :members

end

PRE

Your tests all look pretty thorough, and I don't really have anything to say about them that I didn't say in the first section. However, I do tend to miss edge cases, so please give it another look if you're concerned about that. 

Put together, this is your final code:

MID

class MultiSet
  include Enumerable

  def initialize(enum=[])
    @members = Hash.new(0)
    raise ArgumentError, "enum must include the 'Enumerable' module" unless enum.kind_of?(Enumerable)
    enum.each do |item|
      add(item)
    end
  end

  def each(&amp;blk)
    @members.each(&amp;blk)
  end

  def ==(other)
    @members.to_h == other.to_h
  end

  def members
    @members.dup
  end

  def to_a
    a = []
    @members.each do |key, count|
      count.times { a &lt;&lt; key }
    end
    a
  end

  def to_set
    Set.new(members.keys)
  end

  def remove(item)
    @members[item] -= 1
    @members.remove(item) if @members[item] &lt; 1
    self
  end

  def add(item)
    @members[item] += 1
    self
  end

  def clear
    @members.clear
  end

  def multiplicity(item)
    @members[item]
  end

  def include?(item)
    @members.include?(item)
  end

  def cardinality
    @members.values.reduce(0, :+)
  end

  def |(other)
    union = self.class.new(self.to_a)
    other.each do |key, count|
      count.times { union.add(key) }
    end
    union
  end

  def &amp;(other)
    intersection = self.class.new
    @members.each do |key, count|
      if other.include?(key)
        max_count = [count, other.multiplicity(key)].min
        max_count.times { intersection.add(key) }
      end
    end
    intersection
  end

  alias_method :to_h, :members
  alias_method :union, :|
  alias_method :intersection, :&amp;
  alias_method :eql?, :==
end


POST

SUBMITTED

data(int n) {
    Random random = new Random(seed); // Random seed stays same for all sorts
    int[] list = new int[n];

    for(int i = 0; i &lt; list.length; i++) {
        list[i] = random.nextInt(1000);
    }

    return list;
}

public static void printList(int[] list) {
    for(int i = 0; i &lt; list.length; i++) {
            System.out.format("%5d",list[i]);
    }
    System.out.println();
}

public static void printToFile() {
    // Print to file
    try {
        File file = new File("times.txt");
        if(!file.exists())
            file.createNewFile();
        FileWriter fw

PRE

So, I did a few tests with your code, except I changed the data generator to: 

MID

public static int[] data(int n) {
    Random random = new Random(seed); // Random seed stays same for all sorts
    int[] list = new int[n];

    for(int i = 0; i &lt; list.length; i++) {
        list[i] = random.nextInt(list.length * 10);
    }

    return list;
}


POST

When I ran yur code with this, I got the results:

SUBMITTED

and 1 &lt; int(starting_base) &lt; 37):
        print("Please enter a positive integer between 2 and 36")
        starting_base = input("starting base: ")

    return int(starting_base)


def get_starting_num(starting_base):
    """ Input and verification of starting number, that it is a positive integer
    using only characters from its base. Returns starting_num as a string."""
    # Assigns string which only contains characters from the given base
    base_members = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"[0:starting_base]

    # Gets initial input
    starting_num = input("starting number: ")

    # Assumes the input is proper, then gives it a change to prove us wrong.
    # If it uses characters that are not available in that base, the user will
    # be prompted again
    is_proper = True
    for character in starting_num:
        if character not in base_members:
            is_proper = False

    while not is_proper:
        print("Please only use characters in your base (Capital letters for " +
              "bases larger than than 10)" )
        starting_num = input("starting number: ")

        is_proper = True
        for character in starting_num:
            if character not in

PRE

<strong>Logic flow</strong>

Then, the whole <code>get_starting_num</code> function can be rewritten :

MID

def get_starting_num(starting_base):
    """ Input and verification of starting number, that it is a positive integer
    using only characters from its base. Returns starting_num as a string."""
    # Assigns string which only contains characters from the given base
    base_members = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"[0:starting_base]

    while True:
        starting_num = input("starting number: ")
        if all(c in base_members for c in starting_num):
            return starting_num
        print("Please only use characters in your base (Capital letters for " +
              "bases larger than than 10)")


The reasons why I prefer that way to write it :

Similarly, I'd rather write <code>get_starting_base</code>:

def get_starting_base():
    """ Input and verification of starting base, that it is a positive integer
    between 2 and 36. Returns starting_base as an integer."""
    while True:
        starting_base = input("starting base: ")
        if starting_base.isdigit() and 1 &lt; int(starting_base) &lt; 37:
            return int(starting_base)
        print("Please enter a positive integer between 2 and 36")


and <code>get_ending_base</code>:

def get_ending_base():
    """ Input and verification of ending base, that it is a positive integer
    between 2 and 36. Returns ending_base as an integer."""
    while True:
        ending_base = input("ending base: ")
        if ending_base.isdigit() and 1 &lt; int(ending_base) &lt; 37:
            return int(ending_base)
        print("Please enter a positive integer between 2 and 36")


<strong>Reusing code</strong>

Now that we've played a bit with <code>get_(starting|ending)_base</code>, we notice that they look very similar. It might be worth writing a more generic function to handle this :

def get_integer_in_range(prompt, mini, maxi):
    while True:
        starting_base = input(prompt)
        if starting_base.isdigit() and mini &lt;= int(starting_base) &lt;= maxi:
            return int(starting_base)
        print("Please enter a positive integer between %d and %d" % (mini, maxi))


def get_starting_base():
    return get_integer_in_range("starting base: ", 2, 36)

def get_ending_base():
    return get_integer_in_range("ending base: ", 2, 36)


POST

<strong>Premature optimisation</strong>

Your check on <code>if starting/ending_base == 10:</code> makes your code more complicated and adds little.
Also, it makes testing akward as it bypasses pretty much the only case I can check without any electronic device.

<strong>Naming</strong>

A few things are not that great in the naming of your functions and variables especially because it does not convey much information about the actual type of the data we are handling :

SUBMITTED

align(Align, sizeof(T), raw_ptr, space);
        new (ptr)T(std::forward&lt;Args&gt;(args)...);
        m_object = reinterpret_cast&lt;T*&gt

PRE

You don't need <code>reinterpret_cast</code> to convert an object pointer to <code>void*</code>, a <code>static_cast</code> is sufficient for that. Don't use stronger casts than necessary.

You can simplify the assignment to <code>m_object</code> and make it more obvious by assigning the result of the placement-new into it:

MID

m_object = new (ptr) T(std::forward&lt;Args&gt;(args)...);


POST

<code>16</code> looks like a rather arbitrary number for the default template argument for <code>Align</code> (it's actually a magic number). There is even no guarantee that 16 is a valid alignment value. I would probably choose something less arbitrary such as <code>sizeof(void*)</code>.

There is no reason to use <code>std::aligned_storage</code> for the type of <code>m_storage</code>. You don't actually care about alignment of <code>m_storage</code> at all (which is emphasised by you passing <code>1</code> to its <code>Align</code> parameter). All you need is a buffer of suitable size, and for this <code>usigned char[sizeof(T) + Align -1]</code> (or a <code>std::array</code>) would work just as well.

As a side note, be aware that <code>std::aligned_storage_t</code> was only introduced in C++14. Visual Studio 2013 supports some C++14 bits, but using it makes your code non-C++11-compliant.

You might want to swap the order of the data members, it might prevent need for padding between an oddly-sized <code>m_storage</code> and aligned <code>m_object</code>.

You might consider overloading the pointer operators <code>*</code> and <code>-&gt;</code> for your class as syntactic sugar for <code>get()</code>, it simplifies usage. Other generic classes which store a single object sometimes do so as well; an example is <a href="http://www.boost.org/doc/libs/1_56_0/libs/optional/doc/html/boost_optional/reference/detailed_semantics.html#reference_optional_operator_asterisk" rel="nofollow"><code>boost::optional</code></a>.

SUBMITTED

lt;Real

PRE

MID

Real

POST

SUBMITTED

element.Split('-').First()),
  element =&gt; Convert.ToInt32(element.Split('-').Last()));
string substring = "";
foreach (KeyValuePair&lt;int, int&gt; entry in intervals)
  substring += input.Substring(entry.Key - 1, entry.Value - entry.Key

PRE

If usage of the <code>foreach</code> is an issue, you could replace it with the <code>IEnumerable&lt;T&gt;.Aggregate</code> method call:

MID

string substring = intervals.Aggregate(String.Empty, 
    (current, entry) =&gt; 
        current + input.Substring(entry.Key - 1, entry.Value - entry.Key + 1));


If performance is a root, you could try to use the <code>StringBuilder</code> class:

StringBuilder sBuilder = new StringBuilder(input.Length);
foreach (var entry in intervals)
    sBuilder.Append(input, entry.Key - 1, entry.Value - entry.Key + 1);
string substring = sBuilder.ToString();


POST

And there is no reason to use the <code>Dictionary&lt;int, int&gt;</code>. It could be easily replaced with the <code>List&lt;Tuple&lt;int, int&gt;&gt;</code> or with the <code>IEnumerable&lt;Tuple&lt;int, int&gt;&gt;</code> (but in the last case there is no <code>ForEach</code> extension method):

SUBMITTED

Grid
gridGeneration (Grid []) = Grid []
gridGeneration (Grid rs@(row0:row1:row2:rows)) = Grid $ g ([]:rs

PRE

Use clear names

Your tests looks good, you might want to add cases for smaller grids and non-square ones as well though. You might also consider if QuickCheck could be helpful, but I don't see any obvious properties, apart from that all functions should preserve length, but that is already (mostly) covered by the existing tests.

Thanks for supplying tests, it helped me with verifying that my suggestions didn't break anything. :)

Edit: According to Hspec documentation you are supposed to use one <code>describe</code> per function, not one per module as you did.

As I said, you crash on grids with one or two rows, but your code actually
supports them already (they are handled by <code>g</code>). Just remove the arbitrary constraint of needing at least
three rows at the second case of <code>gridGeneration</code> (and remove the third case).

MID

gridGeneration (Grid rs) = Grid $ g ([]:rs)
  where
    ...


POST

The function <code>g</code> also handles empty grids correctly, so you can remove the first case as well.

I know you weren't that interested in efficiency, but here it is anyways.

Your code currently traverses the whole row for every single cell. Example:

SUBMITTED

JButton dismiss = new JButton("OK");
                dismiss.addActionListener(a -&gt; {
                    events.postEvent(new WindowEvent(winAlert,
                            WindowEvent.WINDOW_CLOSING));
                });
                winAlert.add(dismiss);
                SwingUtilities.invokeLater(() -&gt; {
                    winAlert.setVisible(true);
                });
            }
        });

        this.add(submit);
        this.add(textInput);
        this.add(teamInput

PRE

The connection between the size of <code>fields</code> and the <code>FIELD_COUNT</code> constant is semantic: this code snippet doesn't guarantee that <code>fields</code> has enough capacity to contain <code>FIELD_COUNT</code> elements.
The implementation will be more robust if you iterate until <code>fields.length</code> instead.

On a related note, unless you specifically need an array,
it's recommend to use a <code>List</code> instead.
It would eliminate such worries as index overflows in this loop,
and all other potential uses of <code>fields</code>.
The iteration in <code>repaintPositions</code> for example
would also become more straightforward,
using <code>fields.stream()</code> instead of <code>Arrays.stream(fields)</code>.
Finally, the <code>fields</code> member can be <code>final</code>.

Some lambda expressions are unnecessarily enclosed in <code>{...}</code>:

MID

dismiss.addActionListener(a -&gt; {
    events.postEvent(new WindowEvent(winAlert,
            WindowEvent.WINDOW_CLOSING));
});

// ...

SwingUtilities.invokeLater(() -&gt; {
    winAlert.setVisible(true);
});


These could be simply:

dismiss.addActionListener(a -&gt; events.postEvent(new WindowEvent(winAlert,
        WindowEvent.WINDOW_CLOSING)));

// ...

SwingUtilities.invokeLater(() -&gt; winAlert.setVisible(true));


POST

I think the most significant property of a team is the name,
and the color is secondary.
So I would put the constructor params in that order,
and to be consistent, the member field declarations too.

SUBMITTED

template&lt; class RandomIt, class TGetValue &gt;
double average( RandomIt first, RandomIt last, TGetValue getValue

PRE

That's definitely an interesting approach. However, I would say that this interface is trying to accomplish too much. That is, <code>average</code> should just be responsible for calculating the average value over some range <code>[first, last)</code> and <em>not</em> worry about any indirection. E.g., only provide the signature

MID

template&lt; class InputIterator &gt;
double average( InputIterator first, InputIterator last );


Note that I've changed your <code>RandomIt</code> to an <a href="http://en.cppreference.com/w/cpp/concept/InputIterator" rel="nofollow">InputIterator</a> since I think this is a better choice.

Any indirection should instead be handled with <em>iterator transformation</em>. I.e., an adapter which wraps the raw <code>QMap::iterator</code> and overrides <code>operator *()</code> to either return the key or the value. Boost has the <a href="http://www.boost.org/doc/libs/1_56_0/libs/iterator/doc/transform_iterator.html" rel="nofollow"><code>boost::transform_iterator</code></a> which does exactly that. Even more concretely, there is also the <a href="http://www.boost.org/doc/libs/1_56_0/libs/iterator/doc/indirect_iterator.html" rel="nofollow"><code>boost::indirect_iterator</code></a> which is very similar to your <code>Dereference</code> class.

Again, the motivation is to divide up the responsibility into separate classes so that each such class is as simple as possible. Complex tasks are then accomplished by <em>combining</em> these separate classes.

All that being said, let me review the code that you already have written. Because, like I said, it is still an interesting approach!

Use <code>InputIterator</code> instead of <code>RandomIterator</code> as the template parameter for <code>average</code>. <code>InputIterator</code> is more generic and is all you need to compute the average value of a range. When C++ gets ConceptsLite, this will make even more sense.

<code>average</code> always returns <code>double</code>. What about <code>float</code> ranges? Use a trailing return type together with <code>iterator_traits</code> to get the value type of the iterator instead. E.g.,

template&lt; class InputIterator&gt;
auto average( InputIterator first, InputIterator last )
    -&gt; typename iterator_traits&lt;InputIterator&gt;::value_type;


POST

In C++14 this is even simpler as you can simply drop the trailing return type.

Prefer <code>using</code> over <code>typedef</code>. They accomplish the same thing but <a href="https://stackoverflow.com/questions/10747810/what-is-the-difference-between-typedef-and-using-in-c11"><code>using</code> is more powerful</a>.

Besides that, the code looks fine to me. Good job! Please also consider the alternative I wrote in the first part of this post.

<strong>Edit:</strong> I recently read <a href="https://ericniebler.github.io/std/wg21/D4128.html#algorithms-should-take-invokable-projections" rel="nofollow">D4128: Ranges for the Standard Library: Revision 1</a> by Eric Niebler which proposes to overload <em>all</em> algorithms with <em>Projection</em> callables exactly as you did. Note that the very same proposal also includes <em>Range Transform View</em> which is an analogue to the iterator transforms I mentioned. That is, Projections and Range Transform Views coexist and serve slightly different purposes. You can read the proposal to get all the details.

In short, a future C++ standard may include a feature which is very similar to your suggestion. It may even come <a href="http://ericniebler.com/2014/11/07/ranges-concepts-and-the-future-of-the-standard-library/" rel="nofollow">sooner than C++17 in the shape of a TS</a>.

SUBMITTED

Widget container
(function($) {
// Widget container plugin
    $.fn.myWidget = function () {
        this.each (function () {
            // Vars
            var item = $ (this);

            // Set events
            item.click (function (e) {
                if (e) e.preventDefault

PRE

From a once over:

Using <code>each</code> seems overkill, this works:

MID

$.fn.myWidget = function () {
    this.click( function (e) {
        if (e) {
            e.preventDefault ();
        }
        combine_all(this);
    });
};


POST

This code assigns the same function to all elements in <code>this</code>, the function has <code>this</code> as the clicked element, so that is why you provide to <code>combine_all</code>

SUBMITTED

if (typeof Object.create

PRE

Now, is my code efficient?

We don't care. There's not much going on here, there are not thousands of elements in the DOM, and there are no tight data processing loops. If the UI feels sluggish, something must have been gone horribly wrong.

However, there is one inefficiency in your code that matters: The JSON file is fetched on really every single click. I'm pretty sure this is not desired.

It would be OK if you expect it to change really often (that is, &lt; 15min); or if the response would be dynamically created and you did transmit the currently selected option as a parameter.

Especially, the click function within getRegion function? Is this the correct way to handle the click events in OO?

Yes, that's fine.

However, a few oddities I found in your code:

MID

Object.create

POST

SUBMITTED

preferences.getPreferredTimeZone

PRE

MID

getPreferredTimeZone

POST

Alas, this does have the drawback of an extra <code>if</code> condition compared to the original. However, the cost of the extra call should be negligible in practice. This may be a matter of taste. I think the value of clarity in the design outweighs the cost of that extra <code>if</code> (unless performance is absolutely critical, of course).

SUBMITTED

int randNum = 0;
    int upperLimit = 100;
    int lowerLimit = 1;
    String myAnswer

PRE

This is of course less efficient than a simple <code>equals</code>,
so don't use it excessively everywhere,
only when justified.

These initializers are redundant:

MID

int randNum = 0;
String myAnswer = "";


Because, these variables will always be assigned before they are used.
As such, you can remove the initializers:

int randNum;
String myAnswer;


POST

It's a cosmetic thing,
but your formatting doesn't follow the standard in a few places.

Instead of this:

SUBMITTED

var map

PRE

MID

map

POST

Instead of this:

SUBMITTED

true;
    double

PRE

MID

double

POST

SUBMITTED

hint numbers
    while(y

PRE

Then later 

MID

while(y != 9)


can become 

while ( BOARD_HEIGHT &gt; y )


POST

Note that I also changed it from <code>!=</code> to <code>&lt;</code>.  The <code>!=</code> is fragile in the face of future changes.  If you would increment <code>y</code> twice in one loop, you could shoot past your boundary condition.  This way your boundary condition is a region rather than a point, so it will trigger under more conditions.  

SUBMITTED

i = 0,
            chapterFound = false;
            //console.log(chapterTime

PRE

This looks just fine to me.

Some very minor nitpicks:

MID

//console.log(chapterTime);

POST

SUBMITTED

c) {
        return (base &lt;&lt; SHIFT | base &gt;&gt;&gt; (BITS - SHIFT)) ^ c;
    }

    /*
     * Shift the char to remove to the

PRE

For <code>int</code>, the rotation distance of 31 would be equivalent to -1, which is not good as the next <code>char</code> uses about the same bits. For <code>long</code>, it's not bad.

You're speaking about primes, but the shift is modulo 64 and there's no such thing as primes in the ring <code>Z/64</code>. Again, what you need is a number co-prime to 64, i.e., odd. This assures that it takes 64 operations to land in the same position.

I don't think 31 is very good, as after two operations, you get 62, i.e., -2. So using three ASCII chars, a collision can be easily produced as their bits overlap.

When sticking with ASCII, 7 should be fine, but for general strings, I'd suggest at least 16. FWIW, with 17, you're guaranteed that there'll no collisions for up 3 steps. After 4 steps, it totals to 68, i.e., 4, which is not perfect, so I'd go for 19 instead. A measurement with real data could tell us more, while I guess, the answer is that it doesn't matter much.

MID

(base &lt;&lt; SHIFT | base &gt;&gt;&gt; (BITS - SHIFT))


POST

Wrong! Use <code>Long.rotateLeft</code>. It does exactly the same, but is clearer and much faster as it's an intrinsic. Whenever the JIT sees <code>Long.rotateLeft</code>, it uses the rotation instruction; when it sees an equivalent code, it doesn't care.

Actually, you need no <code>BITS</code> as the distance is taken modulo 64 (guaranteed in Java, undefined in C).

SUBMITTED

input) in-bank)))

(defn change-calc [change-requested change-given

PRE

The result is a pair: 

Examples:

MID

(change 8 in-bank)
;[{1 1, 2 1, 5 1} 0]

(change 8 #{2 5 10})
;[{2 1, 5 1} 1]

(change 13 #{1 5 10})
;[{1 3, 10 1} 0]


POST

SUBMITTED

HNStream']


class Item:

    def __init__(self, **kwargs):
        self.__dict__.update(kwargs)

    def __str__(self):
        return "{}: {}".format

PRE

I have a number of suggestions:

MID

def __init__(self, **kwargs):
    self.__dict__.update(kwargs)


POST

It is pretty unclear which attributes the class will have after calling the constructor, as it is basically up to the caller to decide this. This is not optimal, as you want to be in control of what data is set in an item. I'd suggest to use named arguments instead:

SUBMITTED

var linkTags

PRE

MID

linkTags

POST

SUBMITTED

ts codePos

PRE

MID

codePos

POST

SUBMITTED

s.%N")-$start_time)/$dim_secs)" | bc -l)
                if [ $(echo "$br &gt

PRE

And so on, similarly at other places too, you get the idea.

Another common pattern I see at many places:

MID

echo "$br &gt;= 0" | bc -l


That is, using <code>echo</code> to pass a string to a command.
A better way is using <em>here-strings</em>, like this:

bc -l &lt;&lt;&lt; "$br &gt;= 0"


POST

This long line appears at multiple places, sometimes with minor variations:

SUBMITTED

gt; getInformation

PRE

MID

getInformation()

POST

SUBMITTED

string const

PRE

MID

const

POST

Generally speaking, it doesn't make sense to specify <code>const</code> on a return value of a function when that return values is a simple type such as <code>int</code>.  In particular, the following functions should not have <code>const</code> as part of the return value:

SUBMITTED

Task&gt;(taskQueue.size(),PRIORITY_COMPARATOR);
                    for (Task task : taskQueue) {
                        if (task instanceof Interruptible &amp;&amp; ((Interruptible) task).isInterrupted

PRE

Moving swiftly on to one of the last points I want to make:

MID

if (task instanceof Interruptible &amp;&amp; ((Interruptible) task).isInterrupted()) {


Your requirements nowhere state, that only interrupted Interruptibles are to be executed later. Assuming you didn't have the definition of <code>Interruptible</code> given, I had suspected it to be a marker-interface. I'd shorten the code to:

if (task instanceof Interruptible) {


POST

Almost finished:

SUBMITTED

ItemPrice + " x

PRE

MID

x

POST

SUBMITTED

using Microsoft.Win32;
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Net;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading

PRE

These <code>using</code> directives are not needed and can be safely removed:

MID

using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Linq;
using System.Text;
using System.Threading.Tasks;


POST

Method names should be <code>PascalCase</code>:

SUBMITTED

class="hero-action"&gt

PRE

This is safer, in many ways:

MID

hero-action

hero-action

You might want to adjust the placement of the <code>break</code> statement:

hero-action

POST

SUBMITTED

return;
    }


    ArrayList&lt;Tile&gt; listt = new ArrayList();

    /* Adds all the tiles with equal

PRE

A method name should be a verb with possible exceptions like <code>newSomething</code> for methods returning <code>Something</code>.

So either <code>manageNodes</code> or <code>NodeManager nodeManager = new NodeManager();</code>.

MID

ArrayList&lt;Tile&gt; listt = new ArrayList();


POST

<code>listt</code> looks more like a typo than a name. While I still can recall A*, the exact variable names are gone (and maybe they were called differently in my book).

SUBMITTED

from DataFrames for non-redundant groupings
       `workingdf` is used to avoid modifying original DataFrame
    '''
    uniqcols = (i for i in grpby if len(df[i].unique()) == 1)
    pwrset = (i for i in powerset(grpby))
    s = set()
    for uniqcol in uniqcols:
        for i in pwrset:
            if uniqcol in i:
                s.add(i) # add a level of aggregation only when non-redundant

    workingdf = df.copy()
    #for idx,i in enumerate(powerset(grpby)):
    for idx,i in enumerate(s):
        print('  grouping by: {}'.format(i))
        if i != (): 
            tmp = aggfunc( workingdf.groupby(i) )
        else:
            # hack to get output to be a DataFrameGroupBy object:
            #   insert dummy column on which to

PRE

About this part:

MID

def grouper(df,grpby=None,aggfunc=None):
    uniqcols = (i for i in grpby if len(df[i].unique()) == 1)
    pwrset = (i for i in powerset(grpby))
    s = set()
    for uniqcol in uniqcols:
        for i in pwrset:
            if uniqcol in i:
                s.add(i) # add a level of aggregation only when non-redundant


POST

SUBMITTED

int&gt;marbles;

    case1 = 0;

    while(true)
    {
        scanf("%d %d", &amp;numMarbles, &amp;numQueries);
        if(0 == numMarbles &amp;&amp; 0 == numQueries

PRE

You are mixing C with C++. I know these contests like speed, but it is usually unnecessary.

<strong>1. Prefer streams over <code>scanf</code>.</strong>

This means you can change this code:

MID

    scanf(&quot;%d %d&quot;, &amp;numMarbles, &amp;numQueries);


POST

Into this:

SUBMITTED

int i

PRE

Please find my (language agnostic) suggestions below :

<strong>String reversal</strong>: 

MID

i

(len-i-1)

POST

SUBMITTED

player and create Baseball Card."""
        return BaseballCard(*[player for player in organization.players if player in other_org][0].stats

PRE

You can use <a href="https://docs.python.org/2/library/functions.html#next" rel="nofollow"><code>next</code></a> with a generator expression. Here instead of creating a list of all matching items <code>next</code> will simply return the first item from the generator passed to it:

MID

next(player for player in organization.players if player in other_org.players).stats


Just in case <code>other_org.players</code> is huge and all items in both lists are <code>hashable</code> then better convert <code>other_org.players</code> to a set first to support fast lookups:

other_org_set = set(other_org.players)
next(player for player in organization.players if player in other_org_set).stats


Note that both solutions above assume there's always at least one such maching items, if that's not the case then better return a sentinel value(usually <code>None</code> and <code>object()</code> are used) from <code>next</code> and then try to access <code>pror</code> based on the return value from <code>next</code>:

matching_player = next((player for player in organization.players if player in other_org.players), None)
if matching_player is not None:
    return BaseballCard(matching_player.stats)


POST

SUBMITTED

key + '="' + parameters[key] + '", ';
    });
    oauthString += 'oauth_signature="' + encodedSignature + '"';

    var action = httpType == "https" ? https : http

PRE

Not sure exactly why the ternary operator is being used here but the <code>||</code> operator can be used to default values a little cleaner

MID

var action = httpType == "https" ? https : http;


vs

var action = httpType || http;


POST

SUBMITTED

out.print("]");
    }

  public static void FindMissing(){
    int []finalArray = {1,2,3,4,5,7,8,9,10};
    int len = finalArray.length; //First, I took the length of the array.
    int sum = 0;
      for(int

PRE

When you comment your code, you should explain why you wrote what you did write, not what you wrote. I mean, 

MID

int len = finalArray.length; //First, I took the length of the array.


POST

is pretty obvious, so the comment isn't neccessary. I think it is the same for all your comments, except the third. But what I need to understand, as a developper who reads your code, isn't that you used a formula to get the total, but to understand how your formula works so you can get the total.

Both your methods use the same <code>int[]</code>, which makes me think it should be a parameter of both your methods, this way you can be sure they will never be different.

SUBMITTED

threads - 1; ++i) {
                counters[i].join();
            }
        } catch (final InterruptedException ie) {
            ie.printStackTrace();
            return;
        }

        final int

PRE

These seem arbitrary. THREAD_THRESHOLD is perhaps "infinite" with a sanity check, that's fine. But MERGESORT_THRESHOLD seems like it wants an accompanying comment, a reference that describes how some benchmark fared worse with higher or lower thresholds. I'm especially concerned that the optimal threshold would be sensitive to cache size, and no guidance is offered on how to compare the system I'm running on today with the historic benchmark system.

A broader observation is that there's no guidance offered for how, on data of interest, this sort stacks up against the competition, such as in <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html" rel="nofollow noreferrer">https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html</a> .

Rather than using Runtime.getRuntime().availableProcessors(), consider assigning that (as default value) to some config parameter. This offers control to a caller that already has some busy BG threads.

The final loops in areEqual() are fairly pedestrian. Even though modern JITs can do wonders, it seems like Arrays or some other module should offer direct access to memcmp(), since we just need to know if every bit of src matches the bits of dst. I have a concern about whether the current approach of iterating first over array items, then over arrays, would be as cache friendly as the order memcmp() would use. Benching it both ways would be instructive.

ParallelSortImpl might break out helpers to explicitly name each of the three phases. In three places it attempts <code>.join()</code> and then:

MID

    } catch (final InterruptedException ie) {
        ie.printStackTrace();
        return;
    }


POST

It seems likely this allows corrupted (unsorted) results to be passed back to callers. Consider, at a minimum, setting a dirty flag in the handler. Then top-level return to caller can consult flag, do final linear pass to check that all is sorted, and raise exception if not. Or, simply re-throw <code>ie</code> as a RuntimeException if this is a "can't happen" clause that you wrote just to keep the compiler happy about checked exceptions.

SUBMITTED

false

PRE

MID

false

POST

Let consumers handle exceptions:

SUBMITTED

Function
    */
    public function generatePasteID()
    {
        $finalString = "";
        $genRand = $this-&gt;generateRandom();
        do
        {
            $finalString = $this-&gt;generateRandom();
        } while($this-&gt;pasteExists

PRE

Initialize a variable with the value before the loop and then just use the variable in the loop.  

MID

        $finalString = $this-&gt;generateRandom();
    } while($this-&gt;pasteExists($genRand));


POST

A more common way to do this is to have an auto-increment ID column and use a cryptographic function to obfuscate it.  Then you are guaranteed uniqueness by the database and don't have to do anything as heavyweight as this.   

SUBMITTED

template&lt;typename T&gt;
class Ptr {
public:
    Ptr(T* t, int s = 1) : sz{s&lt;1 ? throw std::logic_error("Invalid sz parameter") : s} {
        sz = s;
        p = new T[sz];
        std::copy(t,t+sz,p);
    }

    Ptr(const Ptr&amp; t) : Ptr(t.p, t.sz) { }

    Ptr&amp; operator=(Ptr copy) {
        std::swap(copy.sz, sz);
        std::swap(copy.p, p

PRE

MID

Ptr(T* t, int s = 1): sz{s&lt;1 ? throw std::logic_error("Invalid sz parameter") : s}
{
    sz = s; //this is unnecessary
    p = new T[sz];
    std::copy(t,t+sz,p);
}


Here you are writing to <code>sz</code> twice, first in the initializer list then in the constructors body. In general it's best if you just write only once in the initializer list if possible:

Ptr(T* t, int s = 1):
    sz{s&lt;1 ? throw std::logic_error("Invalid sz parameter") : s}
{
    p = new T[sz];
    std::copy(t,t+sz,p);
}


In the move constructor:

Ptr(Ptr &amp;&amp;t):
    p{t.p},
    sz{t.sz}
{
    t.p = nullptr;
    t.sz = 0;
}


we are changing the pointer and size in this class but not the index. I would "move" everything and take the index from the other class here as well.
We need to set <code>t.p</code> to <code>nullptr</code> so when <code>t</code> gets destructed the the call to <code>delete[] p;</code> will be a no-op, so that part is necessary. However I don't see why the <code>sz</code> needs to be set to 0 because it's a primitive and therefore not in the destructor. Because the range checking function always checks <code>p</code> for a <code>nullptr</code> we can't index the old object anyway so I think I would just remove that expression.

Ptr(Ptr &amp;&amp;t):
    p{t.p},
    sz{t.sz},
    index{t.index}
{
    t.p = nullptr;
}


POST

(Disclaimer: I'm not especially experienced with c++ move semantics so if you think it's more readable to keep explicitly setting every element to a "null" type of value for readability please make a comment, I'd like to know what people think about that.)

SUBMITTED

session.Dispose

PRE

There are a couple things you may want to address with your <code>IDispoable</code> implementation:

MID

Dispose

POST

The first one is pretty easy:

SUBMITTED

sparsemat *create

PRE

A few things immediately stand out to me:

MID

create()

POST

SUBMITTED

int i = 0; i &lt; buf.length; i++) {
        double angle = i / (SAMPLING_FREQUENCY_IN_HZ / hz) * 2 * Math.PI

PRE

In a sense, your math is wrong.  In

MID

double angle = i / (SAMPLING_FREQUENCY_IN_HZ / hz) * 2 * Math.PI;


… both of the divisions are done using integer arithmetic.  As a result, I get nothing more than a clicking noise.  To get the intended signal, you have to cast <code>i</code> to a <code>double</code>.  Better yet, write it instead as

double angle = 2 * Math.PI * i * hz / SAMPLING_FREQUENCY_IN_HZ;


By the <a href="http://en.wikipedia.org/wiki/Sampling_theorem">Nyquist criterion</a>, a sample rate of 8000 Hz means that you can play a frequency no higher than 4000 Hz.  Therefore, for robustness, you should do one of three things:

hz &gt;= SAMPLING_FREQUENCY_IN_HZ / 2

POST

SUBMITTED

tpsstopwatch = new Stopwatch();
        int tpscount = 0;
        //---------------------------------------------------
        static void Main(string[] args

PRE

Are these variables used outside of your main class? If no, than these should be private. Everything should be the least accessible as possible, for clarity and encapsulation reasons.

MID

static void Main(string[] args)


Same here, for clarity it should be public.

void Server()


POST

That's a bad name for a function, even the simple <code>Run()</code> would have been a better choice.

SUBMITTED

lt; beginning)
        return array;

    int pivot = (array[beginning] + array[end]) / 2;
    int firstUnknown

PRE

Your pivot could overflow:

MID

int pivot = (array[beginning] + array[end]) / 2;


Here, pivot could become negative if the two values added together overflowed an <code>int</code>.  You could use a <code>long</code> to do the averaging, but I suggest just picking a pivot like this:

int pivot = array[beginning];


POST

SUBMITTED

in cell in column A
            f = folder + str(cell.Value) + '.txt'
            #embed

PRE

since <code>0 == False</code> in Python. I suggest doing so since it makes the action self-explanatory.

This could be better with formatting:

MID

f = folder + str(cell.Value) + '.txt'


to

f = "%s%s.txt" % (folder, cell.Value)


or moving to new-style formatting (this would change your other format) with

f = "{}{}.txt".format(folder, cell.Value)


POST

The name <code>f</code> should also be improved to, say, <code>filename</code>. Same with <code>ol</code> (I chose <code>ole_obj</code>).

Now in <code>rename_file</code>, remove dead comments like

SUBMITTED

public interface INotificationCenter
{
    ISubscriptionHandler Subscribe&lt;T&gt;() where T

PRE

MID

ISubscriptionHandler Subscribe&lt;T&gt;()


I think this is a confusing interface. I would expect something along the lines of:

ISubscription Subscribe&lt;T&gt;(ISubscriptionHandler&lt;T&gt; handler)


where <code>ISubscriptionHandler&lt;T&gt;</code> would contain any predicates and code that should be dispatched when a message arrives and <code>ISubscription</code> can be used to unsubscribe.

Why is <code>ChatCenter</code> a singleton? This is especially weird since you're using unit tests, which should be independent.

/// &lt;typeparam name="T"&gt;&lt;/typeparam&gt;
/// &lt;returns&gt;&lt;/returns&gt;


If you don't want to add documentation comments for everything, that's fine. But there is no reason to have empty comments like these cluttering up your code.

You already realized that you need to separate the non-generic <code>ISubscriptionHandler</code> and the generic <code>ISubscriptionProcessor&lt;TMessage&gt;</code>. But since you already have that, you should use the generic version as much as possible and use the non-generic version only when necessary (pretty much just around the <code>Dictionary</code>).

This would mean you could get rid of the <code>IMessage.Dispatch()</code> step and for example the core of <code>ChatCenter.Publish()</code> could look like this (explicitly typing the iteration variable of a <code>foreach</code> works as a cast):

foreach (ISubscriptionProcessor&lt;T&gt; handler in listeners[typeof(T)])
{
    handler.ProcessMessage(message);
}


POST

SUBMITTED

clrscr();
    int ih,im,fh,fm,e,a,b;
    cout&lt;&lt

PRE

This is good:

MID

a=ih*60+im;
b=fh*60+fm;


Not sure what you are doing here:

e=abs(((780+a)/(781+b))*720-abs(a-b));


POST

What are the 780/781/720 constants doing? If you remove all the extra stuff it should just work

SUBMITTED

lt; xmlFiles[i].lastModified()) {
                                        lastModifiedFile = xmlFiles[i];
                                    }
                                }
                                try {
                                    if (!lastModifiedFile.getName().contains("processes")) {
                                        if (!lastModifiedFile.getName().contains("draft")) {
                                            br = new

PRE

As for the directory traversal, what I can briefly suggest is to use a combination of <a href="http://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html#newDirectoryStream%28java.nio.file.Path,%20java.nio.file.DirectoryStream.Filter%29" rel="nofollow noreferrer"><code>Files.newDirectoryStream</code></a> and <a href="http://docs.oracle.com/javase/7/docs/api/java/nio/file/DirectoryStream.Filter.html" rel="nofollow noreferrer"><code>DirectoryStream.Filter</code></a> to help you filter directories and files. Your current way of checking:

MID

!lastModifiedFile.getName().contains("processes") &amp;&amp; 
    !lastModifiedFile.getName().contains("draft")


POST

Will fail for paths like <code>...\draft.txt</code> or <code>...\processes.pdf</code>. Of course, if you know for sure that you will not have these cases...

<strong>Java: Be all, end all?</strong>

Do you really need a Java application for this? If your target OS is <code>*nix</code>, you can pretty much achieve the same thing with shell scripts, using a combination of <code>find</code> and <code>grep</code> for example. And that's off the top of my head...

SUBMITTED

template &lt;class T, class Q&gt;
vector &lt;T&gt; operator*(const Q c, const vector&lt;T&gt; &amp;A) {

  vector &lt;T&gt; R(A.size());
  std::transform(A.begin(), A.end(), R.begin(),
                 std::bind1st(std::multiplies&lt;T&gt;(),c));
  return R

PRE

For simplicity, let's say variable <code>v2</code> is located at address 0x10.
When you do <code>3 * v1</code>, you are calling your function. 

<code>R</code> would then be created at let's say address 0x20. When your function returns, the contents of <code>R</code> would have to be copied from 0x20 to <code>v2</code> at 0x10 and then the destructor for <code>R</code> would have to be called. Without copy elision, this would require copying every element from <code>R</code> into <code>v2</code>. 

Now in C++11, there is something called <a href="https://stackoverflow.com/questions/3106110/what-is-move-semantics">move semantics</a>. This means, that without copy elision, <code>R</code> would not have to copy every element into <code>v2</code>, it could swap pointers. This is much faster, but it is still slower than copy elision. 

With copy elision, instead of creating <code>R</code> at 0x20, it uses address 0x10 and builds <code>v2</code> in place. With copy elision, nothing has to be copied and no pointers have to be swapped because <code>v2</code> is built in place.

Here's how I would re-write the function:

MID

template &lt;class T, class Q&gt;
std::vector &lt;T&gt; operator* (const Q c, std::vector &lt;T&gt; A)
{
    std::transform (A.begin (), A.end (), A.begin (),
                 std::bind1st (std::multiplies &lt;T&gt; () , c)) ;
    return A ;
}


POST

<strong>2. If you have to use an index-loop for some reason, rather than a range-loop or iterators, make sure you are comparing compatible types.</strong>

You could do something like this:

SUBMITTED

int main

PRE

MID

main

POST

The compiler will automatically generate the equivalent to <code>return 0</code> for code that successfully gets to the end of <code>main</code>.

SUBMITTED

ProcessMessage(TMessage message)
    {
        if (this.condition == null)
        {
            this.callback(message, this);
            return;
        }

        if (!this.condition(message))
        {
            return;
        }

        this.callback(message, this);
    }

    protected virtual void OnUnsubscribing()
    {
        var handler = this.Unsubscribing;
        if (handler == null)
        {
            return;
        }

        handler(new NotificationArgs

PRE

How is <code>GetContent()</code> (both versions) useful? The non-generic <code>IMessage</code> could be just a marker interface, with no methods.

I'm not even sure about the usefulness of <code>Content</code>, since it seems it doesn't contain all the content of the message. E.g. treating <code>WhisperMessage</code> as a <code>IMessage&lt;string&gt;</code> won't give you everything.

MID

if (this.condition == null)
{
    this.callback(message, this);
    return;
}

if (!this.condition(message))
{
    return;
}

this.callback(message, this);


This is unnecessarily complicated, you could simplify it to:

if (this.condition == null || this.condition(message))
{
    this.callback(message, this);
}


POST

SUBMITTED

tictactoe.Game

PRE

MID

Game

POST

SUBMITTED

int j

PRE

MID

j

POST

SUBMITTED

VGAP = 3;

    public static final int NUMBER_OF_CELLS = ROWS * COLS;

    private JFrame frame;
    private List&lt;Cell&gt; buttons = new ArrayList&lt;&gt;();
    private List&lt;Cell&gt; correct = new ArrayList&lt;&gt;();
    private Cell emptyButton;

    private int movesCounter;

    /**
     * Constructor for objects of class GUI
     */
    public GUI ()
    {
        frame = new JFrame("Slide Game");

        frame.setDefaultCloseOperation

PRE

It's a bit of extra work, but I think it's worth it.

Instead of <code>checkNeighbour</code>, a more common way to name a method that returns a boolean is to replace "check" with "is". 
This will intuitively distinguish it from other methods that check something without returning a value, such as <code>checkVictory</code>.

Make <code>final</code> member variables as much as possible. For example these in <code>GUI</code>:

MID

private final JFrame frame;
private final List&lt;Cell&gt; buttons = new ArrayList&lt;&gt;();
private final List&lt;Cell&gt; correct = new ArrayList&lt;&gt;();


POST

And these in <code>Cell</code>:

SUBMITTED

php if

PRE

MID

if

POST

SUBMITTED

z0-9-._~+]|%[A-Fa-f0

PRE

MID

[A-Fa-f0-9]

POST

SUBMITTED

currentNum += reverse

PRE

MID

reverse

POST

As mentioned above,
the simple but lazy implementation breaks on negative numbers.
It also breaks on numbers that cause integer overflow when reversed.
And like with <code>isPalindromic</code>,
the logic is wasteful.
It would be better to implement this too using basic math logic:

SUBMITTED

BackgroundTaskRunner taskRunner
 *         = new BackgroundTaskRunner("myapp-%d", SwingUtilities::invokeLater);
 *
 *     // ...
 *
 *     taskRunner.run(
 *         () -&gt; { my(); background(); task(); here(); },
 *         () -&gt; { postponed(); ui(); update(); here(); }
 *     );
 * &lt;/pre&gt;
 *
 * &lt;p&gt;You can also bind a frontend task to consume a value produced by the given
 * backgound task; for instance, if you have two methods:&lt;/p&gt;
 *
 * &lt;pre&gt;
 *     public Foo backgroundProducer()
 *     {
 *         // procude a Foo
 *     }
 *
 *     public void frontendConsumer(final Foo foo)
 *     {
 *         // consume a Foo
 *     }
 * &lt;/pre&gt;
 *
 * &lt;p&gt;you will then be able to invoke:&lt;/p&gt;
 *
 * &lt;pre&gt;
 *     taskRunner.compute(
 *         () -&gt; this::backgroundProducer,
 *         () -&gt; this::frontendConsumer
 *     );
 * &lt;/pre&gt;
 *
 * &lt;p&gt;Those are the two basic mechanisms. Three variants of each of these exist:
 * &lt;/p&gt;
 *
 * &lt;ul&gt;
 *     &lt;li&gt;a variant

PRE

That's some tasty looking code.

I don't think I'm going to be able to find anything wrong with the implementation.

There's something to be said about the documentation, though...

MID

/** &lt;p&gt;You can also bind a frontend task to consume a value produced by the given
 * backgound task; for instance, if you have two methods:&lt;/p&gt;
 *
 * &lt;pre&gt;
 *     public Foo backgroundProducer()
 *     {
 *         // procude a Foo
 *     }
 *
 *     public void frontendConsumer(final Foo foo)
 *     {
 *         // consume a Foo
 *     }
 * &lt;/pre&gt;
 *
 * &lt;p&gt;you will then be able to invoke:&lt;/p&gt; */


POST

"backgound task", "procude a Foo", lower-case y for "you will then be able to invoke"

... and that's that it's also pretty good, save for those few typo's.

If there's one thing you could do to improve the code, I think it would be providing error messages for <code>Objects.requireNotNull</code>. 

Here's an exception thrown from <code>Objects.requireNonNull(null)</code>:

SUBMITTED

de $e
        catch(PDOException $e)
        {
            return $e-&gt;getMessage();
        }
    }

    //$values verwacht $_POST waardes dus

PRE

From the off, let me be clear about this: <code>PDO</code> offers a clean, concise and fully OO API. To attempt to extend, or in your case wrap it into something that is, somehow <em>better</em> is <strong><em>Impossiburu!</em></strong> I've been <a href="https://codereview.stackexchange.com/a/29394/16133">quite vocal about this</a> in many of my previous <code>PDO</code> related reviews.

Of course, <code>PDO</code> is, even in my projects, often hidden away, tucked into some connection manager or abstraction layer of sorts. But that layer does so much more than your class does. And it certainly does a lot more than any given class can or indeed should do. For that reason ORM's and DBAL's like Propel or Doctrine exist, and are in common usage. Don't make the mistake of building your own, by yourself from scratch. By the time you get it close to something that could be considered a stable release, the existing open-source projects will have surpassed anything you can build many times over. If for no other reason than the simple fact that these projects are being actively developed by a multitude of developers. You simply can't compete with that by yourself.

Your <code>Database</code> constructor contains a really ugly <em>"faux-pas"</em> in the <code>catch</code> block. You're catching a possible <code>PDOException</code>that might have been thrown and try to return its message (A string) from the constructor. That's not possible. Can't be done. What will happen is you'll end up with an instance of the class as though the constructor hasn't been called. IE: all of the properties that the constructor <em>should've</em> initialized will still be <code>null</code>.<br>
In short remove this bit:

MID

catch (PDOException $e)
{
    return $e-&gt;getMessage();
}


What you should do is <strong><em>not catch the exception</em></strong>. Think about it: your class needs the DB connection to do its job. If something in the constructor (which creates the <code>PDO</code> instance, and sets it up for future use) went awry, the class can no longer safely do its job, and so the user (code that creates the instance) <em>must</em> be notified that an <strong>exceptional</strong> error has occurred. That's the whole point of exceptions, and that's exactly why they keep propagating through the call-stack right up to the point where they're either caught, or handled by an exception handler, or they cause the application to halt.

If the DB connection is not critical, the code that creates the <code>Database</code> instance might have an alternative at the ready, in which case, that code might look like this:

try {
    $db = new Database();
} catch (PDOException $e) {
    $logger-&gt;log(
        sprintf(
            'DB error: %s - switching to mongodb (or whatever)',
            $e-&gt;getMessage()
        )
    );
    $db = new MongoClient();//or some other class
}


POST

Of course, it's far more likely that a DB connection in a PHP app is vital, but a class shoudln't assume that it's critical to the application in which it is being used. That's entirely up to you, the programmer.

SUBMITTED

resetBoard(){
        for(int i = 0; i &lt; size; i++)
            board[i

PRE

So for all three examples:

MID

for (int i = startPosition; i &lt; size ; i += n) {  

}  


POST

<strong>The diagonal check(s)</strong>  

Here the starting positions are clear. It is the upper left corner so <code>0</code> and the upper right corner so <code>n - 1</code>.  

If we loop from the upper left to the lower right, the last position to check is <code>size -1</code>.  

If we loop from the upper right to the lower left, the last position to check is <code>size - n</code>.

Let us use new samples for getting the value of which we need to increment the iterating variable.  

n == 3

SUBMITTED

double APP_VERSION

PRE

Some quick remarks:

MID

APP_VERSION

POST

SUBMITTED

EXISTS `users

PRE

MID

users

POST

SUBMITTED

h1{
    font-size:3em;
    text-align

PRE

<strong>Validity</strong>

You can <a href="https://jigsaw.w3.org/css-validator" rel="nofollow">validate your CSS</a> here. It found no formal issues with your CSS code at all. Congrats :)

<strong>Formatting</strong>

MID

font-size:3em;

POST

<strong>Misc</strong>

SUBMITTED

FGSingleton.sharedInstance().displayGameScore

PRE

And call it like this:

MID

FGSingleton.sharedInstance.displayGameScore()


POST

SUBMITTED

ProccesBigFiles();
            }
            else
            {
                return;
                throw new FileNotFoundException("No more file to procces found

PRE

MID

return;
throw new FileNotFoundException("No more file to procces found");


POST

The second line here is unreachable, and should trigger a warning from your  compiler.

SUBMITTED

public myClassFromXsd excelToMyClassFromXsd(String excelFile)
            {
                Excel.Application excelApp = new Excel

PRE

The indendation looks off - assuming it's not a paste glitch with tabs vs spaces, the scope-opening brace should line up with the method's signature:

MID

public myClassFromXsd excelToMyClassFromXsd(String excelFile)
            {


Like this:

public myClassFromXsd excelToMyClassFromXsd(String excelFile)
{


Also, C# type names should be <code>PascalCase</code>, as well as any public members: 

myClassFromXsd

POST

SUBMITTED

catch (Exception

PRE

There's two things wrong here really.

MID

Exception

Exception

POST

SUBMITTED

data-id="1" data-amount

PRE

It certainly seems like there's too much going on. If I understand correctly, clicking a checkbox does 2 things:

MID

data-amount

POST

However this can be redefined as just one task:

Here's a snippet, which uses that approach.

<div class="snippet" data-lang="js" data-hide="true">
<div class="snippet-code snippet-currently-hidden">
<pre class="snippet-code-js lang-js prettyprint-override"><code>$(function () { // shorthand for $(document).ready()

  // get all checkboxes
  var allCheckboxes = $(".perk:checkbox");
  
  // group them by name for later
  var groups = {};
  allCheckboxes.each(function () {
    groups[this.name] || (groups[this.name] = []);
    groups[this.name].push(this);
  });
  
  // hook up event handling
  allCheckboxes.on("change", function (event) {
    // reset all checkboxes (easier than having to reset)
    allCheckboxes.each(function () { this.checked = false });
    
    // get the clicked checkbox and its amount
    var selected = $(this).prop("checked", true);
    var amount = selected.data("amount");
    
    // process each group of checkboxes
    for(var name in groups) {
      if(!groups.hasOwnProperty(name)) { continue }
      
      var group = $(groups[name]);
      
      // get those checkboxes in the group that have an equal or lower amount
      var matching = group.filter(function () {
        return $(this).data("amount") &lt;= amount;
      });
      
      // get the maximum within that
      var amounts = matching.map(function () {
        return $(this).data("amount");
      }).get();
      
      var maxAmount = Math.max.apply(null, amounts);
      
      // now check those that have that amount
      group.filter("[data-amount='" + maxAmount + "']").prop("checked", true);
    }
  });
});</code></pre>
<pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"&gt;&lt;/script&gt;

Group1:&lt;br&gt;
&lt;input class="perk" name="perks[]" type="checkbox" data-amount="5"&gt;$ 5&lt;br&gt;
&lt;input class="perk" name="perks[]" type="checkbox" data-amount="5"&gt;$ 5&lt;br&gt;
&lt;input class="perk" name="perks[]" type="checkbox" data-amount="10"&gt;$ 10&lt;br&gt;
&lt;input class="perk" name="perks[]" type="checkbox" data-amount="17"&gt;$ 17&lt;br&gt;
&lt;input class="perk" name="perks[]" type="checkbox" data-amount="25"&gt;$ 25&lt;br&gt;
&lt;input class="perk" name="perks[]" type="checkbox" data-amount="49"&gt;$ 49&lt;br&gt;
    
&lt;br&gt;
        
Group 2:&lt;br&gt;
&lt;input class="perk" name="perks_admin[]" type="checkbox" data-amount="10"&gt;$ 10&lt;br&gt;
&lt;input class="perk" name="perks_admin[]" type="checkbox" data-amount="15"&gt;$ 15&lt;br&gt;
&lt;input class="perk" name="perks_admin[]" type="checkbox" data-amount="15"&gt;$ 15&lt;br&gt;
&lt;input class="perk" name="perks_admin[]" type="checkbox" data-amount="25"&gt;$ 25&lt;br&gt;
&lt;input class="perk" name="perks_admin[]" type="checkbox" data-amount="50"&gt;$ 50&lt;br&gt;
&lt;input class="perk" name="perks_admin[]" type="checkbox" data-amount="100"&gt;$ 100&lt;br&gt;</code></pre>
</div>
</div>


I've simplified the HTML; since the <code>name</code> attributes already divide the checkboxes into different groups, there's little need for the <code>all_perks</code>/<code>admin_perks</code>. Instead <em>all</em> checkboxes simply share a basic <code>perk</code> class, and are then grouped by their <code>name</code>.

I've also skipped disabling the checkboxes, but that's simple to add.

SUBMITTED

int&gt;&amp; s) {
    static const int coin

PRE

The input is described as a desired sum, S, and a list of coin values, V1..VN.  So I would expect a <code>vector</code> named <code>v</code> to refer to that input value.  However, in this case, <code>v</code> holds an intermediate result and <code>s</code> holds the coin values.  The desired value is in <code>n</code>.  It would be reasonable to use the same names as in the problem statement.  Normally if you change them, you'd change them to be more descriptive, e.g. <code>desired_sum</code> and <code>coin_values</code>.  

What is a <code>coins_td</code>?  I've been looking at this problem for some time now, and I still have no idea.  It's possible that I'm just being slow, but this suggests to me that it is a non-descriptive name.  Writing it out rather than abbreviating might help.  

MID

    static const int coin = 1;


POST

While it's good that you're trying to avoid magic numbers in your code, this is a bit confusing.  What is <code>coin</code> and why does it equal <code>1</code>?  I actually think that using the value <code>1</code> is more obvious about what is happening in this case.  

SUBMITTED

public delegate void DebugTimerHandler(ITimer sender, String TimerName);

/// &lt;summary&gt;
/// Allows for Debug-Mode timing

PRE

this  

MID

public delegate void DebugTimerHandler(ITimer sender, String TimerName);  


should be   

public delegate void DebugTimerHandler(ITimer sender, String timerName);  


Propertynames shouldn't start with an underscore <code>_</code> either. This should be used for classmember variables only. One would either use <code>_someVariable</code>, <code>mSomeVariable</code> or just <code>someVariable</code> for a classmember variable, but always <code>SomeVariable</code> for a property name.  

Sometimes you are using <code>this.</code> to refer to a class property, sometimes you aren't. You should stick to one style and not mixing them.  

Using private properties (getter and setter are private) is only adding noise to the code. There isn't a real benefit of using them if you hadn't some validation logic etc. in the setter.   

public void StartTimer(String Timer)
{
    if (DebugMode)
    {
        Timer timer = new Timer(Timer);


POST

this just smells. Using a variable name which is the same as an existing,used class.  

Commented code like <code>//throw new Exception(String.Format("DebugTimer...</code> is dead code which only adds noise and should be deleted.  

By adding a guard clause like  

SUBMITTED

nrows*Input.nrows):
        x = []
        for j in List[i]:
            x.append(j)
        dic[i] = x

    # sort
    a = []
    for i in dic.values():
        a.append(i)

    # collect number of mutations in data files
    import csv
    null = []
    one = []
    two = []
    three = []
    four = []
    five = []
    six = []
    seven = []
    eight = []
    nine = []
    ten = []
    for i in range(Input.nrows*Input.nrows):
        if len(a[i]) &lt;= 4:
            null.append(a[i])
            with open("no_mut.csv", "w", newline="") as f:
                writer = csv.writer(f)
                writer.writerows(null)
        elif len(a[i]) == 5:
            one.append(a[i])
            with open("one.csv", "w", newline="") as f:
                writer = csv.writer(f)
                writer.writerows(one)
        elif len(a[i]) == 6:
            two.append(a[i])
            with open("two.csv", "w", newline="") as f:
                writer = csv.writer(f)
                writer.writerows(two)
        elif

PRE

This of course is a complete mess:

MID

null = []
one = []
two = []
# ...
for i in range(Input.nrows*Input.nrows):
    if len(a[i]) &lt;= 4:
        null.append(a[i])
        with open("no_mut.csv", "w", newline="") as f:
            writer = csv.writer(f)
            writer.writerows(null)
    elif len(a[i]) == 5:
        one.append(a[i])
        with open("one.csv", "w", newline="") as f:
            writer = csv.writer(f)
            writer.writerows(one)
    elif len(a[i]) == 6:
        # ...


The code duplication might actually be the smaller of two big problems.
The biggest problem is that <em>each file is potentially rewritten multiple times</em>.
I don't know what kind of data you have,
but for example if you have 10 rows with <code>len(a[i]) == 5</code>,
then the file <code>one.csv</code> will be first written with 1 line, then rewritten with 2 lines, 3 lines, ..., in the end 10 lines.
This is crazy.
You should rework this to write each file only once.

Here's an <strong><em>untested</em></strong> approach that I think should work,
and solves both the multiple writing and the code duplication:

files = (
    (lambda length: length &lt;= 4, "no_mut.csv", []),
    (lambda length: length == 5, "one.csv", []),
    (lambda length: length == 6, "two.csv", []),
    (lambda length: length == 7, "three.csv", []),
    # ... and so on
)

for i in range(sheet.nrows * sheet.nrows):
    for matcher, _, rows in files:
        if matcher(a[i]):
            rows.append(a[i])
            break

for _, filename, rows in files:
    with open(filename, 'w', newline='') as fh:
        writer = csv.writer(fh)
        writer.writerows(rows)


POST

SUBMITTED

cnt=0
    #inc=0;    

    for gr in G_list:                
        for c in G_list:
            if (gt.isomorphism(gr,c)): 
                cnt+= 1                            
                print("iso")
        print ("graph:{} frequence:{} ".format(i,cnt

PRE

Printing to the terminal is slow, and I notice the second version has a <code>print</code> call in an inner loop where the first version has not:

MID

    for c in G_list:
        if (gt.isomorphism(gr,c)): 
            cnt+= 1                            
            print("iso")


POST

For more accurate timings

SUBMITTED

the 'data-' prefix to the input string
 * @param {string} key The objects key it currently iterating on.
 * @return {string} 
 */
window

PRE

I'm a little lost on the <code>prefixAndTrimProperties</code> function. In [Martin's] book he states that you only want the function to do one thing, and my function is doing two - at least.

It's true that a function should ideally only "do one thing". But what constitutes "one thing" is somewhat debatable. For instance, if you instead call your function <code>prepareProperties</code> then its "one thing" is to, well, prepare a properties object. That's an operation that counts as one thing in your context. Yes, it entails both trimming values <em>and</em> prefixing keys, but that's an implementation detail.

Am I splitting up my functions in a way that are more testable? For example, is it really necessary to just have a function like <code>hasDataAnalyticsTag</code> return <code>true</code> or <code>false</code>? How granular should I be getting? Is it overkill?

Probably a little overkill, yes. But I'm more concerned about its use - or lack thereof. In <code>parseDataAnalyticsTag</code> you <em>don't</em> use it, meaning you may get an exception: <code>element.attr('data-analyticstag').split('_')</code> will fail if the attribute doesn't exist, since <code>attr()</code> will returned <code>undefined</code>, which you can't split.

In fact, I'd say it'd be easier to simply call <code>parseDataAnalyticsTag</code> and have it return <code>null</code> or an empty object if there's no attribute to parse. Right now, you've split it into checking and parsing, but - as far as I can tell - you only need to check if you want to parse. And if you want to parse, you need to check. So that's "one thing".

So, how granular should it be? Enough to keep the code DRY. If you find yourself repeating something, extract it into a function. Conversely, combine dependent/sequential steps into a function, and call that "one thing".

By the way, there's a hint that you may be too diligent in splitting things up. The comments for <code>addPrefixToKey</code> say

MID

// @param {string} key The objects key it currently iterating on.


POST

Who said anything about an object? Or iteration? Or a key for that matter? The function just takes an argument - <em>any</em> argument, really - and prepends <code>"data-"</code> to it. That's it. Its name and comments indicate that it was intended for or extracted from a very specific context, but the function itself really doesn't care. But if its intended use-case is so specific, it probably shouldn't be a separate function at all.

As to the code itself:

You're exposing <em>all</em> your functions in the <code>window.analytics.utilities</code> object, though you seem to only use one: <code>setDataAttributes</code>. So that's your API; the rest is - viewed from the outside - implementation details.

I'm also not a big fan of the <code>parseDataAnalyticsTag</code> function. For one, its <code>@return</code> comment lies: The object does not contain <code>index</code>, <code>linktype</code> and <code>cmpgrp</code> properties - it contains <code>index</code>, <code>type</code> and <code>region</code>. Boo.

It's also fragile and fairly tricky to follow, despite its short length. As mentioned, you <em>assume</em> that the attribute exists when you call <code>split</code>, but after that, you also <em>assume</em> that there are at least 8 elements in the resulting array. And the use of <code>splice</code> instead of <code>slice</code> makes it hard to keep track of indices, and requires things to happen in the right order. I.e. the <code>region</code> value is actually index 7 - not 3 - in the original array, so it only works because you've used <code>splice</code>.

Lastly, <code>setDataAttributes</code> has side effects: You're modifying the <code>dataAttributes</code> object you're given. It's ok for the usage you've got right now, since you're not keeping a reference to the object on the caller's side, but it's icky nonetheless.

Suggestions:

I'd consider making this a jQuery plugin. You're depending on jQuery anyway.

Something like this, perhaps (note: incomplete implementation)

SUBMITTED

manipulating with

PRE

MID

with

POST

Something like this:

SUBMITTED

LinkedList::~LinkedList()
{
}

int LinkedList::get_count(){
    return count;
}

void LinkedList::AddNode(int _value

PRE

Instead of having <code>Node</code> use getters and setters, just make it a <code>struct</code> declared within the <code>private</code> section of <code>LinkedList</code>.  It won't need its own files, either.

All but one of your functions are in PascalCase.  Whether you choose that or camelCase, choose just one and maintain that.  This should be kept consistent.

When creating a new linked list, the head should first point to <code>NULL</code> (or <code>nullptr</code> in C++11) to indicate an empty list.  You're instead having the head point to a new node, so the list isn't really considered empty at the start.

You have an empty destructor, even though you allocate memory with <code>new</code>.  In order to prevent memory leaks, the destructor should use <code>delete</code> on each allocated <code>Node</code>.  This is typically done with a loop through the list.

Member functions that don't modify data members should be <code>const</code>.  This also prevents any accidental modifications to data members within these functions.

An example with your <code>get_count()</code> function:

MID

int LinkedList::get_count() const {
    return count;
}


POST

SUBMITTED

public int nextInt() {
  long oldState = state;
  state = oldState * MULTIPLIER + inc;
  int xorShifted = (int) (((oldState &gt;&gt;&gt; 18) ^ oldState) &gt;&gt;&gt; 27);
  int rot = (int) (oldState &gt;&gt;&gt; 59);
  return Integer.rotateRight(xorShifted, rot

PRE

I cannot see any functional issues when comparing the C code against the Java code. it would seem they should produce the same results given the same input. Of course, a logical course of action would be to write a test system for the code which wraps the C code in to a program which accepts a single seed value as an argument, and produces a stream of int values in 'network byte' order. You then pipe that stream in to a Java program which produces the same stream, and compares the results. I would actually set up a test where the Java program starts a sub-process for the C version, and runs it with many input seeds, including the logical edge-cases (0, 1, -1, Long.MAX_VALUE, Long.MinValue, and all seeds from -100 to +1000). For each run, compare the first 10,000 generated values.

That would give me some measure of confidence that the code is a faithful reproduction.

Like you, I believe the Java code is a fair reproduction, but, like you, I would want to check it again.

Now,about the code, you are doing unnecessary work. There is no need to store the oldState:

MID

public int nextInt() {
  long oldState = state;
  state = oldState * MULTIPLIER + inc;
  int xorShifted = (int) (((oldState &gt;&gt;&gt; 18) ^ oldState) &gt;&gt;&gt; 27);
  int rot = (int) (oldState &gt;&gt;&gt; 59);
  return Integer.rotateRight(xorShifted, rot);
}


That code can be reduced to:

public int nextInt() {
  int xorShifted = (int) (((state &gt;&gt;&gt; 18) ^ state) &gt;&gt;&gt; 27);
  int rot = (int) (state &gt;&gt;&gt; 59);
  state = state * MULTIPLIER + inc;
  return Integer.rotateRight(xorShifted, rot);
}


POST

Also, while your comments about the <code>&gt;&gt;&gt;</code> vs <code>&gt;&gt;</code> are accurate, and I prefer the use of <code>&gt;&gt;&gt;</code> here, you should also know that the only shift which has a significant impact (where using <code>&gt;&gt;&gt;</code> makes a difference vs. <code>&gt;&gt;</code>) is the part:

SUBMITTED

hash

PRE

MID

$hash

POST

SUBMITTED

a = getchar

PRE

MID

getchar()

POST

I don't recommend using <code>getchar()</code> to read one character at a time, since you are really interested more in lines.  However, if you do use <code>getchar()</code>, you might as well use it more effectively, by writing the string in reverse to begin with.

SUBMITTED

char * get_buffer

PRE

MID

get_buffer()

POST

SUBMITTED

password = NULL;
        }
        int userlen = (postusername?postusername:postuserinfo) - postprotocol;
        *username = malloc(sizeof(char

PRE

No need to do <code>return 0</code> at the end of <code>main</code>,
the compiler automatically adds that.

This line is too tightly packed:

MID

    int userlen = (postusername?postusername:postuserinfo) - postprotocol;


Use spaces around operators to make it more readable, like this:

    int userlen = (postusername ? postusername : postuserinfo) - postprotocol;


POST

Putting some of the above points together,
a Url Info abstract data type and a main method using it might look like this:

SUBMITTED

void subscribe(IEventListener&lt;Model, Publisher&gt; listener) {
        listeners.add(listener);
    }

    public void unsubscribe(IEventListener&lt;Model, Publisher&gt; listener) {
        listeners.remove(listener);
    }

    protected void publish(Publisher publisher, Model sender) {
        for(IEventListener&lt;Model, Publisher&gt; listener : listeners){
            listener.actionPerformed(publisher, sender);
        }
    }

    public abstract void publish(Model sender);
}

interface IEventListener&lt;Model, EventPublisher extends AEventPublisher&lt;Model, ?&gt;&gt; {
    public void actionPerformed(EventPublisher publisher, Model sender

PRE

Next up is how you handle publishing. The problem you're describing when you implemented your publish method is rooted in how you restricted yourself when starting directly with an abstract class, instead of taking yourself the room of creating an interface for a Publisher. Consider the following:

MID

public interface Publisher&lt;E&gt; {
    public void subscribe(IEventListener&lt;E, Publisher&lt;E&gt;&gt; listener);
    public void unsubscribe(IEventListener&lt;E, Publisher&lt;E&gt;&gt; listener);
    public void publish(E sender);
}


This greatly simplifies your generics declarations and nestings and additionally resolves the conflict you had internally.

If you'd sacrifice a little "flexibility" (which you problably won't need anyways, more later), you could even make your IEventListener much simpler and completely get rid of the second type-parameter you introduced. 

In general your solution seems overengineered for the problem. Which brings me to my next point.

In general your design is somewhat over the top. You try to keep flexibility and allow substitions (which is in principle a good thing) in places where it's overly complicating your source-code and detrimental to code-readability and hurtful to your actual flexibility.

You will never need a Listener, which can listen to multiple different model classes, and <strong>if against all odds</strong> you need it, an abstract class or interface to group these model-classes is the simplest call to make. You went too far in your idealistic approach to be "open to everything". This is something you should strive to do, but not at the cost of simplicity and effectiveness. 

This is true to both gamedevelopment and business applications.

In addition to that, gamedevelopment is a often heavily performance-reliant environment, and let me tell you, overcomplicated generics and backreferencing interfaces are not something to make the JVM run faster. 

I also have no idea why you'd <em>need</em> or want the Listener to obtain a reference to the publisher. From what I see with my nonexistant experience you could "directly" subscribe to your model, which would then pass a reference to itself to it's listener. But that makes the whole Model-circus in your code moot, and defeats the point of a separate Publisher (which I don't see in the first place).

In general, separating the Publisher from the "published" is somewhat overkill and most probably sign of an underlying design mistake. I can not imagine a situation where I'd have to get a reference to a Publisher, before publishing something. You're again: overly complicating a simple matter. 

You want to bring data from one end to another, depending on certain conditions. And there's already a <strong>lot</strong> of existing solutions (beginning with <code>Observable</code> and ending god knows where) in the Java world for that.

Which is also what makes this model somewhat problematic from a business perspective. The simplicity of existing solutions beats your idea easily. The practical use-case is from my point of view <strong>missing</strong>. 

Overall you reinvented the wheel, but not as wheel, but as a polygon. Your solution to "Get data from A to B on demand" suffers from clunkyness in use. It's a bumpy ride and I don't know how I'd make it better without landing at some place that's already polished for use.

When I reviewed your code I copied it to a local project in my IDE. A few changes and a little headscratching later I was at the state of code that follows.

From what your use-case seems to be, that should be completely sufficient:

public interface Publisher&lt;E&gt; {
    public void subscribe(IEventListener&lt;E&gt; listener);
    public void unsubscribe(IEventListener&lt;E&gt; listener);
    public void publish(E sender);
}


public interface IEventListener&lt;E&gt; {
    public void actionPerformed(Publisher&lt;E&gt; publisher, E sender);
}


public class DefaultEventPublisher&lt;Model&gt; implements Publisher&lt;Model&gt; {
    private final ArrayList&lt;IEventListener&lt;Model&gt;&gt; listeners = new ArrayList&lt;&gt;();

    @Override
    public void subscribe(IEventListener&lt;Model&gt; listener) {
        listeners.add(listener);
    }

    @Override
    public void unsubscribe(IEventListener&lt;Model&gt; listener) {
        listeners.remove(listener);
    }

    @Override
    public void publish(Model sender) {
        for (IEventListener listener : listeners) {
            listener.actionPerformed(this, sender);
        }
    }
}


POST

And since you also had an example of a usecase:

SUBMITTED

if(key != "block" and key != "username" and key != "setid" 
                                        and key != "setid_hash" and key != "predecessor"
                                        and key != "time_string" and key != "condition"):
                                            val[key]=val_2[key]
                                skipList.append(idx_2)


    for idx, val in enumerate(set_of_pk_values):
        if(idx not in skipList):
            newList.append(val)
    set_of_pk_values = newList
    print str(len(set_of_pk_values))
    timeEnd = datetime.datetime.now()
    print str(timeEnd - timeNow

PRE

The above loop occurs as the inner-most loop of both loops <code>1</code> and <code>2</code>. With each iteration you check that <code>key</code> isn't equivalent to 7 other possible key values. 6 of these key values occur in the data you've presented and the 7th (<code>condition</code>) doesn't. It should be more efficient to replace:

MID

for key in val_2.keys():
   if(key != &quot;block&quot; and key != &quot;username&quot; and key != &quot;setid&quot; 
      and key != &quot;setid_hash&quot; and key != &quot;predecessor&quot; 
      and key != &quot;time_string&quot; and key != &quot;condition&quot;):
           val[key]=val_2[key]


with:

# put this at the top of the test function 
x_keys = set(['block', 'username', 'setid', 'setid_hash', 'predecessor', 'time_string', 'condition'])
# ...
for key in set(val_2.keys()) - x_keys:
    val[key] = val_2[key]


POST

SUBMITTED

OP accordoDaListaNote

PRE

MID

accordoDaListaNote

POST

SUBMITTED

refreshScaleFactor(sf

PRE

MID

sf

POST

SUBMITTED

lt;int, Tree&lt;T&gt;&gt;();
    private Dictionary&lt;int, T&gt; TreeItems = new Dictionary&lt;int, T&gt

PRE

MID

private Dictionary&lt;int, T&gt; TreeItems = new Dictionary&lt;int, T&gt;();


private fields are <code>lowerCamelCase</code> or <code>_lowerCamelCase</code> with the latter receiving my (and most others') preference.

public Tree&lt;T&gt; AddDirectory(int key, T item, Tree&lt;T&gt; value)
{
    this.AddItem(key, item);

    if (TreeMenus.ContainsKey(key))
    {
        throw new ArgumentException("Tree already contains directory at that location.");
    }
    TreeMenus.Add(key, value);
    return this;
}


POST

Do you really want to insert the item when there might be argument exceptions possible? If you catch the exception, you will have a partially executed method; if you don't catch the exception your program will have crashed anyway.

What is the <code>key</code> exactly? It seems like it conveys an ordering position; name it as such. 

SUBMITTED

HttpPost]
public ActionResult GetNewData(FormCollection collection)
{
    Tuple&lt;List&lt;Models.Author&gt;, List&lt;Models.Book&gt;, List&lt;Models.Topic&gt;&gt; newData = GetAuthorBookTopic();

    foreach (Models.Author newAuthor in newData.Item1)
    {
        context.Authors.Add(newAuthor);
        context.SaveChanges();
    }
    foreach

PRE

You're not actually using the form so can't it be omitted? 

MID

Tuple&lt;List&lt;Models.Author&gt;, List&lt;Models.Book&gt;, List&lt;Models.Topic&gt;&gt; newData = GetAuthorBookTopic();


POST

99% of the time you think you need a Tuple, you don't. First look into whether this can be turned into 3 methods. If that isn't possible, return a simple object that holds these 3 collections as properties.

SUBMITTED

SQL query define in array
  $query = array(
  "SELECT  * FROM products   WHERE   rowno=1
   and   colno=1 and pageno=1 and  productLine like '$cat'",
   "SELECT  *  FROM   products  WHERE  rowno=1  and  colno=2
   and  pageno=1   and   productLine   like   '$cat'",
   "SELECT *  FROM  products WHERE rowno=1 and colno=3
    and pageno=1 and productLine like '$cat'",
   "SELECT * FROM products  WHERE rowno=2 and

PRE

<strong>Security</strong>

It's unclear where <code>$cat</code> comes from, but if it can possibly be user supplied (eg when it comes from a GET/POST request, or when it comes from the database where it might have been placed by a user), you should use <a href="http://php.net/manual/en/pdo.prepared-statements.php" rel="nofollow">prepared statements</a> to prevent SQL injection.

You should also not be using <code>mysql_*</code> as it's deprecated.

Also, you should always <a href="https://stackoverflow.com/questions/1996122/how-to-prevent-xss-with-html-php">prevent XSS</a> when echoing data that might be user supplied.

<strong>Queries in array</strong>

Your approach of using an array to handle the 9 queries whose results should be handled the same is ok, but it would be better if you extracted your foreach loop into a separate function and then called that function with the queries (or better yet their result). Doing it that way would increase readability and reusability of your code.

<strong>Reduce amount of queries</strong>

You could remove the amount of queries you use by using <code>or</code>, which should increase the performance of your code. So instead of asking 

MID

SELECT * FROM products WHERE rowno=1 and colno=1 and pageno=1 and productLine like '$cat'";
SELECT * FROM products WHERE rowno=1 and colno=2 and pageno=1 and productLine like '$cat'";


You could just ask

SELECT * FROM products WHERE ((rowno=1 and colno=2 and pageno=1) or (rowno=1 and colno=2 and pageno=1)) and productLine like '$cat'";


POST

This could be further simplified, and the other queries could be added as well, but honestly, I'm not quite sure if it wouldn't be easier to change your database schema. I'm not quite sure how it currently works though. 

<strong>Misc</strong>

SUBMITTED

def logger
    @logger ||= ActiveSupport::TaggedLogging.new(Logger.new(STDOUT))
  end

  def with_context(tags, msg)
    @logger.tagged(*tags) { @logger.info msg }
  end
end

class Provider
  def self.logger
    Vlogger.instance
  end

  def self.say_hello
    logger.with_context(["tag2"], "hello")
  end
end

v = Vlogger.instance
v.logger = ActiveSupport::TaggedLogging.new(Logger.new(STDOUT))
Worker.new(v).perform

PRE

You might be better off just using a module with some static methods, e.g.:

MID

module Vlogger
  class &lt;&lt; self
    def logger
      @logger ||= ActiveSupport::TaggedLogging.new(Logger.new(STDOUT))
    end

    def with_context(tags, message)
      logger.tagged(*tags) { logger.info message }
    end
  end
end


Add attribute access as needed.

Now you can simply call <code>Vlogger.with_context</code> directly when you need it without having to use <code>instance</code> or otherwise keeping a reference to things elsewhere.

class Worker
  def perform
    Vlogger.with_context(["tag1"], "Started work")
    Provider.say_hello
  end
end

class Provider
  def self.say_hello
    Vlogger.with_context(["tag2"], "hello")
  end
end


POST

It's an option, at least.

SUBMITTED

lt;/div&gt

PRE

MID

&lt;noscript&gt;

POST

I’ll come back to the HTML when I comment on the JS.

You can make some improvements here:

<strong>Comments:</strong> Your CSS needs more comments. (This is not just you: most CSS has very sparse commenting.) In particular, I’d suggest comments that:

<strong>Consolidate:</strong> You have lots of selectors with very similar attributes that differ in only a few ways. I’d put multiple selectors on the common rules, with distinct selectors for the few rules where they differ. Not only is this more compact, but it highlights the differences between them. 

For example, for the final pair of rules, write it as:

SUBMITTED

GC can collect objects
        private WeakReference ThisWeakReference = new WeakReference(this);

        public HelpersContainer

PRE

You haven't asked any specific questions, so here's a generic critique.

MID

private WeakReference ThisWeakReference = new WeakReference(this);


POST

I don't think this is going to solve whatever problem you want it to, at least the way you are using it here.  Circular references aren't a problem with garbage collection, the way they can be with reference counting management techniques.  The GC will see that the whole group is no longer reachable from a GC root and clean them all up.  Furthermore, this isn't the correct way to use a <code>WeakReference</code> - your objects all end up with regular references in the end.  What you would do is entirely replace

SUBMITTED

s.length();
        sa = pos = tmp = vector&lt;int&gt;(n);
        for (int i=0; i&lt;n; i++) sa[i] = i, pos[i] = s[i], tmp[i] = 0;
        for (gap = 1;; gap *= 2) {
            quickSort(sa, n

PRE

This should be <code>const string &amp; s</code> to avoid unnecessary copying of the <code>string</code>.

MID

for (int i=0; i&lt;n; i++) sa[i] = i, pos[i] = s[i], tmp[i] = 0;


The comma operator has a few legitimate uses, but this is not one of them. Coding it this way will lead to problems if you need to modify the loop body at all. The right way to do this is to make a multi-statement loop the usual way: curly braces surrounding multiple lines with one statement on each line.

 for (int i=0; i&lt;n; i++)
 {
   sa[i] = i;
   pos[i] = s[i];
   tmp[i] = 0;
 }


POST

SUBMITTED

iii for

PRE

MID

for

POST

SUBMITTED

Controllers\User

PRE

<strong>Structure</strong>

MID

User

POST

SUBMITTED

public int[] shiftLeft(int[] nums) {
    for(int i = 0, start = 0; i &lt; nums.length; i++)
    {
        if(i == 0)
            start = nums[i];
        if(i == (nums.length -1))
        {
            nums[i] = start;
            break;
        }    
        nums[i] = nums[i + 1];
    }
    return nums

PRE

Your current solution is actually pretty good, conceptually. There's nothing wrong with the <code>start</code> variable. I am not sure why you want to remove it. The loop is logically a good solution, but there's a better way than that, though (better because you can make the system do it for you....).

MID

public int[] shiftLeft(int[] nums) {
    if (nums == null || nums.length &lt;= 1) {
        return nums;
    }
    int start = nums[0];
    System.arraycopy(nums, 1, nums, 0, nums.length - 1);
    nums[nums.length - 1] = start;
    return nums;
}


POST

Note that, in addition to using <code>System.arraycopy</code> I also check to see that the input has valid values available....

SUBMITTED

report();
        break

PRE

Doing so means that the variable is actually usefully initialized immediately at construction.  This is a desireable property of C++ class variables in particular because it removes the possibility of bugs by attempting to use a partially initialized object.  It's such a famous and well-known idea that it's got a name, which is <a href="http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization" rel="nofollow">Resource Acquisition Is Initialization</a> or RAII.

MID

break

POST

The <code>Main.cpp</code> file includes a <code>while(1)</code> as the main loop.  Somewhere within that monstrously large loop, the program either breaks out of the loop or exits.  Rather than forcing the reader of your program to go hunting for that (those?) statements, it's much better practice to put the loop exit condition at the top of the loop.  

The current <code>Student.cpp</code> contains this peculiar loop:

SUBMITTED

Population::getNeighborData

PRE

MID

getNeighborData

POST

SUBMITTED

return

PRE

The <code>code</code> variable in <code>compress</code> is not used.  Also, the <code>size</code> parameter is not used, but it should be.  I'd recommend eliminating <code>code</code> and <code>size</code>.  If you need the size, as for the <code>decompress</code> routine, you can simply use <code>input.size()</code>.

MID

return 0

POST

When a C++ program reaches the end of <code>main</code> the compiler will automatically generate code to return 0, so there is no reason to put <code>return 0;</code> explicitly at the end of <code>main</code>.

SUBMITTED

function splitForm() {


// Part 1 of the code. Set the variables and read load data.

// Control variables. Can be changed by user.
var done = 22; // In the source sheet, what column number is "Done". If A = 1, B = 2
var when = 23; // In the source sheet, what column number is "Date Moved". If A = 1, B = 2

// Sheet name variables. Can be changed if sheet names change.
var source = "Form responses"; //Name of the sheet with form responses
var hrSheet = "HR"; // Name of the sheet for HR responses
var itSheet = "IT"; // Name of the sheet for IT responses
var wfmSheet = "WFM"; // Name

PRE



MID

// Part 1 of the code. Set the variables and read load data.

// Control variables. Can be changed by user.
var done = 22; // In the source sheet, what column number is "Done". If A = 1, B = 2
var when = 23; // In the source sheet, what column number is "Date Moved". If A = 1, B = 2


POST

Rather than embed these column numbers as constants in code, you could calculate them using the column headers. You'd have to do that after you've read the sheet's values.

Doing this makes it easier to distribute your script to less-technical users, as it frees them to change the spreadsheet layout without needing to make matching changes in the script.

Something like:

SUBMITTED

tstring;
typedef std::wstring::npos tnpos;
#else
typedef std::string

PRE

MID

typedef std::wstring::npos tnpos;


POST

This should not be working. So I presume you have not tested this.

SUBMITTED

public List&lt;string&gt; Conversion(int x)
    {
        var bitConversion = new List&lt;string&gt;();
        var result = x;
        while (result &gt;= 0)
        {
            if (result == 0)
            {
                bitConversion.Add("0");
                break;
            }
            bitConversion.Add((result % 2).ToString(CultureInfo.InvariantCulture));
            result = result / 2;

        }
       bitConversion.Reverse();

       return bitConversion

PRE

where <code>int</code> is your supplied argument.

<a href="https://msdn.microsoft.com/en-us/library/14kwkz77(v=vs.110).aspx" rel="noreferrer">Convert.ToString Method (Int32, Int32)</a>

Converts the value of a 32-bit signed integer to its equivalent string representation in a specified base.

Note that this returns you a string value like <code>10000110100001</code>, which is the representation of a binary number. In your code you store them as string representations and in separate entries in your collection, which is not the way a number should be stored. It's like creating an array with values "1" and "2" to represent the number 12.

If this is your intention then you can always work towards that of course but it might be an indication that something else is wrong for needing it like that.

However if you want to stay with your own implementation, there are a few things you could change around:

MID

public List&lt;string&gt; Conversion2(int x)
{
   var bitConversion = new List&lt;string&gt;();
   while (x &gt;= 0)
   {
       if (x == 0)
       {
           bitConversion.Add("0");
           break;
       }
       bitConversion.Add((x % 2).ToString(CultureInfo.InvariantCulture));
       x /=  2;
   }
  bitConversion.Reverse();
  return bitConversion;
}


POST

SUBMITTED

override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning

PRE

MID

override func didReceiveMemoryWarning() {
    super.didReceiveMemoryWarning()
}


POST

If all your method does is call up to the super class's implementation of the method, you can safely omit the method entirely.  I understand this is boilerplate code that Xcode automatically inserts any time you create a new view controller, but at the end of the day, it's just clutter that should be cleaned up.

SUBMITTED

if ((principal == null || principal.getName() == null)) {
            boolean isValidInputData = true;
            if ((!reCaptchaBean.isValidCaptcha(recapchaResponse))) {
                model.addAttribute("captchaError", messageSource.getMessage("СaptchaError", null, LOCALE_RU));
                isValidInputData = false;
            }
            if (!validateAddParamsPageForDemoMode(campaignBeanDto, bindingResult)) {
                isValidInputData = false;
            }
            if (!isValidInputData) {
                model.addAttribute("useCampaignBeanDto", true);
                return createCompanyAddParams(principal, model, session

PRE

Let's translate that back into code:

MID

if (!reCaptchaBean.isValidCaptcha(recapchaResponse)) {
    model.addAttribute("captchaError", messageSource.getMessage("СaptchaError", null, LOCALE_RU));
}
if (!reCaptchaBean.isValidCaptcha(recapchaResponse) || !validateAddParamsPageForDemoMode(campaignBeanDto, bindingResult)) {
    model.addAttribute("useCampaignBeanDto", true);
    return createCompanyAddParams(principal, model, session);
}


But this contains double work, as we're validating the captcha twice.

So I'd suggest storing this in a boolean:

boolean captchaValid = reCaptchaBean.isValidCaptcha(recapchaResponse);
if (!captchaValid) {
    model.addAttribute("captchaError", messageSource.getMessage("СaptchaError", null, LOCALE_RU));
}
if (!captchaValid || !validateAddParamsPageForDemoMode(campaignBeanDto, bindingResult)) {
    model.addAttribute("useCampaignBeanDto", true);
    return createCompanyAddParams(principal, model, session);
}


Makes the end result look like this:

if (principal == null || principal.getName() == null) {
    boolean captchaValid = reCaptchaBean.isValidCaptcha(recapchaResponse);
    if (!captchaValid) {
        model.addAttribute("captchaError", messageSource.getMessage("СaptchaError", null, LOCALE_RU));
    }
    if (!captchaValid || !validateAddParamsPageForDemoMode(campaignBeanDto, bindingResult)) {
        model.addAttribute("useCampaignBeanDto", true);
        return createCompanyAddParams(principal, model, session);
    }
}


It's not much clearer though.

Also, in case you DO have side-effects from <code>validateAddParamsPageForDemoMode(campaignBeanDto, bindingResult)</code>, then this can be worked back in too:

if (principal == null || principal.getName() == null) {
    boolean captchaValid = reCaptchaBean.isValidCaptcha(recapchaResponse);
    if (!captchaValid) {
        model.addAttribute("captchaError", messageSource.getMessage("СaptchaError", null, LOCALE_RU));
    }
    if (!validateAddParamsPageForDemoMode(campaignBeanDto, bindingResult) || !captchaValid) {
        model.addAttribute("useCampaignBeanDto", true);
        return createCompanyAddParams(principal, model, session);
    }
}


POST

Like that, both validation functions will be called before <code>createCompanyAddParams</code>.

By recognizing the statement "If not conditionA or not conditionB, then controlA is false. If controlA is false, then functionB." to be "Only if not conditionA or not conditionB, controlA is false. If controlA is false, then functionB.", it becomes easier to see that there's no need for the control.

Only if <code>!cA || !cB</code>, controlA. If controlA, functionB. So if <code>!cA || !cB</code>, functionB.

This simplifying can only be done once you've removed the specifics of the code, as what specific code is executed is too much detail for pruning branches.

SUBMITTED

array
    String[] arr = new

PRE

Other smaller issues:

MID

String[] arr

for (String str : tokens) { ... }

POST

SUBMITTED

number * $padWidth + 2]
        setPin $name [expr $xRight-$xOffset] $y Top $index
    }
}
#---- Numbered pins at the right -------------------------------------
# The same for the right edge.
proc setNumberedRightPins {x yTop pins} {
    set padWidth 95
    foreach {number name index} $pins {
        set yOffset [expr max(0, $number * $padWidth - 2.5)]
        setPin $name $x [expr $yTop-$yOffset] Right $index
    }
}
#---- Numbered pins at the bottom ------------------------------------
# The same for the bottom edge.
proc setNumberedBottomPins {xRight y pins} {
    set padWidth 95
    foreach {number name index} $pins {
        set xOffset [expr $number * $padWidth + 2]
        setPin $name [expr $xRight-$xOffset] $y Bottom $index

PRE

I would suggest that since only 2 of the procs are close enough to identical, just "combine" those:

MID

set padWidth 95

proc setNumberedRightPins {x yTop pins} {
    foreach {number name index} $pins {
        set yOffset [expr {max(0, $number * $::padWidth - 2.5)}]
        setPin $name $x [expr {$yTop-$yOffset}] Right $index
    }
}

proc setNumberedTopPins {args} {
    setNumberedTopOrBottomPins {*}$args Top
}

proc setNumberedBottomPins {args} {
    setNumberedTopOrBottomPins {*}$args Bottom
}

proc setNumberedTopOrBottomPins {xRight y pins side} {
    foreach {number name index} $pins {
        set xOffset [expr {$number * $::padWidth + 2}]
        setPin $name [expr {$xRight-$xOffset}] $y $side $index
    }
}


POST

Notes:

SUBMITTED

public async void AddTemplate()
{
    IsBusy = true;

    await Task.Run(() =&gt; {
        using (var repo = new Repository())
        {
            var template = new Template() { ... };
            try
            {
                repo.Templates.Add(template);
                repo.SaveChanges();
                this.TryClose(true);
            }
            catch (SqlException ex)
            {
                _util.Log.AddException(Exceptions.DB_EXC, ex.Message);
            }
            catch (EntityException ex)
            {
                _util.Log.AddException(Exceptions.EF_EXC, ex.Message);
            }
            catch (Exception ex)
            {
                _util.Log.AddException(Exceptions

PRE

You should be able to await the <code>repo.SaveChangesAsync()</code> method.

MID

public async Task AddTemplateAsync()
{
    var template = new Template {...};

    using (var repo = new Repository())
    {
        try
        {
            IsBusy = true;
            repo.Templates.Add(template);
            await repo.SaveChangesAsync();
        }
        catch {...}
        finally
        {
            IsBusy = false;
            TryClose();
        }
    }
}


POST

Since <code>AddTemplate()</code> is an async method, it should be called <code>AddTemplateAsync()</code> and return a <code>Task</code>. Take a look at these <a href="https://msdn.microsoft.com/en-us/magazine/jj991977.aspx" rel="nofollow">best practices</a> for more details. You might want to consider passing in a <code>CancellationToken</code> depending on your requirements.

I would also advise against swallowing the base <code>Exception</code> type for reasons explained <a href="http://www.codeproject.com/Articles/9538/Exception-Handling-Best-Practices-in-NET#Don%27teverswallowexceptions13" rel="nofollow">here</a>.

SUBMITTED

w]*)+/
    File.expand_path(path, __FILE__)    
  when /\.\/[a-z]*/
    Dir.pwd + path[1..-1]
  when /\/[a-z]*/
    Dir.pwd + path
  else
    puts "Wrong path name"
  end
end

def search_in_file(path_to_file, keyword)
  f = open(path_to_file)

  flag = true

  f.each_with_index do |line, i|
    if line.include? keyword

      # print file name and path
      if flag
        puts ""
        puts path_to_file.bold.blue
        flag = false
      end
      puts "#{i+1}:".bold.gray + " #{line}".sub(keyword, keyword.bg_red) 
    end
  end
end

def file_finder(path, keyword)
  Dir.chdir(path)

  entries = Dir.entries('.')

  entries.each do |item|
    unless IGNORED_DIRS.include?(item)
      if File.file?(path + "/" + item

PRE

Opening a file without closing it causes a file descriptor leak.

<code>flag</code> is a poor variable name.

I'm not a fan of augmenting the <code>String</code> class, especially for code that is, strictly speaking, related more to terminal control than strings.

MID

def search_in_file(path_to_file, keyword)
  seen = false
  File::open(path_to_file) do |f|
    f.each_with_index do |line, i|
      if line.include?(keyword)
        if not seen
          puts path_to_file.bold.blue
          seen = true
        end
        puts "#{i+1}:".bold.gray + " #{line}".sub(keyword, keyword.bg_red)
      end
    end
  end
  puts "" if seen
end


POST

SUBMITTED

the end of to[] from to[pos] where pos= position of NULL in to[] ***/

void append(char to[],char from[],int pos)
{
    int i=0;

    while((pos&lt;STORELEN) &amp;&amp; ((to[pos]=from[i])!='\0'))
    {
        ++i;
        ++pos;
    }
    to[pos

PRE

This way it's easier to see where single expressions start or end, especially combined with syntax highlighting colors.

I'd also rewrite the contents of your <code>append()</code> function. Since there's nothing happening inside the loop other than the increments, you could use a <code>for()</code> instead:

MID

void append(char to[], char from[], int pos)
{
    int i;

    for (i = 0; pos &lt; STORELEN - 1 &amp;&amp; from[i]; to[pos++] = from[i++]);

    to[pos] = '\0'; // Only required in case you run out of space
}


POST

As long as your target string isn't too long already and there's still a character left in your source string it will copy the contents and then move both offsets every iteration. Also note the <code>- 1</code> when checking for the maximum length. Otherwise <code>pos</code> would point one past the maximum length (see below).

There's a buffer overrun in your code:

If you define <code>char string[1000]</code>, your last valid offset would be 999, since the index starts at 0.

When checking <code>pos &lt; STORELEN</code> and this check fails, the value of <code>pos</code> would be 1000 already. Once you hit the line <code>to[pos] = '\0'</code> you're essentially writing past the allocated memory at <code>string[1000]</code>.

SUBMITTED

get_gender(self):
       """Return the animals gender"""
        return self._gender

    def get_stren(self):
        """Return the animals strength"""
        return self._strength


class

PRE

Instead of getters like this:

MID

def get_stren(self):
    """Return the animals strength"""
    return self._strength


It's more natural to use properties:

@property
def stren(self):
    return self._strength


POST

When you use this, instead of <code>animal.get_stren()</code>, you will have to write <code>animal.stren</code> (without parentheses).

I also dropped the redundant comment.

The current code has many hard-wired elements for Bear and Fish,
for example:

SUBMITTED

for x in range(0,len(ls)-l):
        if x+l &gt; len(ls): return False
        if

PRE

For reference, my python 3 answer to this problem finishes in under half a second on a poor quality laptop, and doesn't use precomputed sums. The substantial differences between our algorithms are the ones hinted at above.

Style

MID

if x+l &gt; len(ls): return False

POST

SUBMITTED

lt;Row

PRE

MID

Row

POST

SUBMITTED

include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct node {
    int data;
    struct node * next;
} node_t;

void print_list(node_t * head);
void push(node_t ** head, int data);
int pop(node_t ** head);
int add_at_end(node_t ** head, int data);
int remove_last(node_t * head);
int add_at_index(node_t ** head, int n, int data);
int remove_by_index(node_t ** head, int n);


int main()
{
    node_t * head = NULL;

    head = malloc(sizeof(node_t));
    if (head == NULL) {
      return 1;
    }
    head-&gt;data = 1;
    head-&gt;next = NULL;
    print_list(head);
    return 0;
}

void push(node_t ** head, int data) {
    node_t * new_node;
    new_node = malloc(sizeof(node_t));
    new_node-&gt

PRE

<em>1.</em> You can add some comments !

<em>2.</em> In my opinion you should create another <code>struct</code> that will be named like <code>linked_list_t</code> which will have two pointers, <code>node_t * start</code> ,<code>node_t* end</code>.In terms of efficiency, by doing this, you don't have to iterate all the list on <code>add_at_end</code> to add a single node (this is a common practice when you create a <code>linked_list</code>)

<em>3.</em> When you malloc you can check the <code>returned pointer</code> and if it is <code>NULL</code> you should <code>perror()</code> the message.

<em>4.</em> The code 

MID

typedef struct node {
    int data;
    struct node * next;
} node_t;

void print_list(node_t * head);
void push(node_t ** head, int data);
int pop(node_t ** head);
int add_at_end(node_t ** head, int data);
int remove_last(node_t * head);
int add_at_index(node_t ** head, int n, int data);
int remove_by_index(node_t ** head, int n);


POST

should be put on a <code>header file</code> as it just contains <code>declarations</code> 

<em>5.</em> Use <a href="https://en.wikipedia.org/wiki/Sentinel_node" rel="nofollow">Sentinel Nodes</a> in order not to iterate on <code>int remove_last(node_t *)</code>

SUBMITTED

E&gt; the type of the satellite datum.
     */
    public static final class BinaryTreeNode&lt;E extends Comparable&lt;? super E&gt;&gt; 
    extends AbstractBinaryTreeNode&lt;E, BinaryTreeNode&lt;E&gt;&gt; {

        /**
         * Construct a new tree node with given element.
         * 
         * @param element the element to store in

PRE

On the whole, your code is neat, the style is good, generics look OK. I have a concern with two major 'design' points though.

The first is the <code>AbstractBinaryTreeNode</code> class. This encapsulates the basic functionality of a node in the binary tree, and it makes it seem that there would be a way to customize the implementation.

Unfortunately, you can't.

Your BinaryTree class creates a concrete implementation as a static-internal: 

MID

public static final class BinaryTreeNode&lt;E extends Comparable&lt;? super E&gt;&gt; 
   extends AbstractBinaryTreeNode&lt;E, BinaryTreeNode&lt;E&gt;&gt; {


POST

and then only uses this implementation for the root:

SUBMITTED

class PaperPlayer

PRE

MID

PaperPlayer

POST

SUBMITTED

this.currentReports);
     LimitsManager.calcFteLimits

PRE

Since <code>this.originalReports</code> is not referenced again within the function,
it would seem that this produces a side effect outside the function.
Or else, it's pointless and should be deleted.

The only references to <code>LimitsManager</code>:

MID

LimitsManager.calcFteLimits();


POST

What is it doing there in the middle of the function?
Does it need to be in the middle?
Can it be at the start or at the end?
Or does it have a side effect that makes a difference for the code that appears before or after it?

If the code dealing with <code>ChartBuilder</code> is moved out to its own method,
then this part can be simplified:

SUBMITTED

pair
        arv, dest = tickets.shift
        if arv == nil 
            break #Done if we are out of tickets
        end
        ordered_flights[iter] = []
        ordered_flights[iter].push(arv, dest

PRE

Use <code>#nil?</code> rather than <code>== nil</code>, <code>empty?</code> when checking array lengths, <code>#first</code>/<code>#last</code> when accessing the start/end of an array, etc.. 

Postfix conditions for single-line, single-branch conditionals. E.g. this:

MID

if arv == nil 
    break #Done if we are out of tickets
end


becomes:

break if arv.nil? # Done if we are out of tickets


POST

Instead of iterating through ranges like <code>(0...n)</code> you can use <code>n.times</code> instead. E.g. <code>n.times { |i| puts i }</code> will produce the same as <code>(0...n).each { |i| puts i }</code>

You missed a single pair of parentheses in a method call: <code>.join ' '</code> :)<br>
Granted, you can write Ruby without parentheses (Seattle style Ruby). Personally though, I like 'em (except for <code>puts</code> and <code>print</code>), but <a href="http://heartmindcode.com/2013/09/05/parentheses-in-ruby/" rel="nofollow">there are arguments for and against</a>.

Instead of <code>$stdin.readline.strip</code>, you can use the more common <code>gets.chomp</code>. <code>#gets</code> is just a shortcut for <code>$stdin.readline</code>, and <code>#chomp</code> chops off the linebreak, but leaves other whitespace intact.

When possible use methods like <code>#map</code> and <code>#reduce</code> and their ilk instead of modifying a closed-over object from inside a block. E.g. this:

SUBMITTED

this.lblCheck.Visible = false;
this.lblBackup.Visible = false;
this.txtEmpNo.Visible = false;
this.CheckButton.Enabled = false;

if (matchedCode)
{
    if (checkBackdatedLeave || startDate &gt; todayDate)
    {
        if (!checkBackdatedLeave) { this.lblCheck.Visible = true; }

        this.lblBackup.Visible = true;
        this.txtEmpNo.Visible = true;
        this.CheckButton.Enabled = true

PRE

The answer of <a href="https://codereview.stackexchange.com/users/47901/ivo-beckers"><strong>Ivo Beckers</strong></a> already provides a viable solution. The only thing I would change is to place the three same checks in a variable and use that variable, instead of checking again and again. And only for <code>lblCheck</code>, do another check.

For example:

MID

var status = matchedCode &amp;&amp; (checkBackdatedLeave || startDate &gt; todayDate);

this.lblBackup.Visible = status;
this.txtEmpNo.Visible = status;
this.CheckButton.Enabled = status;

this.lblCheck.Visible = matchedCode &amp;&amp; !checkBackdatedLeave;


POST

SUBMITTED

equalsIgnoreCase("SYN_REPORT

PRE

At each state, you check whether the input line is valid, and update the Event with data. You know at <code>SYN_MT_REPORT</code> you add the MTEvent to the Event's List and at <code>SYN_REPORT</code> you have read the whole event, so you can add the event to the event list. If the line isn't valid, have it throw a parseException that your main read loop can catch.

Based on the input, you also choose the next state, So, when you're in the <code>SYN_MT_REPORT</code> state,  when you next call parseLine, the next command could be a <code>ABS_MT_TOUCH_MAJOR</code> or a <code>SYN_REPORT</code>, so in the nextAction method, the line read will decide between each.

MID

SYN_REPORT

POST

SUBMITTED

lt;div class="container"&gt;
&lt;div class="row"&gt;
    &lt;div class="col-xs-3"&gt;
        &lt;div class="animate bg-info" data-animation="left" data-distance="200" data-speed="1000" data-delay="0" data-offset="80" data-easing="easeInOutBack"&gt;Nulla vel varius

PRE

Now consider when there are two <code>.animate</code> elements on page:

MID

&lt;div class="animate" data-speed="200"&gt;&lt;/div&gt;
&lt;div class="animate" data-delay="1000"&gt;&lt;/div&gt;


POST

The first one will be animated with <code>speed=200</code> and default delay, but the second one will be animated with both <code>delay=1000</code> and <code>speed=200</code> because each time <code>loadValues()</code> is ran, the values it overrides in <code>settings</code> will stay there.

<strong>This jQuery plugin is hard-coded to a concrete selector.</strong>

Instead of selecting <code>.animate</code> class directly inside the plugin, you should use the <code>this</code> context element:

SUBMITTED

class Circle

PRE

MID

Circle

POST

Even the code is shorter.
There are no obvious downsides either, which is in stark contrast with the superclass variant.

Consider a mixed hierarchy, using protocols and inheritance where they make sense.
For example <code>Shape</code> should clearly be a protocol,
but <code>Rectangle</code> can be a class that specialized cases like <code>Square</code> can inherit from.
As you explore the shape universe,
there might be other cases in the hierarchy where a protocol might make sense.

SUBMITTED

class TestClass {
    private static byte N;
    public static

PRE

MID

private static byte N;


POST

We know that <code>N&lt;=100</code>, but this is a very premature optimization. In theory, you're saving 3 bytes <em>total</em>. Actually, it'll get rounded up to a nearest multiple of 8 or whatever and you save nothing at all.

It's also no good idea top make everything <code>static</code>.

SUBMITTED

public byte[] genReportBytes(int id, string fromm,string too,string filetype)
{
    reportDetails repD = new reportDetails();
    repD = getOneReport(id);

    LocalReport report = new LocalReport

PRE

Your naming conventions are hard to follow, or you're not following them; either way, you're not following the standard/recommended/established conventions.

MID

public byte[] genReportBytes(int id, string fromm,string too,string filetype)


Public members should be <code>PascalCase</code>; locals and parameters should be <code>camelCase</code>. That would make the signature read like this:

public byte[] GenReportBytes(int id, string fromm, string too, string fileType)


POST

<code>getOneReport(id)</code> would be <code>GetOneReport(id)</code>, and <code>getReportData(sqlGet, repD.ParametersCommandLine))</code> would be <code>GetReportData(sqlGet, repD.ParametersCommandLine))</code>, and <code>streamids</code> would be <code>streamIds</code>.

But if I had to pick only 1 name to change, it would be this one:

SUBMITTED

gt;(pq);
        int index = 0;
        float number = 0.0f;
        int halfQueueSize = (temp.size() &gt;&gt; 1);

        if(temp.size() % 2 != 0) {
            while(index

PRE

Don't use <code>float</code> unless you really have to conserve memory. They're pretty imprecise and they're no faster than <code>double</code>, at least on modern Desktop CPUs.

MID

    int halfQueueSize = (temp.size() &gt;&gt; 1);

    if(temp.size() % 2 != 0) {


Do you optimize division by 2 as shift or don't you? Note that it hardly matters as this is surely not the most time-consuming operation here.

    if(temp.size() % 2 != 0) {
        while(index++ &lt;= halfQueueSize) {
            number = temp.poll();
        }
        return number;
    } else {
        while(index++ &lt; halfQueueSize) {
           number = temp.poll();
        }
        return ((number+temp.poll())/2.0f);
    }


You really shouldn't have two nearly identical branches. It makes it hard to spot the difference. With something like

    int halfQueueSize = (temp.size() &gt;&gt; 1) + (temp.size() &amp; 1);


POST

you can use <code>&lt;</code> in both branches and pull the loop out.

SUBMITTED

e(0) &amp; " " &amp; wsImport.Name
End If

Next

Application.ScreenUpdating = False
wsMain.Columns("A:AO").Select
Selection.EntireColumn.AutoFit

Application.ScreenUpdating = False
Selection.ClearFormats

Dim tbl As ListObject
Set tbl = ActiveSheet.ListObjects.Add(xlSrcRange, Selection, , xlYes)
tbl.TableStyle = "TableStyleMedium9"

Application.ScreenUpdating = True

End Sub

PRE

<a href="https://stackoverflow.com/questions/10714251/how-to-avoid-using-select-in-excel-vba-macros">Don't activate and select</a>. Use object references/variables instead.

MID

wsMain.Columns("A:AO").Select
Selection.EntireColumn.AutoFit
Selection.ClearFormats

Dim tbl As ListObject
Set tbl = ActiveSheet.ListObjects.Add(xlSrcRange, Selection, , xlYes)


Should be

   Dim cols As Range
   Set cols = wsMain.Columns("A:AO") 
   cols.EntireColumn.AutoFit
   cols.ClearFormats

   Dim tbl As ListObject
   Set tbl = ActiveSheet.ListObjects.Add(xlSrcRange, cols, , xlYes)
   tbl.TableStyle = "TableStyleMedium9"


POST

Always be explicit about scope. Procedures defined as just plain <code>Sub</code> are public. It's better to write that down instead of relying on a developer's knowledge (or lack there of).

Here's the resulting code. I apologize that I never got around to performance. There were a number of issues to work through first. If I get time, I'll take a look at the performance later.

SUBMITTED

package Blackjack

PRE

MID

Blackjack

POST

SUBMITTED

address check is enabled
                        isAddress = true;
                    } else {
                        addressNew = new StringBuffer(returnAddress.getErrorString

PRE

This code could be more efficient, in that it could be written more compactly.  However, I don't see anything that would cause a noticeable performance impact.  If you're connecting to a remote server to verify an address, I would expect that the time to send, process, and receive that request would dwarf whatever time it takes to concatenate a few strings.

I have much deeper concerns about this code than performance.

This line, in particular, has me very worried:

MID

} else {
    addressNew = new StringBuffer(returnAddress.getErrorString());                                                      
}


POST

<strong>Always distinguish error messages from legitimate data.</strong>  Do not output them through the same channel.  Here's a real-life example of what happens when error messages are accidentally treated as data:

<img src="https://newsimg.bbc.co.uk/media/images/45162000/jpg/_45162744_-2.jpg" alt="Nid wyf yn y swyddfa ar hyn o bryd. Anfonwch unrhyw waith i&#39;w gyfieithu.">

That's <a href="http://news.bbc.co.uk/2/hi/7702913.stm" rel="nofollow noreferrer">Welsh for "I am not in the office at the moment. Send any work to be translated."</a>

Don't let that happen to users of this function.  In Java, the right thing to do when you encounter an error is to throw an exception.  That forces a caller somewhere in the call stack to deal with the error as an error, and helps prevent mix-ups like this.

It's not clear what this function is supposed to return.  Here's the return for the "desired" code path:

SUBMITTED

for user in users %}
    {% for score in scores %}
    {% if score.user == user %} {{ user }} -- {{ score.subject }} -- {{ score.score }} &lt;br&gt;{% endif %}
    {% endfor %}
    {% endfor

PRE

And then in the template you can eliminate one <code>for</code> and one <code>if</code>:

MID

{% for score in scores %}
{{ score.user }} -- {{ score.subject }} -- {{ score.score }} &lt;br&gt;
{% endfor %}


POST

SUBMITTED

PostTypeId = 1 --questions
  and Body not like '%&lt;/code&gt;&lt;/pre&gt;%'
  and ClosedDate is null
order by

PRE

I have never used it before but I think what you are looking for is <code>CHARINDEX</code> I found a <a href="https://stackoverflow.com/a/25676890/1214743">StackOverflow Answer</a> that has several upvotes and no downvotes using it like this

MID

WHERE CHARINDEX('&lt;/code&gt;&lt;/pre&gt;', Body) = 0


POST

So far from what I have seen they are relatively close to the same speed, and is giving the same results as your query.  

I would much rather read this than <code>Body not like '%&lt;/code&gt;&lt;/pre&gt;%'</code>

I think we have found a new "hammer", let's find some nails.

<sub><a href="https://msdn.microsoft.com/en-us/library/ms186323.aspx" rel="nofollow noreferrer">Read more about CHARINDEX Here</a></sub>

There is also a <code>CONTAINS</code> function in T-SQL, but unfortunately it cannot be used on that column of that table because the column is not Full-Text Indexed

<sub><a href="https://msdn.microsoft.com/en-us/library/ms187787.aspx" rel="nofollow noreferrer">Read more about <code>CONTAINS</code> Here</a></sub>

SUBMITTED

targetTypes, String name, PlayerAbility reward) {
        super(targetNumber, world, name, reward

PRE

There's several things to address here, so let's get to it!

<strong>Classes</strong>

Too many.

<strong>Speed</strong>

Can be better.

<strong>Declaring missions</strong>

Perfect for a config file.

<strong>checkIfMissionComplete</strong>

Slight code duplication.

<a href="http://altreus.github.io/qi-klaxon/?Strategy+Pattern">BEEP BEEP BEEP Strategy pattern!</a>

This bothers me a bit:

MID

super(targetNumber, world, name, reward);


Instead of having that, I would use a <code>MayorMission</code> constructor like this:

public MayorMission(int targetNumber, World world, String name,
    PlayerAbility reward, GameGoal goal)


POST

Where <code>GameGoal</code> is something like:

SUBMITTED

Result.win

PRE

MID

win

POST

SUBMITTED

sender = 15
OR

PRE

MID

OR

You should make it a habit to look at your queries' execution plan when in doubt. I recreated the table in SQL Fiddle (albeit, without containing data) and it shows that the query with <code>OR</code> is less complex.

<em><strong>Please note:</strong> SQL Fiddle does not support your <code>FOREIGN KEY</code> constraints, so I had to remove them.</em>

OR

POST

<img src="https://i.stack.imgur.com/vsCOo.png" alt="OR" />

SUBMITTED

laps_correct'] = dict

PRE

MID

dict

POST

SUBMITTED

import statistics
import sys

samples = []


def menu():
    print("Welcome to the Statistics Assistant 3000")
    print("Select from the following options:")
    print("    1. Find the mean")
    print("    2. Find the median")
    print("    3. Find the mode")
    print("    4. Find the range")
    print("    5. Find the standard deviation")
    print("    6. Find the z-score")
    print("    0. Quit program")

    choice = input("Pick one: ")

    if choice == '1':
        find_mean()
    elif choice == '2':
        find_median()
    elif choice == '3':
        find_mode()
    elif choice == '4':
        find_range()
    elif choice == '5':
        standard_deviation()
    elif choice == '6':
        z_score()
    elif choice == '0':
        f = open('sultry.txt')

        for line in f:
            print(line)
        sys.exit()
    else:
        print("That isn't one of the options")
        print("Try again")
        menu()


def load_samples():
    global samples

    print("Would you like to load samples from a text file")
    print("or

PRE

You can use dictionary for making menu

MID

def menu():
    prompt = '''Welcome to the Statistics Assistant 3000
    Select from the following options:
    1. Find the mean
    2. Find the median
    3. Find the mode
    4. Find the range
    5. Find the standard deviation
    6. Find the z-score
    0. Quit program'''
    print(prompt)

    choice = input('Pick one: ')
    choices = {
        '1': find_mean,
        '2': find_median,
        '3': find_mode,
        '4': find_range,
        '5': standard_deviation,
        '6': z_score,
        '0': quit
    }

    if choice in choices:
        choices[choice]()
    else:
        print_failure()


POST

Give some defaults, upper case - default value

SUBMITTED

for (int i = 0; i &lt; 100000; i++)
        {
            writer.WriteLine("AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA");
            for (int j = 0; j &lt; 1000; j++)
            {
                Math.Sin(Math.Cos(Math.Pow(j, j)));
            }
        }
    }
    Console.WriteLine("buffered:   " + watch.ElapsedMilliseconds);
    return

PRE

The issue is the underlying dataset being tested. 

Instead of just writing the same string again and again:

MID

writer.WriteLine("AAAAAAA...");
for (int j = 0; j &lt; 1000; j++)
{
    Math.Sin(Math.Cos(Math.Pow(j, j)));
}


POST

Generate a random string, then write that data:

SUBMITTED

i = 1 To 7
        value = Well_List.Column(i, row)
        If value &lt;&gt; vbNullString Then 
            CallByName wellObj, properties(i), VbLet, value
        End If
    Next

End Sub

PRE

Now you can go from 1 to 7 and, assuming <code>CWell</code> is a class module (I'm not all that familiar with Access, I hope my assumption is correct)...

MID

For i = 1 To 7
    value = Well_List.Column(i, row)
    If value &lt;&gt; vbNullString Then SetPropertyValue wellObj, properties(i), value
Next


POST

Notice I'm using <code>vbNullString</code> instead of an empty string literal <code>""</code>. <code>vbNullString</code> is a <em>null string pointer</em>, which isn't allocated a memory address. <code>""</code> has its own memory spot. No biggie, but not needed either.

So, how would that <code>SetPropertyValue</code> method be implemented? The VBA standard library has this little wonder in its <code>VBA.Interaction</code> module, called <code>CallByName</code>:

SUBMITTED

new ConcurrentDictionary&lt;string, SubscriptionClient&gt;();

        public NamespaceManager NamespaceManager { get; set; }
        public DefaultAzureServiceBusHelper(IValidationService validationService)
        {
            _validationService = validationService;
            _defaultConnectionString = CloudConfigurationManager.GetSetting("Microsoft.ServiceBus.ConnectionString");
        }


        public NamespaceManager GetNamespaceManager(string connectionString = null)
        {
            lock(_padLock)
            {
                if(this.NamespaceManager == null)
                {
                    this.NamespaceManager = NamespaceManager.CreateFromConnectionString(connectionString ?? _defaultConnectionString);
                }
            }
            return this.NamespaceManager;
        }

        public TopicDescription CreateTopic(string path)
        {
            _validationService.StringIsNullOrEmpty(path

PRE

Of course we can! And we <em>should</em>! If no class actually depends on an <code>IConfigurationManager</code>, then the <code>CloudConfigurationManager</code> should be used at the <em>composition root</em>, to consructor-inject the <code>defaultConnectionString</code> and other configuration settings needed throughout the application.

This is a very confusing API:

MID

public NamespaceManager NamespaceManager { get; set; }

public NamespaceManager GetNamespaceManager(string connectionString = null)
{
    lock(_padLock)
    {
        if(this.NamespaceManager == null)
        {
            this.NamespaceManager = NamespaceManager.CreateFromConnectionString(connectionString ?? _defaultConnectionString);
        }
    }
    return this.NamespaceManager;
}


POST

<code>NamespaceManager</code> has a public setter, so anyone anywhere can set it to anything. And it has a public getter, so anyone anywhere can retrieve it without ever calling <code>GetNamespaceManager</code> - get rid of the auto-property, it's nothing more than a public field with a property's makeup at that point.

SUBMITTED

description]
 * 
 * @param   queue   a queue structure reference
 * @return [description]
 */
uint8_t queueIsEmpty(const strqueue_t *queue)
{
    if(queue-&gt;front

PRE

checks three conditions.  But any one of those three conditions would mean an empty list so you can just pick one:

MID

bool queueIsEmpty(const strqueue_t *queue)
{
    return queue-&gt;nodeCount == 0;
}


Here is another place with redundant checks.  But there are other problems:

char * queueFront(strqueue_t * queue)
{
    if ((queue-&gt;front != NULL) &amp;&amp; (queue-&gt;rear != NULL))
        return (queue-&gt;front-&gt;data);
    else
        return 0;
}


You have some extra parentheses here.  Also, you return <code>0</code> instead of <code>NULL</code>.  I would also go ahead and make this function return <code>const char *</code> because it would be bad for the caller to do something like free the data when the data is still in the queue.  It depends on your usage case, though.

const char * queueFront(const strqueue_t * queue)
{
    if (queue-&gt;front == NULL)
        return NULL;
    return queue-&gt;front-&gt;data;
}


POST

I commend you on your use of <code>const</code> when appropriate.  You missed one spot in <code>queueDisplay()</code>, but otherwise well done.

SUBMITTED

context);

    void acquire();

    void release();

    void think();

    void eat();

    void waitForLeft();

    void waitForRight();

    void releaseLeft();

    void releaseRight();

    int getNo();

    void setNo(int no);

    bool amIOdd();

    void join();

};


//A class demonstrating problem of 5 philosophers
class CPhilo5
{
    CPhilo* philos[PHIL_COUNT];
    CFork * forks[PHIL_COUNT];
    CBoard* _board;

public:

    CPhilo5();

    ~CPhilo5();

    void join();

private:

    void createForks();

    void

PRE

All these are guaranteed not to be NULL. So why have pointers. Reference are a much better metaphor for what you are trying to achieve and there is no need to validate they are NULL.

These are all part of the public interface?

MID

void acquire();
void release();
void think();
void eat();
void waitForLeft();
void waitForRight();
void releaseLeft();
void releaseRight();
int getNo();
void setNo(int no);
bool amIOdd();
void join();


POST

Is wrong. If a philosopher can not acquire either fork they are supposed to be thinking instead. In your code when they try and acquire a fork they block waiting for the to be available. Thus they never get any thinking time in.

When you try and acquire a fork if you fail you drop any currently held forks and then think. You should never block waiting for fork.

I don't remember and dinner parties were guests were just looking at the handle of the fork waiting for it to become available. If they could not get a fork they generally engage in conversation until the fork is available.

Remember this problem was originally designed to allocate tape drive resources as efficiently as possible. You are not using your tape drives or your CPU very well if you spend time waiting.

SUBMITTED

PartitionHolder

PRE

MID

PartitionHolder

POST

The implementation for local/remote primary/secondary addresses all look <em>extremely</em> familiar... to the refactoring machine!

SUBMITTED

idx];} else return 0;
  }
void  AImg::setdata(void* input){data=(void*)input;}
void* AImg::getdata

PRE

I don't think that the method <code>setdata</code> really needs a cast from <code>void*</code> to <code>void*</code>:

MID

void AImg::setdata(void* input) { data = input; }


POST

SUBMITTED

a singleton TCP server.
     */

    public class Server extends Thread {

        private

PRE

MID

public class Server extends Thread {


POST

Don't extend <code>Thread</code>. Implement <code>Runnable</code> instead. By extending Thread it's not possible for constructs like thread pools to run your server. What's more, "restarting" a server isn't possible either, because a thread that has stopped cannot be restarted. You can, however, rerun a runnable on a new Thread.

SUBMITTED

public class EventManager {

    public static EventManager mouseRightClick = new EventManager(EventType.mouseRightClick), mouseLeftClick = new EventManager(EventType.mouseLeftClick);

    public final EventType type;

    public List&lt;Listener&gt; listeners

PRE

Avoid declaring multiple variables on the same line,
especially when the line is long.
At first I didn't see that there are two variables declared on this line:

MID

public static EventManager mouseRightClick = new EventManager(EventType.mouseRightClick), mouseLeftClick = new EventManager(EventType.mouseLeftClick);


This is much better:

public static EventManager mouseRightClick = new EventManager(EventType.mouseRightClick)
public static EventManager mouseLeftClick = new EventManager(EventType.mouseLeftClick);


POST

At first glance it looks like the class has a nice general purpose,
to manage listeners and dispatch events to them.
The <code>mouseRightClick</code> and <code>mouseLeftClick</code> members violate the general purpose and the reusability of this class.
It would be better to move those out to a different class,
perhaps an <code>EventManagerRegistry</code>.

The <code>listeners</code> member shouldn't be <code>public</code>.
A malicious user could change its value and break your class.
It should be <code>private</code>.
And it can be <code>final</code>,
as it's never reassigned during the lifetime of the class.

Let's see the time complexity of the main operations:

This is because you store listeners in a list.
You could do better by storing them in a <code>Set</code>.
On the other hand,
if dispatching in reverse order is important,
then using a <code>Set</code> would be tricky.
I don't know your reasons for iterating in reverse order.
If you wouldn't mind iterating in insertion order,
then you could use a <code>LinkedHashSet</code>.

Keep in mind that the implementation is not thread-safe.
If the class might be used by multiple threads,
you can get runtime exceptions and incorrect behavior.

SUBMITTED

self, id

PRE

MID

id

POST

SUBMITTED

gt;returnData

PRE

MID

$returnData

POST

SUBMITTED

if [ $(grep

PRE

MID

grep

POST

SUBMITTED

calculations.grain_per_meal}}"
};
function decrement(){
        if(current == 0)
                current = 4 
    else
        current--;
}

function increment(){ 
    if(current == 4)
        current

PRE

Some variables are named <code>camelCase</code> and others <code>snake_case</code>.
The convention in Python is to use <code>snake_case</code>,
consistently, everywhere.

It's ok to use a different convention for variables in JavaScript and the cookies,
that's up to you.
For Python there is a standard (<code>snake_case</code>), and it's good to follow that.

The indenting is off at many places in the JavaScript code, for example:

MID

function decrement(){
        if(current == 0)
                current = 4 
    else
        current--;
}


The clean way to write:

function decrement(){
    if (current == 0) {
        current = 4; 
    } else {
        current--;
    }
}


POST

Notice that I also added braces <code>{ ... }</code>, a recommended practice,
and a statement terminating <code>;</code> was missing too.

You seem concerned about the way you pass data to the template. And then how the context is used to store these values in JavaScript. It doesn't seem so bad to me. I don't really have groundbreaking ideas to improve this part, it seems quite done the way it is now.

The only thing is, I would drop the term "context" from the function name <code>build_calculations_context</code>. Because the dictionary of calculations that this creates is only one part of the context (in Django's terms) that you pass to the template, which can be confusing, misleading readers that this dictionary is the whole context. For the same reason, also avoid assigning this dictionary to variables named context.

SUBMITTED

super();
        number = 0;
        ivs = new ArrayList&lt;ImageView&gt;();

        for (int i = 0; i &lt; digit; i++){

            ivs.add(new ImageView());
            ivs.get(i).setFitHeight(DISPLAY_HEIGHT);

            ivs.get(i).setFitWidth(DISPLAY_WIDTH);
            this.getChildren().add(ivs.get(i));
        }

        this.update();

    }

    public void setNumber

PRE

There are multiple things wrong with these lines:

MID

ivs.add(new ImageView());
ivs.get(i).setFitHeight(DISPLAY_HEIGHT);

ivs.get(i).setFitWidth(DISPLAY_WIDTH);
this.getChildren().add(ivs.get(i));


ivs.get(i)

Isn't this a little redundant and inefficient? Wouldn't it be easier to just store <code>ivs.get(i)</code> in a variable, and then to re-<code>put</code> it back into the array when you are done?

ivs.get(i) == ivs.add(...)

POST

This may just be me, but when you add a new <code>ImageView</code> to the array, and then you <code>get(i)</code>, wouldn't you be retrieving the <code>ImageView</code> that you just put in?

If so, don't add the <code>ImageView</code> to the array until you are done calling all those functions on it. Then, you can add it to the array.

The same recommendation I wrote about the other pictures applies to the ones at the end of this file.

Write some JavaDoc.

You wrote a lot of code, and that code could get really hard to look back on unless you have documentation describing each and every method.

And, by having JavaDoc, it will be easier for other people to review your code.

SUBMITTED

new UnsupportedOperationException(
            "Range: Unsupported

PRE

This is the first method which will fall pray to round-off errors. For something like

MID

new Range(0.0, 0.1, 1.0)


POST

you may get that it contains 10 or 11 elements. It's deterministic, but from the user's POV it looks random. A representation using <code>min, </code>step<code>, and </code>size` would be better.

Skipped many throwing methods which can be inherited from <code>AbstractList</code>.

SUBMITTED

using System

PRE

MID

using

POST

SUBMITTED

path):
        exit

PRE

MID

exit

POST

SUBMITTED

T&gt; *tmp = head;
        head = head-&gt;next;
        delete tmp;
        --currSize;
    }
}

template &lt;typename T&gt;
int Stack&lt;T&gt;::size() const
{
    return currSize;
}

template &lt;typename T&gt;
T Stack&lt;T&gt;::top() const
{
    if (head != nullptr)
    {
        return head-&gt;data;
    }
    else return NULL;
}



int

PRE

This way you won't risk ending with a half destroyed object in your hands.

MID

template &lt;typename T&gt;
T Stack&lt;T&gt;::top() const
{
    if (head != nullptr)
    {
        return head-&gt;data;
    }
    else return NULL;
    //          ^^^^ problem here!
}


POST

That will not work for a <code>T</code> type that is not a pointer or integer. <code>NULL</code> can be assigned to integers because it is usually implemented as <code>#define</code> for <code>0</code>. That's one of the reasons why you should use <a href="https://en.cppreference.com/w/cpp/language/nullptr" rel="nofollow noreferrer"><code>nullptr</code></a> whenever possible (C++11). If you had used <code>nullptr</code>, your test with <code>T=char</code> would have failed and you would have noticed this problem.

The usual convention for a generic stack is to throw an exception if you try to access the top for an empty stack. Returning a &quot;default&quot; value is less generic and also makes it harder for the caller to detect errors. Returning a default also requires the type <code>T</code> to be default constructible, so don't do it.

Same goes for popping on an empty stack. Right now you are not generating any errors. You should consider throwing and exception. Deriving a <code>StackUnderflow</code> exception type from <a href="https://en.cppreference.com/w/cpp/error/runtime_error" rel="nofollow noreferrer"><code>std::runtime_error</code></a> might be a good idea. Then you can extend the concept to a <code>StackOverflow</code> error when trying to push to the bounded stack. Granted that you can do with a simple <code>std::runtime_error</code>, but defining custom exception classes is a nice exercise if that's your point for writing this implementation.

SUBMITTED

ListElement&lt;T&gt; tail;

    public QueueCircularDLL(){
        head=null;
        tail=null;
    }

    public

PRE

<strong>Constructor needed?</strong>

First of, these are not needed because Java null initializes object references.

MID

public QueueCircularDLL(){
    head=null;
    tail=null;
}


POST

Meaning, you do not need a constructor in this code.

<a href="http://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html" rel="nofollow">Reference</a>

<em>Note: It can be considered bad practice, if you prefer to explicity state they are null then do it in the same line as initialization.</em>

<strong>Code Conventions</strong>

Normally <code>if-else</code> would look like:

SUBMITTED

amp; pop

PRE

MID

pop

POST

The reason you're crashing is that the local value you moved out of is destroyed when you leave the function scope. So you're moving from rubbish. <a href="https://stackoverflow.com/questions/1116641/is-returning-by-rvalue-reference-more-efficient">Returning by r-value reference: Just don't</a>. The compiler will likely perform <a href="https://en.wikipedia.org/wiki/Return_value_optimization" rel="nofollow noreferrer">(N)RVO</a> and the copy will be optimized out if it is possible.

You have an infinite conditional wait. It may be useful to have a functionality to &quot;sever&quot; the queue and release all threads waiting on jobs.

Typically you would have:

SUBMITTED

FALSE, retry_times

PRE

It is simpler, and is easier to use / understand.

If you want to overwrite the memoized variable, pass <code>overwrite=True</code>.<br>
Forget is ambiguous to what you are forgetting.

If you want to handle <code>**kwargs</code> at a later date, you may want to change it to <code>overwrite_memoized</code>, or an alternate less common name.

MID

retry_times

POST

SUBMITTED

startPoint = this.edgePointForDirection(sideToStart);

        for (int i = 0; i &lt; CityWorld.WORLD_HEIGHT; i++) {
            Tile firstTile = world[startPoint

PRE

MID

for (int i = 0; i &lt; CityWorld.WORLD_HEIGHT; i++) {


POST

This looks like it will break if your <code>WORLD_HEIGHT</code> is not equal to your <code>WORLD_WIDTH</code>.

SUBMITTED

BigDecimal

PRE

You can fix it by replacing <code>.doubleValue()</code> with <code>.toString()</code>,
the unit test will pass.

MID

BigDecimal

POST

<code>BigDecimal</code> instances are immutable, so you can safely pass around copies.
Creating <code>new</code> instances is completely unnecessary.
Your current approach forces you to clone.
Since cloning is non-sense, this indicates a code smell,
and that a better solution is probably available.

A better approach would be to avoid the strange cloning, by making the decorated object a final field in your wrapper class. Add a constructor that takes a <code>BigDecimal</code>, and call that one instead of super. 

By the way, putting the decorated object into a field of the decorator class is the common technique when implementing this pattern (composition instead of inheritance). It makes it possible to nest multiple decorators in arbitrary order. Inheritance is a very tight coupling, composition gives you much more flexibility.

For example something like this:

SUBMITTED

using System

PRE

Nothing terribly major, but:

MID

using

POST

SUBMITTED

Tree&lt;T&gt;::Tree(const Tree&amp; rhs){
    if(rhs.root==NULL)
        root=NULL;
    else
        copyTree(root,rhs.root);
}

template&lt;class T&gt;
void Tree&lt;T&gt;::copyTree(TreeNode *&amp;thisRoot,TreeNode *rhsRoot){
    if(rhsRoot==NULL)
        thisRoot

PRE

Now you can uncomment <code>TreeNode</code>'s destructor and enjoy a correct code without memory leaks.

<a href="/questions/tagged/c%2b%2b11" class="post-tag" title="show questions tagged &#39;c++11&#39;" rel="tag">c++11</a> Consider adding a move constructor and a move assignment operator to your class. The cost of moving a tree is trivial compared to what it costs to copy a whole tree:

MID

template&lt;class T&gt;
Tree&lt;T&gt;::Tree(Tree&amp;&amp; other):
    root(other.root)
{
    other.root = nullptr;
}


POST

See, all the move constructor does is acquire the memory managed by <code>other</code> and assign <code>nullptr</code> to <code>other.root</code> so that the memory does not get freed when <code>other</code> is destructed.

<code>const</code>-correctness is important in C++. When one of your methods does not modify a class, mark it <code>const</code>. Not only will it make it clear which functions modify the class and which ones do not, but it is also essential if you need to use these functions in a <code>const</code> context.

SUBMITTED

in

            //execute slow task
            self.queryForTable

PRE

First off, I don't know Swift.  These are generic issues that should be addressed in all written code, and I'll leave the Swift-specific stuff to the experts.

MID

//execute slow task


POST

Comments should say why the code is the way it is, not a generic comment that doesn't tell us anything constructive.  If there is an issue with the code being slow, document why it is slow, and maybe state why you haven't been able to fix it for future reference.

SUBMITTED

permutations
n

PRE

It's a waste to explore the entire permutation space.
There's a simpler way to calculate the possible combinations using basic combinatorics principles:

MID

1 .. n

1 .. n-1

1 .. n-2

POST

There are <code>n * (n - 1) * (n - 2)</code> combinations like this,
but that includes <code>n</code> in the first, second, and third positions.
You need to exclude the combinations where <code>n</code> is in the first and third position, so you need to divide it by 3.

SUBMITTED

public partial class Home : UserControl
    {

        private Microsoft.Win32.OpenFileDialog dlg = new Microsoft.Win32.OpenFileDialog();

        public Home()
        {
            InitializeComponent();
            Startup

PRE

Any particular reason you're using this alias? Most people I see that use aliases (including me) have these as part of an automatic re-formatting of the document.

MID

private Microsoft.Win32.OpenFileDialog dlg = new Microsoft.Win32.OpenFileDialog();


POST

As far as I can tell you only show the dialog once (to get the location) and afterwards you only use the filename. I would keep a local field pointed to the filename and create the dialog inside <code>BrowseButton_Click</code> instead. That way you can also easily check for <code>if(filename == null)</code> instead of doing <code>if (string.IsNullOrEmpty(TextBoxFile.Text))</code>.

SUBMITTED

showToast();
            } else {
                subtract = true

PRE

MID

subtract = true

POST

SUBMITTED

main

PRE

It's pretty unusual to <code>declare</code> all of your functions before defining them.

It appears that you did it so that you could define your functions in the order you thought
most appropriate. That's common for newcomers, and it's certainly something many people are
used to. To be clear, there's <em>nothing</em> wrong with wanting that.

However, most clojure programs work within this constraint and just define things in the
order they are needed. After a while you become accustomed to seeing things in that order,
and you start to look at the bottom of the file for the program overview. This has the
minor benefit of calling out the places where circular references are actually needed.

MID

-main

POST

This is a toy program, so calling <code>-main</code> in your namespace probably does what you want 100%
of the time. However, in a real codebase, doing that can pretty much make your namespace
unusable for other namespaces. If you're using <code>lein</code> you can call:

SUBMITTED

String senddata);
    }

    public ConnectionExector(Context context) {

        try {
            this.context = context;

            executorService = Executors.newFixedThreadPool(3);

        } catch (Exception e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

    }

    public class HttpDefs {

        public String _URL;
        public JSONObject jsonData;
        public String _Data;
        public onHttpRequestListener Response;
        public List&lt;NameValuePair

PRE

Or just rename it to something like <code>NONE</code> or <code>INIT</code>.

<strong>3)</strong>

MID

public ConnectionExector(Context context) {
    try {
        this.context = context;
        executorService = Executors.newFixedThreadPool(3);
    } catch (Exception e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
}


POST

What's the purpose of capturing an exception there? I can see no cases where you would get one, and even if you get one you want the constructor to fail, as the only failure point would be the line

SUBMITTED

person is nice and want to be friends")
        time.sleep(1)
        print("You have a friend now")
        friends()


def fight_enemy_4(enemy_name, min_enemy_damage, max_enemy_damage, min_player_damage, max_player_damage):
    enemy_damage_dealt = random.randint(min_enemy_damage, max_enemy_damage)
    player_damage_dealt = random.randint(min_player_damage, max_player_damage)

    if enemy_damage_dealt &gt; player_damage_dealt:
        print("Uh-oh! You died!")
        game_over()
    elif enemy_damage_dealt &lt; player_damage_dealt:
        print("You killed the {enemy_name}".format(enemy_name=enemy_name))
        you_killed_him()
    else:
        print("You walk away unscathed, but the {enemy_name} still lives.".format(enemy_name=enemy_name))
        you_killed_him()


def you_killed_him():
    print("You keep walking")


def friends():
    print("You and your friend combined powers")




intro

PRE

Rather than (again) recreating the <code>fight_enemy</code> function to run a different function each time, you can add an additional argument to the end of the function signature, <code>function_to_run</code>. You <code>fight_enemy</code> function would then become this:

MID

def fight_enemy(enemy_name, min_enemy_damage, max_enemy_damage, min_player_damage, max_player_damage, function_to_run):
    enemy_damage_dealt = random.randint(min_enemy_damage, max_enemy_damage)
    player_damage_dealt = random.randint(min_player_damage, max_player_damage)

    if enemy_damage_dealt &gt; player_damage_dealt:
        print("Uh-oh! You died!")
        game_over()
    elif enemy_damage_dealt &lt; player_damage_dealt:
        print("You killed the {enemy_name}".format(enemy_name=enemy_name))
        function_to_run()
    else:
        print("You walk away unscathed, but the {enemy_name} still lives.".format(enemy_name=enemy_name))
        function_to_run()


POST

You're also converting the result of an <code>input</code> call using the <code>str</code> function in many places. This is not needed. You can just call <code>input</code> like this:

SUBMITTED

class ListIterator

PRE

MID

ListIterator

POST

SUBMITTED

messages), a

PRE

MID

a

&lt;a&gt;

POST

SUBMITTED

String piece = "";
        makeTempBoard();
        //System.out.println

PRE

Why would you introduce an own class for the board? Does the board have specific properties and/or methods which should be "bundled" together? I would say: no. 

Copying the ArrayList is fine – but: I would not make a class member for <code>tempBoard</code> but change the signature of <code>makeTempBoard</code> to e.g. <code>ArrayList&lt;String&gt; createTemporaryBoardFrom(ArrayList&lt;String&gt;)</code> and make it static. You really don't need an instance of this class for this operation.

Some more general remarks (not exhaustive):

MID

System.out.println

POST

SUBMITTED

ifndef _TYPE_IDENTIFIER_H_
#define _TYPE_IDENTIFIER_H_

typedef std::size_t Identifier;

class TypeIdentifier {
public:
    template&lt;class T&gt;
    static Identifier get_identifier() {
        static const Identifier current_identifier = ++next_identifier;

        return current_identifier;
    }

private:
    static Identifier next_identifier;
};

Identifier TypeIdentifier::next_identifier = 0;

#endif

PRE

Is in the wrong place. It will be defined for every compilation unit that includes the header. Personally I would use a function rather than a static value.

MID

class TypeIdentifier {
public:
    template&lt;class T&gt;
    static Identifier get_identifier() {
        static const Identifier current_identifier = getNext();
        return current_identifier;
    }

private:
    static Identifier getNext() {
        static Identifier next_identifier = 0;
        return next_identifier++;  //
    }
};


POST

SUBMITTED

show()
    plt.close

PRE

MID

plt.show()

plt.close()

POST

SUBMITTED

e) {
  e.preventDefault();

  if (form.costOfGas.value == '' || 
    form.vehicleMPG.value == '' ||
    form.numMiles.value == '') 
  {
    return;
  } 
  else 
  {
    var userCostOfGas = +form.costOfGas.value

PRE

Choose one and stick with it: it makes your code a lot more clean. Personally, I like to use the first version.

Here, you are checking to make sure that the form is not blank:

MID

if (form.costOfGas.value == '' || 
  form.vehicleMPG.value == '' ||
  form.numMiles.value == '') 
{


However, there is a much, much easier way to do this: using the <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input" rel="nofollow noreferrer"><code>required</code> HTML attribute</a> (scroll down for the "required" section)

By adding a blank <code>required</code> attribute to each of the input elements of your form, you can safely remove this chunk of code from your JavaScript; the user will no longer be able to submit the form unless they have entered data in each field.

Here, you are using the <code>+</code> operator to convert a string to a number:

var userCostOfGas = +form.costOfGas.value;


While this is a neat little JavaScript trick, it looks like it's more for if you were creating this code for a code golf: it is very unclear as to what this is doing.

To make this more clear, use the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt" rel="nofollow noreferrer"><code>parseInt</code></a> function:

var userCostOfGas = parseInt(form.costOfGas.value, 10);


It looks to me that, since you are attempting to turn the form input fields from a string into a number, that you are using input fields of the type text.

By doing it this way, you are forcing yourself to take that extra step of converting the input to a number type. It would a lot easier if you set the <code>type</code> attribute of your input fields to <code>"number"</code>.

That way, when you go to get the value of the input fields, they will already be of the correct type.

Good job using <code>toFixed</code> on the output: it makes the formatting of numbers very clean.

You have a few <a href="https://stackoverflow.com/questions/47882/what-is-a-magic-number-and-why-is-it-bad">magic numbers</a> in your code, especially in the <code>calcCost</code> function:

var dailyCost = (costOfGas / vehicleMPG) * (numMiles * 2);
var weeklyCost = dailyCost * 5;
var monthlyCost = weeklyCost * 4;


POST

Where did the <code>2</code> come from? What about the <code>5</code>? And the <code>4</code>?

To make your code more readable and understandable, you should declare constants at the top of your code, and then use the constants in place of these mysterious numbers.

Here, I've created a few for you:

SUBMITTED

False
player_aboveground

PRE

MID

player_aboveground

POST

SUBMITTED

MessageBox.Show("Game Over! O Wins!");
            ResetGame();
        }
        else if (but3.Text == "O" &amp;&amp; but5.Text == "O" &amp;&amp; but7.Text == "O")
        {
            MessageBox.Show("Game Over! O Wins!");
            ResetGame();
        }
    }

    public void Tie()
    {
        if (but1clicked == true &amp;&amp;
            but2clicked == true &amp;&amp;
            but3clicked == true &amp;&amp; 
            but4clicked == true &amp;&amp; 
            but5clicked == true &amp;&amp; 
            but6clicked == true &amp;&amp; 
            but7clicked == true &amp;&amp; 
            but8clicked == true &amp;&amp; 
            but9clicked == true)
        {
            MessageBox.Show("You

PRE

The buttons should be an array, if so you will replace <code>btn</code> with <code>buttons[1]</code>. Using the array will allow replacing this:

MID

    if (but1clicked == true &amp;&amp;
        but2clicked == true &amp;&amp;
        but3clicked == true &amp;&amp; 
        but4clicked == true &amp;&amp; 
        but5clicked == true &amp;&amp; 
        but6clicked == true &amp;&amp; 
        but7clicked == true &amp;&amp; 
        but8clicked == true &amp;&amp; 
        but9clicked == true)


POST

With this:

SUBMITTED

node

PRE

MID

node

POST

SUBMITTED

list left right)
                (splitr (cdr l) right (cons (car l) left)))))
        (splitr l '() '())))
    (cond
      ((null? l) l)
      ((null? (cdr l)) l)
      (else (let* ((parts (split l))
                   (left (car parts))
                   (right (cadr parts)))
              (merge (mergesort left cmp)
                     (mergesort right cmp

PRE

The inner function <code>splitr</code> could be reformulated using a named <code>let</code>, which is more idiomatic in Scheme:

MID

(define (split l)
  (let loop ((l l)
             (left '())
             (right '()))
    (if (null? l)
        (list left right)
        (loop (cdr l) right (cons (car l) left)))))


POST

SUBMITTED

letters in place
***********************************/
void draw (char guess[],int xc)
{

    if (guess[0]=='a')
   {
        gotoxy((xc*6)+3,15);
      cout &lt;&lt; " ___";
    gotoxy((xc*6)+3,16);
      cout &lt;&lt; "|   |";
    gotoxy((xc*6)+3,17);
      cout &lt;&lt; "|___|";
      gotoxy((xc*6)+3,18);
      cout &lt;&lt; "|   |";
      gotoxy((xc*6)+3,19);
      cout &lt;&lt; "|   |";
   }
   if (guess[0]=='b')
    {
        gotoxy((xc*6)+3,15);
      cout &lt;&lt; " ___";
    gotoxy((xc*6)+3,16);
      cout &lt;&lt; "|   \\";
    gotoxy((xc*6)+3,17);
      cout &lt;&lt; "|___/";
      gotoxy

PRE

<strong>Data oriented programming</strong>

The following block of code is repated with little differences 26 times:

MID

    if (guess[0]=='a')
   {
    gotoxy((xc*6)+3,15);
  cout &lt;&lt; " ___";
gotoxy((xc*6)+3,16);
  cout &lt;&lt; "|   |";
gotoxy((xc*6)+3,17);
  cout &lt;&lt; "|___|";
  gotoxy((xc*6)+3,18);
  cout &lt;&lt; "|   |";
  gotoxy((xc*6)+3,19);
  cout &lt;&lt; "|   |";


POST

To print all the letters. I suggest loading the ascii art from a file, as code and resources (ascii art in this case) should be separated.

The same can be said about:

SUBMITTED

exit
    end
end

def move_left?
    sum  = @track_move.inject{|r, s| r + s}
    if sum == 36
       return true
    end
end

def check_win?
    player = @current
    symbol = @symbol
    if board[0][0] == symbol &amp;&amp; 
       board

PRE

Actually I would have chosen a bool as return value, not <code>winner_player</code>

<strong>About <code>move_left?</code></strong>

MID

 def move_left?
     sum  = @track_move.inject{|r, s| r + s}
     if sum == 36
       return true
     end
end


POST

SUBMITTED

public static DateTime ParseDateTime(string dateString)
    {
        DateTime dateTime;
        if (!DateTime.TryParse(dateString, CultureInfo.InvariantCulture, DateTimeStyles.AssumeUniversal, out dateTime))
        {
            if (!DateTime.TryParse(dateString, CultureInfo.CurrentCulture, DateTimeStyles.AssumeUniversal, out dateTime))
            {
                try
                {
                    dateTime = DateTime.Parse(dateString, CultureInfo.InvariantCulture, DateTimeStyles.AssumeLocal);
                }
                catch (FormatException)
                {
                    // Try to extract at least year from the string (the longest

PRE

I would say it's generally not fruitful to accept <em>any</em> kind of format from the user, and then go through a series of exercices to try and normalize the input.
You're better off just restricting input to be, for example, <a href="https://en.wikipedia.org/wiki/ISO_8601" rel="nofollow">ISO 8601</a> compliant.

A couple more things to consider:

Regarding coding style, consider inverting the first two conditions to avoid nested code

MID

if (DateTime.TryParse(dateString, CultureInfo.InvariantCulture, DateTimeStyles.AssumeUniversal, out dateTime))
    return dateTime;

if (DateTime.TryParse(dateString, CultureInfo.CurrentCulture, DateTimeStyles.AssumeUniversal, out dateTime))
    return dateTime;

try ...


POST

SUBMITTED

in range

PRE

MID

range

for i in range(3):

POST

SUBMITTED

static void Main(string[] args)
{
    var listCancellationTokens = new List&lt;CancellationTokenSource&gt;();

    for (var

PRE

Basically it is in its current state senseless to have a  

MID

var listCancellationTokens = new List&lt;CancellationTokenSource&gt;();  


POST

if all you want is <strong>one</strong> running thread at any time.  

So what I suggest instead is to create <strong>one</strong> <a href="https://msdn.microsoft.com/en-us/library/system.threading.tasks.task%28v=VS.110%29.aspx" rel="nofollow"><code>Task</code></a> and if there comes the situation that this task should be canceled you should cancel the task and <a href="https://msdn.microsoft.com/en-us/library/dd321315%28v=vs.110%29.aspx" rel="nofollow"><code>Wait</code></a> until the task returned.  

After the <code>Task</code> returned you then create the new <code>Task</code>.  

SUBMITTED

os.system

PRE

You can do a great deal more with <code>str.format</code>, but I'll leave it up to you to figure that out, as there's too much for this one post.

MID

system

POST

I find all of these lines of code to be absolutely horrid:

SUBMITTED

bitIndex = 0; bitIndex &lt;= rootBitIndex; bitIndex++)
        {
            if (rootVector[bitIndex])
            {
                var prime32 = ToNumber(bitIndex, Three);
                yield return prime32;
                // If prime, all of its multiples - on all vectors - are composites and should be marked as such.
                MarkCompositesInParallel(bitIndex, prime32);
            }
        }

        // output remaining primes 
        for (var vectorIndex = 0; vectorIndex &lt; _vectors.Count; vectorIndex++)
        {
            var vector = _vectors[vectorIndex];
            var startIndex = (vectorIndex == 0) ? rootBitIndex + 1 : 0;
            // Due to high frequency of access, its ever so slightly faster to have copies created outside the loop
            // rather than called inside the loop directly and repeatedly with vector.BitLength and vector.StartingNumber.
            var length = vector.BitLength;
            var startingNumber = vector.StartingNumber;
            for (var bitIndex = startIndex; bitIndex &lt; length; bitIndex++)
            {
                if (vector[bitIndex]) { yield return ToNumber(bitIndex, startingNumber); }
            }
        }
    }

    private void MarkCompositesInParallel(int bitIndex, uint prime32)
    {
        Parallel.For(0, _vectors.Count, vectorIndex =&gt;
        {
            var vector = _vectors[vectorIndex];
            var startIndex = 0;
            var stopIndex = vector.BitLength - 1;

            if (vectorIndex == 0)
            {
                // startIndex may be calculated way past the BitLength of the vector.
                // That's okay as

PRE

This doesn't have much effect on the results, but I saw times drop further from 3653ms to 3622ms (5 run average).

Apart from the few micro-optimizations above, one of the issues I see with your code is just how <em>packed</em> it is.

For example, this is hard to read:

MID

// output remaining primes 
for (var vectorIndex = 0; vectorIndex &lt; _vectors.Count; vectorIndex++)
{
    var vector = _vectors[vectorIndex];
    var startIndex = (vectorIndex == 0) ? rootBitIndex + 1 : 0;
    // Due to high frequency of access, its ever so slightly faster to have copies created outside the loop
    // rather than called inside the loop directly and repeatedly with vector.BitLength and vector.StartingNumber.
    var length = vector.BitLength;
    var startingNumber = vector.StartingNumber;
    for (var bitIndex = startIndex; bitIndex &lt; length; bitIndex++)
    {
        if (vector[bitIndex]) { yield return ToNumber(bitIndex, startingNumber); }
    }
}


It's <em>ever so slightly</em> easier to follow with a little more whitespace:

// output remaining primes 
for (var vectorIndex = 0; vectorIndex &lt; _vectors.Count; vectorIndex++)
{
    var vector = _vectors[vectorIndex];
    var startIndex = (vectorIndex == 0) ? rootBitIndex + 1 : 0;
    // Due to high frequency of access, its ever so slightly faster to have copies created outside the loop
    // rather than called inside the loop directly and repeatedly with vector.BitLength and vector.StartingNumber.
    var length = vector.BitLength;
    var startingNumber = vector.StartingNumber;

    for (var bitIndex = startIndex; bitIndex &lt; length; bitIndex++)
    {
        if (vector[bitIndex])
        {
            yield return ToNumber(bitIndex, startingNumber);
        }
    }
}


POST

As far as your general questions:

But then there’s the constants <code>Zero</code>, <code>One</code>, <code>Two</code>, and <code>Three</code>. Are they magic numbers, or even if they aren't, is it overkill to use this?

The problem with having these constants is that the name of the constant doesn't imply what it <em>means</em>, but instead what it <em>is</em>. This means that any usage of them within the code is meaningless, as the only thing we know about them is that <code>Zero</code> is a <code>uint</code> valued at <code>0</code>. If this is all the magic numbers are for, then having a constant adds absolutely <em>no</em> value to the code. It's only noise.

When you use the <code>Find All References</code> feature, it should be clear that each instance of that constant, property, field, method, class, struct, etc. is used in a <em>specific</em> scenario. However, these constants are not. So what is the point? I don't actually <em>care</em> about what references the constant <code>Zero</code>, so why is it a constant? Would I ever <em>need</em> to change it? No, so there's no value added.

Should there be a Vector.Id property?

Should VectorList have a RootVector property?

Using Three instead of rootVector.StartingNumber

All three of these have the same response:

Properties exist to allow is to idiomatically access information within them. By <em>not</em> using/creating properties, you fall into the trap of having to remember <em>just exactly what</em> the operation means. So, for:

SUBMITTED

function):
        def wrapper(*args, **kwargs):
            if self.debug:
                if getargspec(function).args[0] != "self":
                    print(self.__format_debug_string(function, *args, **kwargs))
                else:
                    print(self.__format_debug_string(function, *args, **kwargs))
                    print("[debug] Parent attributes: {}".format(pformat(args[0].__dict__)))

            return function(*args, **kwargs)
        return wrapper

PRE

You can improve the following:

MID

            if getargspec(function).args[0] != "self":
                print(self.__format_debug_string(function, *args, **kwargs))
            else:
                print(self.__format_debug_string(function, *args, **kwargs))
                print("[debug] Parent attributes: {}".format(pformat(args[0].__dict__)))


If the code is executed no matter the statement, and it always goes first, move it above the condition: (and don't forget to reverse the condition)

            print(self.__format_debug_string(function, *args, **kwargs))
            if getargspec(function).args[0] == "self":
                print("[debug] Parent attributes: {}".format(pformat(args[0].__dict__)))


As for this:

    debug_string = ""
    debug_string += "[debug] {}\n".format(pformat(function))
    debug_string += "[debug] Passed args: {}\n".format(pformat(args))
    debug_string += "[debug] Passed kwargs: {}\n".format(pformat(kwargs))
    debug_string += "[debug] Locals: {}".format(pformat(function.__code__.co_varnames))
    return debug_string


You can remove the <code>= ""</code> entirely:

    debug_string =  "[debug] {}\n".format(pformat(function))
    debug_string += "[debug] Passed args: {}\n".format(pformat(args))
    debug_string += "[debug] Passed kwargs: {}\n".format(pformat(kwargs))
    return debug_string + "[debug] Locals: {}".format(pformat(function.__code__.co_varnames))


It may not look as visually stimulating, but, it's not as redundant.

Is it a good idea to create an empty string, and then add to, and re-assign it to build an output string?

If you were directly printing these then it would be a bad idea, but in this case, not really. However, I suppose you could move them to an object, or an array and return the result of a <code>join</code> function.

You could even return it as an array, and print each <code>[debug]</code> result. Which would remove the need for the <code>\n</code>s at the end, and DRY up the <code>[debug]</code> at the beginning of the strings (<em>put it in the loop, not altogether</em>)

You've got a few too long lines, by PEP8 standard:

debug -- Whether or not you want to output debug info. Generally, a global DEBUG variable is passed in here.
debug_string += "[debug] Locals: {}".format(pformat(function.__code__.co_varnames))
print(self.__format_debug_string(function, *args, **kwargs))
print("[debug] Parent attributes: {}".format(pformat(args[0].__dict__)))


POST

As for your documentation:

SUBMITTED

size];

    for

PRE

MID

for (...

POST

SUBMITTED

util.Scanner

PRE

MID

Scanner

Scanner

POST

SUBMITTED

int getint(int *pn)
{
   int c, sign;

   while(isspace(c = getch()))
      ;

   if(c == EOF)
      return EOF;

   if(!isdigit(c) &amp;&amp; c != '+' &amp;&amp; c != '-')
      return 0;

   sign = (c == '-') ? -1 : 1;

   if(c == '+' || c == '-')
      c = getch();

   if(!isdigit(c)) {
      ungetch(c);
      return 0;
   }

   *pn = 0;
   while(isdigit(c)) {
      *pn = *pn * 10 + c - '0';
      c = getch();
   }

   *pn *= sign;
   ungetch(c);

   return

PRE

But portably using <code>ungetc()</code> twice in a row is not guaranteed.

One character of pushback is guaranteed. If the <code>ungetc</code> function is called too many times on the same stream without an intervening read or file positioning operation on that stream, the operation may fail.  C11dr §7.21.7.10 3

Since code really should "unget" 2 characters (<code>+/-</code> and the following non-digit), but it is not portable - what to do?  Since many systems <em>do</em> support pushing back more than 1 character with restrictions, consider attempting it.  

Of course, all the consumed white-space characters are not push-backed either.  Yet pushing back the sign is prudent - many systems do this with <code>scanf("%d", ...)</code>.

Checking the return value of <code>ungetc()</code> would discern success.  A slight variation follows:

MID

int c;
int sign = EOF;

while(isspace(c = getch()))
  ;
if(c == EOF)
  return EOF;
sign = c;
if (sign == '+' || sign == '-') 
  c = getch();

if (!isdigit(c)) {
  ungetch(c);  // Pedantic code would check this return value.
  if (sign == '+' || sign == '-') {
    // attempt to push-back sign
    if (ungetch(sign) == EOF) {
      ; // Operation failed
    }
  }
  return 0;
}

...

if (sign == '-') *pn = -(*pn);


POST

Other code issues:

Code does not detect overflow.

Code unnecessarily overflows when scanning <code>INT_MIN</code>.  <a href="https://stackoverflow.com/a/26228157/2410359">parse_int(char **s)</a> offers a candidate solution.

Code does not differentiate between an <code>EOF</code> received from <code>getch()</code> due to end-of-file and input error.  Coding goal is "return EOF when <em>end of file</em> is reached".  OTOH, code has no specification concerning input error, so returning <code>EOF</code> for both conditions is reasonable.

SUBMITTED

__init__(o

PRE

MID

o

POST

SUBMITTED

sum) { 
          if

PRE

(and similarly for the iterative versions).

Some advice from the answers to your previous question <a href="https://codereview.stackexchange.com/questions/105078/dfs-in-binary-tree">DFS in Binary Tree</a>
applies here as well:

MID

if

POST

SUBMITTED

shift_x,
        point_y = 2 * y - shift_y;
    if(
            point_x &gt;= width
        ||
            point_x &lt; 0
        ||
            point_y &gt;= height
        ||
            point_y &lt; 0
    )
        return;
    glPushMatrix();                                         
    glTranslatef(point_x, point_y, 0);                      
    glBegin(GL_QUADS

PRE

This OpenGL+GLUT API that you're using is the <a href="https://www.opengl.org/wiki/Legacy_OpenGL" rel="nofollow">legacy, AKA fixed-function, OpenGL</a>. It is an alright option for learning the basics of 2D/3D hardware accelerated graphics, but... nobody uses it anymore, that's why it's called legacy :P. Graphics hardware has evolved A LOT since the first release of OpenGL, some 20-ish years ago, so it is only natural that the API has evolved and changed a lot in the process too. Todays graphics take advantage of the so called "programable pipeline", meaning you actually write programs in a <a href="https://en.wikipedia.org/wiki/Shading_language" rel="nofollow"><em>shading language</em></a> that run directly on the GPU.

Once you get more or less familiar with the basics, I suggest that you take the leap to modern GL at once (<strong>aim OpenGL version 3 and above</strong>), since there's not much point in learning the finer aspects of an outdated technology (apart from retro-programming exercises, of course). At first you might find it a bit daunting to see the amount of extra work needed to get a simple triangle to draw on screen with OpenGL 3+, and that's the way it is. GL has become a much lower-level API for the sake of perfomance. That's not a bad thing really, because there are dozens of high-level libraries built on top of it to choose from if you just want some quick 2D/3D drawing, leaving GL for the high-perf, low-level crew. Nevertheless, I suggest you do take a look at a couple tutorials of modern OpenGL to get a feel for it and better understand the 3D pipeline, even if in the end you just want something simple and easy to set up and switch to some high-level framework.

It would be nice to use a class, even if this is a <code>main.cpp</code>-only kind of program. That avoids the bad habit of global variables and keeps the code (hopefully) better organized.

<code>DrawPoint</code>: 

It takes <code>x</code> and <code>y</code> by reference, but that's not necessary, since the function doesn't change those parameters.

Also this formatting is not very practical:

MID

if(
        point_x &gt;= width
    ||
        point_x &lt; 0
    ||
        point_y &gt;= height
    ||
        point_y &lt; 0
)


POST

That statement isn't even that long, it could be all in the same line, or breaking once at most.

All that <code>string</code>ification here is only creating temporary instances of strings that get discarded right away.

SUBMITTED

Makefile
   |--fonts--|--StarStrips.c
   |         |--whimsy.c
   |
   |           |--core.h 
---|--include--|--StarStrips.h
   |           |--whimsy.h
   |
   |--Makefile

PRE

<strong>fonts/Makefile</strong>

Each object depends only on the corresponding source. It means that header modifications wouldn't trigger recompilation. You may fix it by explicitly spelling out dependencies:

MID

whimsy.o: whimsy.c whimsy.h core.h


POST

In general it is a good habit to have dependencies auto generated: even in your not very complicated case it is easy to miss the <code>core.h</code> dependency. Take a look at <code>-M</code> family of <code>gcc</code> options.

<strong>include/whimsy.h</strong>

Do not <em>define</em> objects (like <code>struct font whimsy</code>) in the header file. You never know how many times the client would happen to <code>#include "whimsy.h"</code> in different places of their project. Better practice is to have the <em>definition</em> in the <code>.c</code> file, and <em>declare</em> it in the header as

SUBMITTED

gt; [Integer]
sieveSundaram n = map (\x -&gt; 2 * x + 1) (genSieve n)
  where
    valid x = (i &lt;= j

PRE

you know that <code>y = foldr h y []</code>, so use this to determine what <code>g0</code> is.

Stylistically I would use list comprehensions as much as possible - replacing <code>map</code> and <code>filter</code>.

Instead of:

MID

sieveSundaram n = map (\x -&gt; 2 * x + 1) (genSieve n)


I would write:

sieveSundaram n = [ 2*x+1 | x &lt;- genSieve n]


POST

and instead of:

SUBMITTED

lt;/legend&gt;

        &lt;label for

PRE

MID

&lt;label&gt;

&lt;input&gt;

&lt;button&gt;

&lt;textarea&gt;

&lt;img&gt;

&lt;img&gt;

POST

SUBMITTED

fub

for ((i=1; i&lt;term; i++))
do
  third=$((fub+third))
  echo

PRE

If you were to apply this code to your picture above, simply replace all instances of <code>fub</code> with <code>second</code>.

Edit:

The modified code should display <code>2*term-2 numbers</code>, (Your code as it is now displays more, <code>2*term+1</code> numbers)

To change this so it only displays <code>term</code> numbers, change <code>term</code> so it's the proper upper limit after you've read it.

So, the code could look something like this:

MID

for ((i=1; i&lt;term/2+1; i++))


POST

Tested it and yes, the code does work.

SUBMITTED

tests/new

PRE

MID

new

POST

SUBMITTED

char buffer[MAX_BUFFER+1] = { 0 };
    ret = sock.recv(buffer, MAX_BUFFER

PRE

So when you need to receive some data, it'll just look like:

MID

ret = sock.recv(buffer);


POST

Then I'd rewrite <code>msg_ok</code> a bit. Right now it has:

SUBMITTED

cstdio&gt;
#include &lt;iostream&gt;

std::string rot47(std::string s

PRE

You're not using either of those, so remove them, and include <code>&lt;string&gt;</code> instead to get <code>std::string</code>.

MID

std::string rot47(std::string s) { /* ... */ }


Why copy the caller's string? You're only reading from it, so take it by <code>const&amp;</code>.

std::string s1 = "!\"#$%&amp;\...";
std::string s2 = "PQRSTUVW...";


These two are constant, don't allocate them for every call, make them static (and const):

static std::string const s1 = "...";


std::string ret = "";


POST

That initialization is not necessary, a default-constructed string is empty. You might want to <code>reserve</code> the appropriate size since you know it though, for optimal performance.

SUBMITTED

Function getValues(catAttIDs As List(Of Integer), itemID As Integer) As List(Of String)
    Dim db As New Model1
    Dim values = New List(Of String)

    For i As Integer = 0 To catAttIDs.Count - 1
        Dim catAttID = catAttIDs(i)

        Dim currentValue = (From row In db.tblEquipment_Attributes
                     Where row.Category_Attribute_Identifier = catAttID _
                     And row.Unique_Item_ID = itemID
                     Select row.Value).SingleOrDefault()

        values.Add(currentValue)
    Next

    Return values
End Function

PRE

So what you could do is write your LINQ statement to see if the Category_Attribute_Identifier is in the list. Then your function will look something like this:

MID

Function getValues(catAttIDs As List(Of Integer), itemID As Integer) As List(Of String)
    Dim db As New Model1

    Dim currentValues as List(Of String) = (From row In db.tblEquipment_Attributes
                     Where catAttIDs.Contains(row.Category_Attribute_Identifier) _
                     And row.Unique_Item_ID = itemID
                     Select row.Value).ToList()

    Return currentValues
End Function


POST

Note that ToList will create a <code>List&lt;T&gt;</code>, where T is the type of the elements. As long as Value in your db is a varchar, it'll be a List.

SUBMITTED

draw_amount

PRE

MID

draw_amount

POST

SUBMITTED

public interface AxisEvent extends Event

PRE

Again, if the pollTask can be different after each start, then a pollTaskFactory would be passed in instead.

If I were implementing this library, I'd want to go the extra mile to use a <a href="http://blog.crisp.se/2013/10/09/perlundholm/another-builder-pattern-for-java" rel="nofollow">Fluent Builder</a>.  And I would also consider <code>setLinearDeadzone</code> and <code>setRadialDeadzone</code> -- a Fluent Builder, or a <em>family</em> of Fluent Builders, can take a lot of the burden off of your clients without necessarily removing the flexibility offered by the generic interface.

MID

public interface Event {
    long getTime();
}


POST

If all of your events are going to be handling time the same way, then you should probably be implementing an <code>AbstractEvent</code> that manages that for you.  

SUBMITTED

True
    else

PRE

MID

else:

POST

SUBMITTED

in a

PRE

MID

^a

POST

SUBMITTED

GetUser(name, false) == null)
                {
                    MembershipCreateStatus status = new MembershipCreateStatus();
                    memProv.CreateUser(name, password, email,
                        "none", // password question
                        "none", // password answer
                        true,   // isApproved
                        null,   //
                        out status);
                    Debug.Assert(status.Equals(MembershipCreateStatus.Success));

                    // Assign the roles to the user.
                    if (rolenames[0] != "")
                        roleProvider.AddUsersToRoles

PRE

Note that this means it's much harder to confuse which array index contains which value and you can (and should) use types other than <code>string</code>.

(The incorrect indentation in the original code is due to <a href="https://codereview.meta.stackexchange.com/q/5063/2041">a bug</a>.)

MID

MembershipCreateStatus status = new MembershipCreateStatus();
memProv.CreateUser(name, password, email,
    "none", // password question
    "none", // password answer
    true,   // isApproved
    null,   //
    out status);


You don't need to initialize <code>out</code> variables. (And <code>new</code>ing up an <code>enum</code> doesn't make much sense either.)

Instead of comments, you should use named arguments, that way, the compiler verifies the names for you (comments can be wrong, code can't).

Put together:

MembershipCreateStatus status;
memProv.CreateUser(name, password, email,
    passwordQuestion: "none",
    passwordAnswer: "none",
    isApproved: true,
    providerUserKey: null,
    status: out status);


POST

SUBMITTED

class Program
{
    static void Main(string[] args)
    {
        List&lt;IVisitor&gt; visitors = new List&lt;IVisitor&gt;();
        visitors.AddRange(new List&lt;IVisitor&gt;()
        {
            new PersonVisitor(),
            new AnimalVisitor()
        });

        List&lt;Creature&gt; creatures = new List&lt;Creature&gt;();
        creatures.AddRange(new List&lt;Creature&gt;()
        {
            new Person() { Name = "Frank" },
            new Person() { Name = "Tony" },
            new Person() { Name = "Amy" },
            new Animal() { Name = "Bubbles" },
            new Animal() { Name = "Max" }
        });

        CreatureProcessor creatureProcessor = new CreatureProcessor(creatures, visitors);
        creatureProcessor.Process();

        Console.ReadKey();
    }
}

interface IVisitor
{
    void Visit(IElement element);
}

interface IElement
{
    void Accept(IVisitor visitor);
}

class PersonVisitor : IVisitor
{
    public void Visit(IElement element)
    {
        if (element is Person)
        {
            Creature creature = element as Person;

            Console.WriteLine("{0} is a good {1}", creature.Name, "Person");
        }
    }
}

class AnimalVisitor : IVisitor
{
    public void Visit(IElement element)
    {
        if (element is Animal)
        {
            Creature creature = element as Animal;

            Console.WriteLine("{0} is a good {1}", creature.Name, "Animal");
        }
    }
}

class Person : Creature
{

}

class Animal : Creature
{

}

abstract class Creature : IElement
{
    public string Name { get; set; }

    public void Accept(IVisitor visitor)
    {
        visitor.Visit(this);
    }
}

class CreatureProcessor
{
    private readonly List&lt;IVisitor&gt; visitors;
    private readonly List&lt;Creature&gt; creatures;        

    public CreatureProcessor(List&lt;Creature&gt; creatures, List&lt;IVisitor&gt; visitors)
    {
        this.creatures = creatures;
        this.visitors = visitors;
    }

    public void Process()
    {
        foreach (IVisitor visitor in visitors)
        {
            foreach (Creature creature in creatures)
            {
                creature.Accept(visitor

PRE

MID

internal abstract class Creature
{
    protected Creature(string name)
    {
        Name = name;
    }

    public string Name { get; }

    public abstract void Accept(ICreatureVisitor visitor);
}

internal sealed class Person : Creature
{
    public Person(string name)
        : base(name)
    {
    }

    public override void Accept(ICreatureVisitor visitor)
    {
        visitor.Visit(this);
    }
}

internal sealed class Animal : Creature
{
    public Animal(string name)
        : base(name)
    {
    }

    public override void Accept(ICreatureVisitor visitor)
    {
        visitor.Visit(this);
    }
}

internal interface ICreatureVisitor
{
    void Visit(Person person);
    void Visit(Animal animal);
}

internal sealed class PrintIsGoodVisitor : ICreatureVisitor
{
    public void Visit(Person person)
    { 
        Console.WriteLine("{0} is a good {1}", person.Name, "Person");
    }

    public void Visit(Animal animal)
    {
        Console.WriteLine("{0} is a good {1}", animal.Name, "Animal");
    }
}

internal sealed class Program
{
    public static void Main(string[] args)
    {
        var visitors = new List&lt;ICreatureVisitor&gt;
        {
            new PrintIsGoodVisitor()
        };

        var creatures = new List&lt;Creature&gt;
        {
            new Person(name: "Frank"),
            new Person(name: "Tony"),
            new Person(name: "Amy"),
            new Animal(name: "Bubbles"),
            new Animal(name: "Max")
        };

        VisitAllCreatures(visitors, creatures);

        Console.ReadKey();
    }

    private static void VisitAllCreatures(IReadOnlyCollection&lt;ICreatureVisitor&gt; visitors, IReadOnlyCollection&lt;Creature&gt; creatures)
    {
        foreach (var visitor in visitors)
        {
            foreach (var creature in creatures)
            {
                creature.Accept(visitor);
            }
        }
    }
}


POST

SUBMITTED

Object value = field.get(this);

                lineBuilder.append(" = ");
                lineBuilder.append(value

PRE

Note that this is adding to @EricStein's excellent answer on normal concatenation instead of <code>StringBuilder</code>s. 

(I'm just starting to look into <code>Streams</code>, so if this is bad, please comment on why)

Otherwise...

Just a small comment:

MID

lineBuilder.append(" = ");
lineBuilder.append(value);


can easily be:

lineBuilder.append(" = ").append(value);


Same with:

lineBuilder.append(" &gt; ");
lineBuilder.append(e.getClass().getSimpleName());


becomes:

lineBuilder.append(" &gt; ").append(e.getClass().getSimpleName());


POST

Also, I would use a simple array instead of an <code>ArrayList</code>:

SUBMITTED

float3 dirLightDir                          : register(c12);
        float xCoordMultiplication                  : register (c13);
        float yCoordMultiplication                  : register (c14);

        struct VsInput
        {
            float4 position

PRE

Late response to this, but all I can suggest is leveraging the per-component math of HLSL better in your shaders...

Vertex Shader

MID

    float xCoordMultiplication                  : register (c13);
    float yCoordMultiplication                  : register (c14);


Make that a float2

    float2 xyCoordMultiplier   : register (c13) : register (c14);


POST

I think that's how you tie two different registers to one global. Might want to double check MSDN HLSL reference to be sure, though.

With your xy multiplier now a float 2, you can change this...

SUBMITTED

main

PRE

MID

main()

main()

POST

SUBMITTED

x",y,) #Multiplication question asked
                 answer = int(input("Answer")) #Students answer
                 if correct == answer: #If it is the correct answer
                       print("That is the correct answer") #response for correct answers
                       score = score + 1 #Adds 1 to the score
                 else: #If its is an incorrect answer
                       print("That is incorrect, the correct answer is",correct) #Response to an incorrect answer
              if sign == 3: #If statement for a multiplication question
               correct = x - y #Calculates the correct answer
               print("What is",x,"-",y,) #Subtraction question asked
               answer = int(input("Answer")) #Students answer
               if correct == answer:
                  print("That is the correct answer")
                  score = score + 1
               else:
                  print("That is incorrect, the correct answer is",correct)
        print (name,"your total score is",score)
        student_3 = group, name, score
    if group == "3":
        input ("are you a student")
        name = input("What is your name") #Asks the user to enter their name
        print("Hello",name) #Prints a wlcome message to the user
        score = 0 #Sets the starting score to 0
        times = 0 #Sets the number of answered questions to 0
        while times &lt;= 9: #While loop set up so that 10 questions are asked
              times = times + 1 #Adds 1 to the number of questions asked
              print("#",times) #Prints how many questions have been answered
              x = random.randrange(1,10) #Randomises the first number in the question
              y = random.randrange(1,10) #Randomises the second number in the question
              sign = random.randrange(1,4) #Randomises the sign for the question
              if sign == 1: #If statement for an addition question
                correct = x + y #Calculates the correct answer
                print("What is",x,"+",y,) #Addition question asked
                answer = int(input("Answer")) #Students answer
                if correct == answer: #If it is the correct answer
                    print("That is the correct answer") #response for correct answers
                    score = score + 1 #Adds 1 to the score
                else: #If its is an incorrect answer
                  print("That is incorrect, the correct answer is",correct) #Response to an incorrect answer
              if sign == 2: #If statement for a subtraction question
                correct = x * y #Calculates the correct answer
                print("What is",x,"x",y,) #Multiplication question asked
                answer = int(input("Answer")) #Students answer
                if correct == answer: #If it is the correct answer
                       print("That is the correct answer") #response for correct answers
                       score = score + 1 #Adds 1 to the score
                else: #If its is an incorrect answer
                       print("That is incorrect, the correct answer is",correct) #Response to an incorrect answer
              if sign == 3: #If statement for a multiplication question
                correct = x - y #Calculates the correct answer
                print("What is",x,"-",y,) #Subtraction question asked
                answer = int(input("Answer")) #Students answer
                if correct == answer:
                  print("That is the correct answer")
                  score = score + 1
                else:
                  print("That is incorrect, the correct answer is",correct)
        print (name,"your total score is",score)
        student_3 = group, name, score

PRE

I'd say half, if not more of your code is repeated.

Make use of <strong>functions</strong> to avoid repetition!

You're doing the same thing 3 times, the only difference being the <code>student_*</code> variable:

MID

def quiz(group):
    name = input(&quot;What is your name&quot;) #Asks the user to enter their name
    print(&quot;Hello&quot;,name) #Prints a wlcome message to the user
    score = 0 #Sets the starting score to 0
    times = 0 #Sets the number of answered questions to 0
    while times &lt;= 9: #While loop set up so that 10 questions are asked
          times = times + 1 #Adds 1 to the number of questions asked
          print(&quot;#&quot;,times) #Prints how many questions have been answered
          x = random.randrange(1,10) #Randomises the first number in the question
          y = random.randrange(1,10) #Randomises the second number in the question
          sign = random.randrange(1,4) #Randomises the sign for the question
          if sign == 1: #If statement for an addition question
            correct = x + y #Calculates the correct answer
            print(&quot;What is&quot;,x,&quot;+&quot;,y,) #Addition question asked
            answer = int(input(&quot;Answer&quot;)) #Students answer
            if correct == answer: #If it is the correct answer
                print(&quot;That is the correct answer&quot;) #response for correct answers
                score = score + 1 #Adds 1 to the score
            else: #If its is an incorrect answer
              print(&quot;That is incorrect, the correct answer is&quot;,correct) #Response to an incorrect answer
          if sign == 2: #If statement for a subtraction question
             correct = x * y #Calculates the correct answer
             print(&quot;What is&quot;,x,&quot;x&quot;,y,) #Multiplication question asked
             answer = int(input(&quot;Answer&quot;)) #Students answer
             if correct == answer: #If it is the correct answer
                   print(&quot;That is the correct answer&quot;) #response for correct answers
                   score = score + 1 #Adds 1 to the score
             else: #If its is an incorrect answer
                   print(&quot;That is incorrect, the correct answer is&quot;,correct) #Response to an incorrect answer
          if sign == 3: #If statement for a multiplication question
           correct = x - y #Calculates the correct answer
           print(&quot;What is&quot;,x,&quot;-&quot;,y,) #Subtraction question asked
           answer = int(input(&quot;Answer&quot;)) #Students answer
           if correct == answer:
              print(&quot;That is the correct answer&quot;)
              score = score + 1
           else:
              print(&quot;That is incorrect, the correct answer is&quot;,correct)
    print (name,&quot;your total score is&quot;,score)
    return (group, name, score)


POST

Comments are good, but too many gets tedious. Only use comments when the code is doing something that isn't self explanatory.

Example:

etc... All of these are <em>obvious!</em> They are unlikely to help <em>anyone</em> -- even yourself! So get rid of them

<code>name = input(&quot;What is your name&quot;)</code>

Leave a space after that last letter so when the program is running, you're not typing right next to the question. And add a question mark! :)

<code>if group == &quot;1&quot;:</code>

If you're looking for an integer, <em>look for an integer.</em> So when you make the <code>group</code> variable, <code>try</code> to make it an integer:

SUBMITTED

current
      exit

PRE

MID

exit

POST

SUBMITTED

maxSec = 59,
        maxMin = 59,
        maxHour = 59;
if(secTime &gt; maxSec){
      minTime++;
      if(minTime &gt; maxMin){
        hourTime++;
        if(hourTime &gt; maxHour){
          hourTime = 0;
          minTime = 0;
          secTime = 0;
        }
        minTime = 0
      }
      secTime = 0;
    }    
        var newSec = (secTime.toString().length == 1) ? '0' + secTime : secTime,
            newMin = (minTime.toString().length == 1) ? '0' + minTime : minTime,
            newHour = (hourTime.toString

PRE

A minor thing, but this piece of code can be simplified:

MID

if (secTime &gt; maxSec) {
    minTime++;
    if (minTime &gt; maxMin) {
        hourTime++;
        if (hourTime &gt; maxHour) {
            hourTime = 0;
            minTime = 0;
            secTime = 0;
        }
        minTime = 0
    }
    secTime = 0;
}


By removing the duplicated resetting to 0, like this:

if (secTime &gt; maxSec) {
    minTime++;
    if (minTime &gt; maxMin) {
        hourTime++;
        if (hourTime &gt; maxHour) {
            hourTime = 0;
        }
        minTime = 0
    }
    secTime = 0;
}    


POST

Another minor thing,
instead of the repeated logic like <code>(x.toString().length == 1) ? '0' + x : x</code> for seconds, minutes and hours, it would be better to extract this logic to a helper method to avoid code duplication.

SUBMITTED

def find_dt

PRE

makes much more sense.

MID

find_dt

POST

I don't like everything that is going on here.  First of all, I would argue that it shouldn't be the job of <code>find_dt</code> to convert an input string to a <code>datetime</code> object - the caller should be responsible for that.

Next, you're doing two distinct things.  One is displaying the day of the week for the given date, and the other is displaying information about that day being a US holiday.  These should probably be distinct.

SUBMITTED

self.modes = ['pvc', 'cvc']
        self.p1win = [('rock' + 'scissors'), ('paper' + 'rock'), ('scissors' + 'paper')]
        self.menu

PRE

Back to your long <code>raw_input</code>, it's way too long a string. Just print line by line and then wrap the final line in <code>raw_input</code>. All your newline characters in the middle of the string are awkward to read.

Just turn <code>self.rounds</code> into an <code>int</code> once instead of repeatedly calling it like this. There's no real reason to keep it a string after the user has entered it.

Your method of evaluating wins and losses is odd. Concatenated strings that indicate the player's victory are counter intuitive. You could instead have a dictionary of values doing a similar thing:

MID

WIN_CONDITIONS = {
    "rock": "scissors",
    "scissors": "paper",
    "paper": "rock",
    }


POST

This would make your test look like this:

SUBMITTED

T

PRE

MID

T

POST

SUBMITTED

MagicSquare.prototype.createHtmlTable = function

PRE

MID

MagicSquare#createHtmlTable

POST

SUBMITTED

lt;Game

PRE

MID

Game

POST

SUBMITTED

i != 0){
            if((numbers[i] - numbers[i - 1]) &gt; 0) {
                inOrder = true;
            } 
            if((numbers[i] - numbers[i - 1]) &lt; 0){
                inOrder = false;
            }
        } else if(i == 0){
                numbers[0] = 0;
        }
    }
    System.out.println("The fact that your numbers are in order is " + inOrder);
    return inOrder;


}

//Challenge 3 is Completed
@SuppressWarnings({ "resource", "unused" })
public static String Challenge3() {
    System.out.println("Enter a String");
    Scanner scan = new Scanner(System.in);
    String word1 = scan.nextLine();
    System.out.println("Enter another String");
    String word2 = scan.nextLine();
    String list = "";
    System.out.println("");
    Character[] word1Chars = toCharacterArray(word1);
    Character[] word2Chars = toCharacterArray(word2);
    Set&lt;String&gt; s1 = new HashSet&lt;&gt;( Arrays.asList( word1.split( "" ) ) );
    Set&lt;String&gt; s2 = new HashSet&lt;&gt;( Arrays.asList( word2.split( "" ) ) );
    s1.retainAll( s2 );

    for( String c: s1 ){
        System.out.print(c + " ");
    }
    return list;
}

public static boolean Challenge4() {
    boolean isInSentence = false;
    System.out.println("Enter a sentence");
    Scanner scan = new Scanner(System

PRE

After some (minor) changes:

MID

public static Set&lt;Character&gt; challenge3() {
    System.out.println("Enter a String");
    Scanner scan = new Scanner(System.in);
    String word1 = scan.nextLine();
    System.out.println("Enter another String");
    String word2 = scan.nextLine();
    scan.close();
    Set&lt;Character&gt; set = new HashSet&lt;&gt;(Arrays.asList(word1.toCharArray()));
    set.retainAll(new HashSet&lt;&gt;(Arrays.asList(word2.toCharArray())));
    System.out.println();
    for (char c : set) {
        System.out.print(c + " ");
    }
    return set;
}


Well, easy. You are over-complicating it. Why:

After simplifications:

public static boolean challenge4() {
    System.out.println("Enter a sentence");
    Scanner scan = new Scanner(System.in);
    String sentence = scan.nextLine();
    System.out.println("Now enter a word");
    String word = scan.nextLine();
    scan.close();
    if (sentence.contains(word)) {
        System.out.println("The word you entered is in the string");
        return true;
    }
    System.out.println("The word you entered is not in the string");
    return false;
}


POST

<s>I'll come back to this.</s>

This challenge is a bit more tricky. Your solution is again too complex:

SUBMITTED

attempt. //
    if (attachNode(node) == false) {    // If

PRE

MID

if (!attachNode(node))

attachNode

POST

SUBMITTED

def humbleNumber(n):
    curr = 0
    i = 0
    dp = {}
    while i &lt; n:
        curr += 1
        if ishumble(curr, dp):
            dp[curr] = True
            i += 1
        else:
            dp[curr] = False
    return curr

def ishumble(x,dp):
    if x == 1:
        return True
    acc = [2,3,5,7]
    for i in acc:
        if x % i == 0:
            if (x/i) in dp:
                return dp[x/i

PRE

<strong>No, not \$O(n)\$</strong>. Not even close. I'll get back to this later though. First, the code:

It's a little difficult to tell what your loop logic is. <code>curr</code> is getting incremented each time, but <code>i</code> isn't... whereas typically we'd use <code>i</code> as a loop index. I'd propose using <code>i</code> as the loop index, and then keeping a humble number count named <code>count</code> (or <code>num_humbles</code> or something):

MID

count = 0
dp = {}
for i in itertools.count(start=1):
    if ishumble(i, dp):
        dp[i] = True
        count += 1
        if count == n:
            return i
    else:
        dp[i] = False


You are also correct in this comment:

<code>#i don't believe this ever get's called</code>

That'll happen in the case where <code>x</code> is divisible by one of our primes, but we somehow haven't seen <code>x/p</code> yet. But we are iterating in order, so you're guaranteed that <code>y in dp</code> for all <code>y&lt;x</code>. So you can simplify that block to:

if x % i == 0:
    return dp[x/i]


Though if you reread that statement again, you'll see that there's no need for <code>dp</code> to be a dictionary. You can just make it a list. 

<strong>Split things up</strong>

Rather than having <strong>one</strong> function that does <strong>both</strong> generate the humble numbers <strong>and</strong> return the nth one, you can split them up. Have one function that generates the humble numbers:

def humble_numbers():
    dp = {}
    for i in itertools.count(start=1):
        if ishumble(i, dp):
            dp[i] = True
            yield i
        else:
            dp[i] = False


POST

And another function that returns the <code>nth</code> one. Actually, that part is a snap using the <a href="https://docs.python.org/2/library/itertools.html#recipes"><code>nth</code> recipe</a>:

SUBMITTED

nearest &lt;- function(id, yr, mnt, dy, ele, s1=s1, s2=s2, s3=s3, s4=s4, s5=s5, out=output, station=station){

  s1_d &lt;- filter(s1, year == yr &amp; month == mnt  &amp; day == dy &amp; element == ele)
  s2_d &lt;- filter(s2, year == yr &amp; month == mnt  &amp; day == dy &amp; element == ele)
  s3_d &lt;- filter(s3, year == yr &amp; month == mnt  &amp; day == dy &amp; element == ele)
  s4_d &lt;- filter(s4, year == yr &amp; month == mnt  &amp; day == dy &amp; element == ele)
  s5_d &lt;- filter(s5, year == yr &amp; month == mnt  &amp; day == dy &amp; element == ele)

  s1_d &lt;- select(s1_d, id, x, y, value)
  s2_d &lt;- select(s2_d, id, x, y, value)
  s3_d &lt;- select(s3_d, id, x, y, value)
  s4_d &lt;- select(s4_d, id, x, y, value)
  s5_d &lt;- select(s5_d, id, x, y, value)

  stack &lt;- do.call("rbind", list(s1_d, s2_d, s3_d, s4_d, s5_d))
  stack &lt;- select(stack, id, x, y, value)
  stack &lt;- filter(stack, value != -9999)

  if (dim(stack)[1] &gt;= 1){
    ifelse(dim(stack)[1] == 1, v &lt;- stack$value, v &lt;- idw(stack$value, stack[,2:4], station[,2:3])) 
  } else {
    ret &lt;- filter(out, id == id

PRE

To go further than my comment:

You're filtering twice for the same datas and so repeating yourself a lot in your nearest function, this could be simplified in a one call subset and avoid too much context switches.

This is how I would write your function:

MID

nearest2 &lt;- function(id,yr,mnt,dy,ele,s1=s1, s2=s2, s3=s3, s4=s4, s5=s5, out=output, station=station){
  stations &lt;- rbind(s1,s2,s3,s4,s5)
  stack &lt;- with(stations,stations[year==yr &amp; month==mnt &amp; day==dy &amp; element==ele &amp; value!=-9999,c("id","x","y","value")])
  if (dim(stack)[1] &gt;= 1){
    ifelse(dim(stack)[1] == 1, v &lt;- stack$value, v &lt;- idw(stack$value, stack[,2:4], station[,2:3])) 
  } else {
    ret &lt;- filter(out, id == id &amp; year == yr, month == mnt, element == ele, value != -9999)
    v &lt;- mean(ret$value) 
  } 
  return(v)
}


As you can see the idea is not really different, I stick to base R but feel free to prefer <code>filter %&gt;% select</code> approach.

To test the results I created 2 functions calling your orignal code and mine:

original &lt;- function() {
  for(j in which(is.na(newdat$value) | newdat$value &gt; 134 | newdat$value &lt; -80 | newdat$value == -9999)) {
    nearest(id = j, yr = as.numeric(newdat[j,3]), mnt = as.numeric(newdat[j,4]), dy = as.numeric(newdat[j,5]),
                           ele = as.character(newdat[j,2]), s1=s1, s2=s2, s3=s3,s4=s4,s5=s5, out=newdat, station=station)
  }
}

refactored &lt;- function() {
  for(j in which(is.na(newdat$value) | newdat$value &gt; 134 | newdat$value &lt; -80 | newdat$value == -9999)) {
    nearest2(id = j, yr = as.numeric(newdat[j,3]), mnt = as.numeric(newdat[j,4]), dy = as.numeric(newdat[j,5]),
                           ele = as.character(newdat[j,2]), s1=s1, s2=s2, s3=s3,s4=s4,s5=s5, out=newdat, station=station)
  }
}


POST

And then I did benchmark them to see if it improves or not:

SUBMITTED

struct PairEqual

PRE

Your <code>PairHash</code> implementation is bad, because it means <code>hash({a,b}) == hash({b,a})</code> (but not {a,b} == {b,a}).

MID

PairEqual

POST

There are already <code>operator==</code> and friends for <code>std::pair</code>.

Instead of keeping track if your rng is <code>seeded</code>, seed it in the constructor.

I find some of your names to be too verbose and far away from common naming schemes (stl, boost). Especially <code>get_...</code>.

For instance <code>get_num_edges_between</code>. I would think <code>count_edges(vertex_type, vertex_type, directed)</code> is just fine.

Why do you manage the <code>GraphEdge</code> by <code>unique_ptr</code> inside <code>edges</code>? This has negative performance impact. Use such an indirection only if you need to move the objects around often but cannot cheaply do so.

The same argument applies to <code>vertices</code>, but it requires more careful reasoning because the <code>GraphVertex</code> object is more complex. Is it required to often move around <code>GraphVertex</code>es in <code>std::unordered_map</code> operations? (I don't think so) Is it expensive to move a <code>GraphVertex</code> object? (Depends on ValueType.)

SUBMITTED

given: {0}, Identifiers Possible: {1}".format(ident, idents))

def change_val(self, col_ident, new_val, primary_value):
    for n in self.rows:
        if n.contents[self._get_primary_rowval()] == primary_value:
            n.contents[self._get_row_val_by_ident(col_ident)] = new_val

PRE

If I understand your intentions correctly,
the <code>_get_primary_rowval</code> and <code>_get_row_val_by_ident</code> functions are used to find column indexes.
They iterate over the list of column definitions until they find a match.
Do the columns get reordered often? Or ever?
In a table-like structure, I would expect the columns to not change much,
and so the column indexes should not change either.
Rather than looping to get the indexes,
it would be better to store them in a dictionary,
so that lookups become \$O(1)\$ operations.

Consider for example this use of these methods:

MID

def change_val(self, col_ident, new_val, primary_value):
    for n in self.rows:
        if n.contents[self._get_primary_rowval()] == primary_value:
            n.contents[self._get_row_val_by_ident(col_ident)] = new_val


POST

For every row,
those <code>_get</code> methods are called,
every time looping over the list of columns.
This is very inefficient and an unusual thing to do.

I suggest to rework this logic:
use a dictionary to store the column indexes.
If the columns change, update the dictionary accordingly.

Instead of this:

SUBMITTED

perc_str = format

PRE

MID

format

str(format(...))

POST

SUBMITTED

gt; 

// SUDOKU SOLVER v1.337

struct blockAttributes
{
    int row, column, box, possibilities = 0;
};

struct sudokuField
{
    int usedFields{ 0 };
    int possibilities{ 0 };
    int values[9 * 9];
    int possField[9 * 9][9];
    blockAttributes attributeField[9 * 9];
};

void

PRE

I see a number of things that could help you improve your program.

There is a subtle but real bug lurking in this code.  The code contains this structure:

MID

struct sudokuField
{
    int usedFields{ 0 };
    int possibilities{ 0 };
    int values[9 * 9];
    int possField[9 * 9][9];
    blockAttributes attributeField[9 * 9];
};


POST

Because you have specified initialization values for <code>usedFields</code> and <code>possibilities</code>, those will both recieve values, but the other fields will be uninitialized.  This does not pose a problem in this code except for <code>possField</code>.  Specifically, within the <code>solveSudoku</code> routine, there is a conditional statment:

SUBMITTED

fs.readFile

PRE

MID

readFile()

POST

SUBMITTED

synchronized (this){
            if( ! completed){
                completionJobs.add(onCompletion);
                return true;
            }
            else{
                return false;
            }
        }
    }
    @Override public void done(){
        synchronized (this){
            completed = true

PRE

Inside <code>synchronized (this)</code>:

MID

        if( ! completed){
            completionJobs.add(onCompletion);
            return true;
        }
        else{
            return false;
        }


A couple of problems:

Line 1: Space between <code>if</code> and <code>(</code><br>
Line 1: No extra spaces before and after <code>!</code><br>
Line 1: Space before brace

Lines 4-5: Should be combined<br>
Line 5: Space before brace

Result:

        if (!completed) {
            completionJobs.add(onCompletion);
            return true;
        } else {
            return false;
        }


In addition to formatting, you can safely omit the <code>else</code>, as the <code>if</code> part returns anyways:

        if (!completed) {
            completionJobs.add(onCompletion);
            return true;
        }
        return false;


}
@Override public void done(){
    synchronized (this){
        completed = true;
    }

    completionJobs.forEach(Runnable::run);
}


This is the end brace of the previous method plus the new method.

Again, a couple of things:

Lines 1-2: Extra newline between<br>
Line 2: Should be separated into two lines: <code>@Override</code> and declaration<br>
Line 2: Space before brace

Line 3: Already mentioned, space before brace
Line 6: Extra newline serves no purpose, but can be left there if wanted

Result:

}

@Override
public void done() {
    synchronized (this) {
        completed = true;
    }
    completionJobs.forEach(Runnable::run);
}


POST

SUBMITTED

var delegate : CellButtonDelegate?

    var parseObject:PFObject?


    internal var buttonEnabled : Bool? {

        get {

            return loveOutlet.enabled

        } set {

            loveOutlet.enabled = newValue!
        }
    }

 @IBAction func loveButton(sender: AnyObject) {

        if

PRE

Delegates should always be <code>weak</code>.  Without making a delegate <code>weak</code>, you're almost always setting up some sort of a retain cycle.  But what's more important, people expect for delegates to be marked as <code>weak</code>.  If you want to replicate the typical &quot;delegate&quot; pattern, but for some reason need the default <code>strong</code> reference, then you need to call your property by something other than &quot;delegate&quot;.

I have several comments about this property:

MID

internal var buttonEnabled : Bool? {

    get {

        return loveOutlet.enabled

    } set {

        loveOutlet.enabled = newValue!
    }
}


First of all, <code>internal</code> is the default access level.  As you marked nothing else as <code>public</code> or <code>private</code>, <em>everything</em> in your code actually has this <code>internal</code> access level.  Above all else, we should prefer consistency.  If you're going to mark <code>internal</code> things with the <code>internal</code> keyword, you're now going to need to mark every property, method, extension, protocol, class, struct, enum, and function (and whatever else I forgot) with its access modifier.  Anything else is inconsistent.  But marking them all is too verbose.  We all know (or should know) that <code>internal</code> is the default level, and if we mark all the internal things as <code>internal</code>, it just becomes an unconstructive cluttered keyword.  I would only ever recommend marking something as <code>internal</code> in a class where basically everything else is already marked as <code>public</code> or <code>private</code>.  In that case, <code>internal</code> indicates &quot;No, I didn't forget to mark this one--yes, it really is internal, I promise.&quot;

Next, there's a whole lot of white space in this.  In fact, you consistently have a ton of vertical white space throughout the entirety of your code.  Let's use white space more constructively, shall we?  Every single line of this property is all associated to this property.  By eliminating the blank lines in the middle, it helps the eye associate all of these lines together visually (in a way far more immediately obvious than the curly braces do).

Finally, let's talk about optionals... Your <code>loveOutlet</code> doesn't appear to be defined in this file, so I don't know if it is an optional or if it is a non-optional but the <code>enabled</code> property is optional.  I don't know what has led you to marking this <code>buttonEnabled</code> property as a <code>Bool?</code> rather than a non-optional <code>Bool</code>, but based on the force-unwrapping in your setter, it seems clear that this should probably be a non-optional.  We should allow the user to pass <code>nil</code> for the <code>buttonEnabled</code> property--how can that even make sense?  It clearly doesn't make sense, because if they ever do, we simply crash.  This is supremely bad design.  Swift gives you the power to clearly dictate which properties can and cannot be set to <code>nil</code>.  What you've done here is created a property that can be set to <code>true</code>, <code>false</code>, or &quot;crash my app please&quot;.

So more realistically, this property should look about like this:

var buttonEnabled: Bool {
    get {
        return loveOutlet.enabled
    } 
    set {
        loveOutlet.enabled = newValue
    }
}


If <code>loveOutlet</code> is optional (in this case, for it to compile, it'd have to be an implicitly unwrapped optional), or its <code>enabled</code> property is optional, then we can go for one of these two options in the <code>get</code>:

loveOutlet?.enabled ?? false


or

loveOutlet.enabled ?? false


POST

SUBMITTED

void displayWord

PRE

You've asked about how to improve performance, but I would advise you to improve the code organization first.  It's rather difficult to do a good job of optimizing the performance with the code in its current form.

Specifically, your code violates the Single-Responsibility Principle, as exemplified in <code>findWords()</code>, which does…

MID

displayWord()

POST

I suggest that you start by ripping out the graphical UI so that you can focus on the algorithm.  The algorithm should have a <code>findWord(String word)</code> function that returns a search result in the form of a row coordinate, column coordinate, and a direction.

Once you have that working, then you can go about implementing the UI as a separate class.

SUBMITTED

gt

PRE

MID

=&gt;

POST

SUBMITTED

lt;/li&gt;
&lt;/ul&gt

PRE

MID

ul.animated-list &gt; li

POST

SUBMITTED

null)
                    {
                        lock

PRE

MID

lock

POST

SUBMITTED

FILE_TEMP1=$(sed

PRE

MID

sed

POST

SUBMITTED

IndexCard[10] = { 0 }; // Card is from 0 to 12
};

int RandomNumber(int Start, int End) {
    int RNG = (rand() % End) + Start;
    return RNG;
}

Players AddCard(Players Player, unsigned int NumberCards) {
    for

PRE

You should seed the random number generator only once during an application run. By seeding it multiple times you ruin the distribution. So move this out of the loop and put it just after main starts.

MID

int RandomNumber(int Start, int End) {
    int RNG = (rand() % End) + Start;
    return RNG;
}


POST

This is probably the anti pattern for getting a rand number (and it has a bug). This is because the space is for random numbers is not even so the chance for any particular number is not the same.

The <code>rand()</code> function generates a number in the range <code>0-RANDMAX</code>. For arguments sake lets say RANDMAX 32768. Your want a number in the range 1-6.

This means.

SUBMITTED

parseData($rules

PRE

MID

rules

POST

Now the only thing you can do in PHP is type-hint for either instances of a class/interface, or for arrays (I know: in PHP7, you can also hint for scalars, but that's not relevant here). It's nice to see that you're using type-hints, but think about it: I can pass a lot of things to this function

SUBMITTED

lt;AcademicDegree

PRE

MID

AcademicDegree

POST

Note that you can still name <em>instances</em> using scenario-specific words (e.g. <code>Server cashier = new Server(…)</code>).

You modelled the queue discipline as a single <code>PrioritizedQueue</code>.  When certain customers can queue-jump, I'm not sure that it's fair to call it a "queue" anymore.  I'd call it four queues.  (That's how the priority scheme would be implemented in real life, right?)  With four queues, you can eliminate the awkward <code>PrioritizedQueue</code> class that is, in your own words, "not to be confused with a priority queue".

The accounting is complicated by the fact that the <strong>statistics are not stored with the associated objects</strong>.  Rather, you have a <code>SimulationResult</code> that is calculated in <code>Simulator.postprocess()</code> from the <code>arrivalEventMap</code> and the <code>servedEventMap</code>.  (You also have an inexplicable special case in <code>Simulator.simulate(Population, Cashier)</code> for zero-sized populations.)

The presence of helper methods in <code>Simulator</code> — <code>preprocess()</code>, <code>initWaitingTimeStructures()</code>, <code>precomputeWaitingTimes()</code>, <code>precomputeDeviationsPhase1()</code>, <code>precomputeDeviationsPhase2()</code>, <code>computeStandardDeviations()</code>, <code>loadStatistics()</code>, <code>computeCashierStatistics()</code>, and <code>postprocess()</code> — is a code smell.  The fact that it takes so <strong>many steps, which probably need to be executed in a specific order</strong>, indicates that the code is fragile.  If you have a good OOP design, no pre- and post-processing should be necessary: you simply say what you want to do, and the method should just work.

The <code>SimulationResult</code> class feels repetitive, with a lot of almost copy-and-paste code.

The main event loop should be very simple and generic.  Rather, you have a <code>Simulator.simulate(Population, Cashier)</code> method that is rather complicated.

First of all, while accepting parameters <code>Population</code> and <code>Cashier</code> might work for a simple system like this, it wouldn't scale well to more complex systems.  The state of the simulation should be held in the <code>Simulator</code> instance.

Let's look at the main loop.

SUBMITTED

id))
      .sum

PRE

MID

sum

POST

SUBMITTED

arguments);
        }
      }
      ImageFilter

PRE

If it is intended that there should only ever be one instance of <code>ImageFilter</code>, then factor it as a module, not a constructor.

If <code>ImageFilter</code> is to be reused, then :

MID

ImageFilter

new ImageFilter()

ImageFilter

POST

A separate reuse issue concerns everything in the vex dialog (<code>container</code>, <code>canvas</code>, <code>img</code> etc), which is created afresh every time <code>loadImage()</code> is called. Much can be created once per <code>data-imagefilter</code> element (or maybe once in total) and reused by rolling some of <code>loadImage()</code> into the constructor or the outer scope. Leave the resizing and <code>vex.dialog.open()</code> part behind (and all the <code>imgInstance</code> stuff I think).

Also, the <code>this.filters</code> object is static. It need not be defined/redefined in the <code>ImageFilter()</code> constructor.

<strong>Global namespace</strong>

There's no apparant reason for using the global namespace? If you really want <code>ImageFilter</code> (or an instance) to be globally available, then it could be assigned as a jQuery static method or refactored as a jQuery plugin? 

<strong>Use of jQuery</strong>

Why not exploit the power of jQuery? Coding in POJS is very noble, but bulky and generally less readable.

It's not clear why you might need polyfills for some portions of jQuery when you are already reliant on jQuery for Vex, which is a jQuery plugin. 

<strong>Others</strong>

According to the documentation, <code>fabric.Canvas();</code> accepts a DOM element, not an id. If the documentation is correct, the <code>canvas</code> element doesn't need an id.

Accessing <code>image.width</code> and <code>image.height</code> immediately after <code>image.src</code> has been set might work in some browsers when an image drawn from cache, but generally not. Best to attach an <code>onload</code> handler and move much of the <code>loadImage()</code> code inside it.

<code>var callback</code> is created conditionally therefore <code>callback</code> is not guaranteed to exist in the line where it is used.

<code>var canvas</code>, <code>self.canvas</code> and <code>this.canvas</code> are confusing. 

Why make <code>global</code> an alias for <code>window</code>, then use <code>window</code>?

What is <code>self</code>?

SUBMITTED

int numUnique

PRE

MID

numUnique

POST

SUBMITTED

if(request_is_attacked){
    if(as_knight){
        if(piece_abs_val==2){//knight
            is_attacked=true;
        }
    }else if(piece_abs_val==6){//king
        if(i==0){
            is_attacked=true;
        }
    }else if(piece_abs_val==5){//queen
        is_attacked=true;
    }else if(piece_direction%2){
        if(piece_abs_val==4){//rook
            is_attacked=true;
        }
    }else if(piece_abs_val==3){//bishop
        is_attacked=true;
    }else if(i==0 &amp;&amp; piece_abs_val==1){
        if(piece_val!=-1){//w_pawn
            if(piece_direction==4 || piece_direction==6){
                is_attacked=true;
            }
        }else{//b_pawn
            if(piece_direction==2 || piece_direction==8){
                is_attacked=true

PRE

We can make this much more readable with a <code>switch</code> statement.

MID

switch(piece_abs_val) {
    case 1:
        if(piece_val != -1){ //w_pawn
            if(piece_direction == 4 || piece_direction == 6){
                is_attacked = true;
            }
        } else { //b_pawn
            if(piece_direction == 2 || piece_direction == 8){
                is_attacked = true;
            }
        }
        break;
    case 2:
        is_attacked = as_knight;
        break;
    case 3:
        is_attacked = true;
        break;
    case 4:
        is_attacked = piece_direction % 2;
        break;
    case 5:
        is_attacked = true;
        break;
    case 6:
        is_attacked = i == 0;
        break;
}


Same exact code only much cleaner. I also did some refactoring. Take <code>6</code> for example; it used to be this:

else if(piece_abs_val==6){//king
        if(i==0){
            is_attacked=true;
        }


POST

In the switch, <code>piece_abs_val</code> is checked for <code>6</code>. Then, <code>is_attacked</code> is set to whatever <code>i==0</code> evaluates to. However, instead of using a conditional, I just simply wrote the statement out in the variable setting.

Your code is littered with <a href="https://stackoverflow.com/questions/47882/what-is-a-magic-number-and-why-is-it-bad">magic numbers</a>. These are bad.

What you need here is a makeshift enumerated type. In case you don't know, an enumerated type is basically a type that assigns plain texts words (not strings) to integer values. I say "makeshift" because JavaScript does not have native support for these values.

Judging from your comments, I was able to make this:

SUBMITTED

readonly IMessageBox

PRE

<code>RemoveVariable()</code> is called before <code>UpdateSignature()</code>, yet I have to scroll pretty far down to find <code>RemoveVariable()</code> while <code>UpdateSignature()</code> is the very first I see. 

I would like to see <code>RemoveVariable()</code> listed first.

MID

IMessageBox

POST

I like this interface, but the only variation, except from the text, are the buttons. Why not abstract the usage instead of copying the actual interface? 

Like:

SUBMITTED

class='datepicker

PRE

MID

.datepicker()

.datepicker

POST

The need for timeouts is worrying. Definitely needs investigating. Possibly due to async loading of SO content?

SUBMITTED

you can run mysql from the command line without password prompt
printf "[mysql]\nuser=root\npassword=\""$MYSQL_ROOT_PASS"\"\n" &gt; ~/.my.cnf

## adds a wordpress user with own password and creates database for wordpress
mysql --defaults-file=~/.my.cnf -e "create database $MYSQL_DB; create user "$MYSQL_USER"@localhost; set password for "$MYSQL_USER"@localhost = PASSWORD(\""$MYSQL_USER_PASS"\"); GRANT ALL PRIVILEGES ON "$MYSQL_DB".* TO "$MYSQL_USER"@localhost IDENTIFIED BY '"$MYSQL_USER_PASS"'; flush privileges

PRE

This line is long and hard to read with many commands jammed inside:

MID

mysql --defaults-file=~/.my.cnf -e "create database $MYSQL_DB; create user "$MYSQL_USER"@localhost; set password for "$MYSQL_USER"@localhost = PASSWORD(\""$MYSQL_USER_PASS"\"); GRANT ALL PRIVILEGES ON "$MYSQL_DB".* TO "$MYSQL_USER"@localhost IDENTIFIED BY '"$MYSQL_USER_PASS"'; flush privileges;"


A more readable way to write this:

cat &lt;&lt; EOF | mysql --defaults-file=~/.my.cnf 
create database $MYSQL_DB;
create user "$MYSQL_USER"@localhost;
set password for "$MYSQL_USER"@localhost = PASSWORD(\""$MYSQL_USER_PASS"\");
GRANT ALL PRIVILEGES ON "$MYSQL_DB".* TO "$MYSQL_USER"@localhost IDENTIFIED BY '"$MYSQL_USER_PASS"';
flush privileges;
EOF


POST

Drop the <code>-r</code> here, as that's useful for recursively removing directories, but you have a simple file here:

SUBMITTED

test
     */
    public function dontProcessForeignTables()
    {
        $expectedResult = ['title' =&gt; 'test'];
        $modifiedFields = $expectedResult;

        $this-&gt

PRE

This is common across all functions in:

MID

    $expectedResult = ['title' =&gt; 'test'];
    $modifiedFields = $expectedResult;


POST

Consider moving it to a more accessible place so it doesn't need to be replicated.

You shouldn't be having actual data hardcoded in, pass it in from a database or config file for better maintainability.

SUBMITTED

php');

$player

PRE

MID

player

POST

SUBMITTED

Sudoku_solving_algorithms

        if not self.check_valid:
            return False

        y, x = 0, 0 #Setting the starting

PRE

<strong>Function calling bug</strong>

MID

if not self.check_valid:
        return False


You omitted the parenthesis, this means you are talking about the value of the function object, that is always true. So this check is basically jumped.

The fix is:

if not self.check_valid():
        return False


POST

<strong>Usage of built-ins : <code>Counter</code> and <code>all</code></strong>

The definition of <code>is_proper_sudoku</code> that you use feels low-level as you re-invent the <code>Counter</code> and <code>all</code> built-ins:

SUBMITTED

gt; r

PRE

MID

r

POST

SUBMITTED

range(0, 5000, 5)
SIDES_OF_AN_EQUILATERAL_TRIANGLE

PRE

MID

SIDES_OF_AN_EQUILATERAL_TRIANGLE = 3

POST

SUBMITTED

piece]    
  (cond

PRE

MID

cond

POST

SUBMITTED

the end of chain
*/
void insertWord(hashtable *phashtable, char *str)
{   
    if (phashtable == NULL || str == NULL)
    {
        return;
    }

    bool ispresent;
    int hashindex = getKey(str);

    if (hashindex &gt; SIZE)
    {
        fprintf(stderr, " -- invalid hashindex -- \n");
        return;
    }

    chainelements *pchainelements = phashtable-&gt;base[hashindex].baseelement;

    /* if no elements are present - insert word */
    if (!pchainelements)
    {
        pchainelements = (chainelements *)malloc(sizeof(chainelements));
        if (pchainelements == NULL)
        {
            fprintf(stderr, " -- memory allocation failed for the word -- \n");
        }
        phashtable-&gt;base[hashindex].baseelement = pchainelements;
        strcpy(pchainelements-&gt;word, str);
        pchainelements-&gt;next = NULL;
    }
    else
    {
        /* Check if the word is already present if not insert*/
        ispresent = searchWord(phashtable, str);

        if (ispresent == 0)
        {
            printf("insert word   is not present - so

PRE

and call it from both <code>searchWord</code> and <code>insertWord</code> with precomputed hash.

<strong>Cast <code>malloc</code></strong>

<a href="https://stackoverflow.com/questions/605845/do-i-cast-the-result-of-malloc">Don't do it</a>

<strong>Memory usage</strong>

The word in the table occupies 100 bytes no matter what. It is possible (even though quite unlikely) to corrupt heap with very long words. It is also very wasteful. You should either allocate just right memory with <code>strdup()</code>, or memory map your file and use pointers into the mapped data.

<strong>What is a better strategy?</strong>

Since you don't care about an order in which collided words appear in the cain, always insert at the beginning. You wouldn't need to special case the empty chain, and the insertion code becomes

MID

ispresent = searchWord(phashtable, str);

if (ispresent == 0)
{
    printf("insert word   is not present - so inserting %s \n", str);

    pchainelements = malloc(sizeof(chainelements));
    if (pchainelements == NULL)
    {
        fprintf(stderr, " -- memory allocation failed for the word -- \n");
    }

    base = phashtable[hashindex].baseelement;
    phashtable-&gt;base[hashindex].baseelement = pchainelements;
    strcpy(pchainelements-&gt;word, str);
    pchainelements-&gt;next = base;
}


POST

SUBMITTED

else
        res

PRE

MID

res

POST

SUBMITTED

taglist").html('&lt;%= escape_javascript(render partial: "items/tag_list", locals: {item: @item}) %&gt;');

$('.remove-tag-button').on('click', function () {
  $.ajax({
    type: "POST",
    data: {id: &lt;%= @item.id %&gt;, tag: $(this).data("tag-name")},
    url: "/remove_tag

PRE

I was able to get rid of the duplicate code by using <strong><em>event delegation</em></strong>.  I changed my event listener to:

MID

$('#taglist').on('click', '.remove-tag-button', function () {
    $.ajax({
      type: "POST",
      data: {id: &lt;%= @item.id %&gt;, tag: $(this).data("tag-name")},
      url: "/remove_tag"
    });
  });


POST

SUBMITTED

def degrees_to_pretty_radians

PRE

instead of

MID

degrees_to_pretty_radians(1234)


POST

This is both more self-explanatory and easier to read.

SUBMITTED

GetString("Name"); //Get field name
                string Type = Reader.GetString("Type"); //Get field type

                Label L = new Label();

                if (Reader.GetInt32("Required") == 1) { L.Text = Name + "*"; } else { L.Text = Name; }

                L.Name = "L" + i;
                L.AutoSize = true;
                L.TextAlign = ContentAlignment.MiddleLeft;
                L.Visible = true;
                L.Font = new Font("Microsoft Sans Serif", 8);
                L.Dock = DockStyle.Fill;
                L.Margin = new Padding(0, 3, 0, 3);

                if (!_labels.Contains(L))
                {
                    _labels.Add(L);
                    L.MouseUp += new MouseEventHandler(wl_Lock);
                }

                Form_Grid.Controls.Add(L, 0, i + 1);
                Form_Grid.RowStyles[i + 1].SizeType = SizeType.AutoSize;

                if (Type == "Textbox" || Type == "Suggestbox")
                {
                    TextBox T = new TextBox();
                    Height += 26;

                    T.Name = "T" + i;
                    T.Dock = DockStyle.Fill;
                    T.TabIndex = i + 1;
                    if (Type == "Suggestbox")
                    {
                        T.AutoCompleteMode = AutoCompleteMode.SuggestAppend;
                        T.AutoCompleteSource = AutoCompleteSource.CustomSource;
                        string[] p = _options[i].Split('|');
                        foreach (string a in p)
                        {
                            T.AutoCompleteCustomSource.Add(a);
                        }
                    }
                    if (!_entries.Contains(T))
                    {
                        _entries.Add(T);
                        T.KeyPress += new KeyPressEventHandler(wl_hotKeys);
                    }
                    Form_Grid.Controls.Add(T, 1, i + 1);
                    Form_Grid

PRE

6) <strong>factories for controls</strong>

Each control can be constructed in a separate function. E.g:

MID

private Label getRequiredLabel(int i, bool isRequired) 
{ 
    Label L = new Label();

    if (isRequired)
        L.Text = Name + "*";
    else 
        L.Text = Name; 

    L.Name = "L" + i;
    L.AutoSize = true;
    L.TextAlign = ContentAlignment.MiddleLeft;
    L.Visible = true;
    L.Font = new Font("Microsoft Sans Serif", 8);
    L.Dock = DockStyle.Fill;
    L.Margin = new Padding(0, 3, 0, 3);

    if (!_labels.Contains(L))
    {
        _labels.Add(L);
        L.MouseUp += new MouseEventHandler(wl_Lock);
    }

    Form_Grid.Controls.Add(L, 0, i + 1);
    Form_Grid.RowStyles[i + 1].SizeType = SizeType.AutoSize;
}


POST

and use it like:

SUBMITTED

filePath"])
            caseDB = caseDB(fp)

            cases = caseDB

PRE

This line is confusing me:

MID

caseDB = caseDB(fp)


POST

This isn't intended to modify <code>caseDB</code>, is it? As far as I can tell, it would modify it by replacing the name in your first case, but not the second since you're only modifying it inside the local scope each time the generator is called. It is a very bad idea to match names like this, because it makes it unclear whether or not they're supposed to be the same thing, or <code>caseDB</code> is an instance of a <code>caseDB</code> object. If this reuse of the name is necessary, it's a very confusing pattern that ought to be explicitly explained rather than just used without comment. 

You shouldn't test for an empty collection using <code>len(var) == 0</code>. You're wasting time calculating the full length of something just to check if it's zero. Instead, use Python's truthiness. Any variable can be evaluated as a boolean in Python. For collections, this means that it's <code>False</code> if the collection is empty, and <code>True</code> otherwise. This means your test could be:

SUBMITTED

done.
            while (true)
            {
                var rays = (from ray in
                                (from second in pointsList.Except(envelope)
                                 select new Ray(envelope.Peek(), second))
                            let possibleEndPoints = pointsList.Except(new Point[] { ray.Start, ray.End })
                            where possibleEndPoints.All(p =&gt; ray.GetProjectionSign(p) &gt;= 0) ||
                                  possibleEndPoints.All(p =&gt; ray

PRE

MID

                                (from second in pointsList.Except(envelope)
                                 select new Ray(envelope.Peek(), second))
                            let possibleEndPoints = pointsList.Except(new Point[] { ray.Start, ray.End })


POST

In my opinion it shouldn't be a list at all, but an <code>ISet&lt;Point&gt;</code> from which the main loop removes used points. In the worst case that would be a significant performance improvement over the first <code>pointsList.Except</code>. A small subtlety would be in the sign test, which would then have to use <code>points</code> instead of <code>possibleEndPoints</code>.

SUBMITTED

createtable() {
            $.ajax

PRE

MID

$.ajax()

POST

SUBMITTED

calculator.
            manipulate_and_display

PRE

<code>script</code> elements are not allowed before the <code>html</code> or after the <code>body</code> element (neither are any other elements for the matter) . Depending on how the scripts are written, they belong all inside the <code>head</code> element, or preferably at the end of (but inside) the <code>body</code> element.

All script should be in external files. So either out the "document ready" code also into <code>calc.js</code>, or put it (together with the function <code>manipulate_and_display</code>) into a separate file.

MID

manipulate_and_display

POST

What exactly is the point of <code>manipulate_and_display</code>? It's name doesn't expain what it does and it doesn't seem to have anything to do with the calculator directly.

The variable <code>calc</code> in it isn't defined anywhere I can find, but It works, so currently I'm assuming it's an implicit variable created by giving the calculator form the name "calc". Don't do that. Using implicit variables created from element IDs and names an out-of-date way to access them. Always get element references using DOM methods such as <code>getElementById()</code> (or store them when creating elements and reuse the references).

You unnecessarily use empty strings when concatinating. This:

SUBMITTED

app.controller('Ctrl2', ['$scope', '$rootScope', function($scope, $rootScope) {
  var myArray = [$scope.input1, $scope.input2];
  $scope.textChange = function(whichChange) {
    if (whichChange == 1) {
      $rootScope.$broadcast('textChanged', $scope.input1, 1);
    } else if (whichChange == 2) {
      $rootScope.$broadcast('textChanged', $scope.input2, 2);
    } //else if, else if, else if, etc

PRE

The first change I would suggest when using a lot of ifs is to put things in a map. This is assuming you know what values are expecting from <code>whichChange</code>:

MID

app.controller('Ctrl2', ['$scope', '$rootScope', function($scope, $rootScope) {
  var inputById = { 
    "1": $scope.input1, 
    "2": $scope.input2
  };
  $scope.textChange = function(whichChange) {
    var input = inputById[whichChange.toString()];
    $rootScope.$broadcast('textChanged', input, whichChange);
  };
}]);


POST

SUBMITTED

noexcept
        : m_pointer

PRE

MID

m_pointer

POST

SUBMITTED

let mut is_prime = 0;
                         ^~~~~~~~~~~~
primes.rs:14:17: 14:25 warning: value assigned to `is_prime` is never read, #[warn(unused_assignments)] on by default
primes.rs:14                 is_prime

PRE

MID

primes.rs:11:13: 11:25 warning: value assigned to `is_prime` is never read, #[warn(unused_assignments)] on by default
primes.rs:11         let mut is_prime = 0;
                         ^~~~~~~~~~~~


You don't have to initialize a variable when you declare it. That is, you can write

let mut is_prime;


You just have to initialize it before reading from it; if the compiler cannot guarantee that the variable will be initialized at that point, it will raise an error.

primes.rs:14:17: 14:25 warning: value assigned to `is_prime` is never read, #[warn(unused_assignments)] on by default
primes.rs:14                 is_prime = 1;
                             ^~~~~~~~


POST

That warning comes from this block:

SUBMITTED

os.close

PRE

MID

close

POST

SUBMITTED

new OctreeNode

PRE

MID

OctreeNode

POST

SUBMITTED

query = $db-&gt;getConnection()-&gt;prepare("INSERT INTO `users` (first_name, last_name, email, username, password, unique_id, date_joined) VALUES(:fname, :lname, :email, :username, :pass, :uniqueid, :date_joined)");
$query-&gt;bindParam(':fname', $first_name, PDO::PARAM_STR);
$query-&gt;bindParam(':lname', $last_name, PDO::PARAM_STR);
$query-&gt;bindParam(':email', $email, PDO::PARAM_STR);
$query-&gt;bindParam(':username', $username, PDO::PARAM_STR);
$query-&gt;bindParam(':pass', $passHash, PDO::PARAM_STR);
$query-&gt;bindParam(':uniqueid', $emailHash, PDO::PARAM_STR);
$query-&gt;bindParam(':date_joined', $date, PDO::PARAM_STR);
$query-&gt;execute

PRE

Since you have <code>PDO::PARAM_STR</code> everywhere, you can just pass all the parameters to the <a href="http://php.net/manual/en/pdostatement.execute.php" rel="nofollow noreferrer">execute</a>:

MID

$query = $db-&gt;getConnection()-&gt;prepare("INSERT INTO `users` (first_name, last_name, email, username, password, unique_id, date_joined) VALUES(:fname, :lname, :email, :username, :pass, :uniqueid, :date_joined)");
$query-&gt;execute(array(
    ':fname' =&gt; $first_name,
    ':lname' =&gt; $last_name,
    ':email' =&gt; $email,
    ':username' =&gt; $username,
    ':pass' =&gt; $passHash,
    ':uniqueid' =&gt; $emailHash,
    ':date_joined' =&gt; $date
));


What about if one wasn't a string? Would the "best" practice be to follow this and just bindParam as usual on the variable that isn't PDO::PARAM_STR?

You can have a custom version of the execute which could work like this:

myCustomExecute($query, array(
    ':fname' =&gt; [$first_name, PDO::PARAM_STR]
    ':lname' =&gt; [$last_name, PDO::PARAM_STR],
    ':age' =&gt; [$age, PDO::PARAM_INT]
));


POST

Inside the <code>myCustomExecute</code> you just loop over the array and do <code>bindValue</code> for each array item (note, it is better to use <code>bindValue</code> instead of <code>bindParam</code>, see for example, <a href="https://stackoverflow.com/questions/4174524/binding-params-for-pdo-statement-inside-a-loop">this</a>).

But I feel like you want something bigger than this to avoid writing a boilerplate code. In this case your are looking for an <code>ORM</code>.

The practical solution is to <a href="https://www.google.com/search?q=php%20orm" rel="nofollow noreferrer">search for</a> existing solution and choose the one you like.

Less practical way would be to write something simple around PDO.

The final syntax would be something like this:

SUBMITTED

State_StateChanged;
        parser.State.OnParseRequested();
        _semaphore.Wait

PRE

After creating a quick scenario that I believe mimics your use case, it seems to work just fine: <a href="https://gist.github.com/Vannevelj/5d0e348fd1424492ff8f">https://gist.github.com/Vannevelj/5d0e348fd1424492ff8f</a>

MID

parser.State.OnParseRequested();


POST

I'm not feeling comfortable with this name for a public member since it's not of the <code>[verb][action]</code> form -- <code>RequestParse()</code> might be more appropriate.

SUBMITTED

if (is_front_page() || is_home()) {
    $description

PRE

What if your <code>$description</code> variable is empty? You are only checking if you're on the front page, or home page, and set it to blog description from wordpress, and if you're not, you're setting it to your post meta value.

What about categories? Tags? other archive pages? 

The 

MID

if($description)


Will return what? False. Why? Because it's a description, not a boolean.

You should check it with

if(isset($description) &amp;&amp; $description !== '')


POST

If the variable is set and not empty string you'll get a true as a value that will pass the <code>if</code> test.

I'd do it like this:

SUBMITTED

logs) / NumCPU
    if ChunkSize == 0 {
        ChunkSize = 0
    }
    if

PRE

<code>NumCPU</code> should start lowercase. Method variables should always be, as they are never exported.

I will duplicate what @cat says here... what's this? (It's a WTF in case you were wondering...):

MID

if ChunkSize == 0 {
    ChunkSize = 0
}


POST

Then, about your code, it is really confusing why you split the data in to chunks based on the number of cores you have (actually, twice as many), and then you loop through the chunks, and for each loop, bizarrely, you split each chunk in half again, and process each half in a separate routine. If you have 4 real cores, you split the data 8 ways, and each of those 8 ways spins off 2 routines - making the whole thing a 16-way split on a 4-core machine. That's not technically, horrible but if that's what you want, just do that with <code>runtime.NumCPU() * 4</code> instead of <code>runtime.NumCPU() * 2</code>....

It's all just.... odd.

Now, you have a <code>locker</code> that's created outside the function (I assume). This is a problem because if your code is called multiple times concurrently, then you will have two different result slices being locked by one lock. The amount of locking you do is really concerning too.... why lock for every record? I would accumulate each goroutine's results in a local slice, then, when the routine is complete, I would add them all to the (locked) result slice.

All told, I would probably make life simple with:

SUBMITTED

def difficulty2

PRE

MID

difficulty2

POST

SUBMITTED

int max_size

PRE

MID

max_size

POST

SUBMITTED

while (true) {
            U32 first = m_first.load(std::memory_order_relaxed);
            if (first == m_last.load(std::memory_order_relaxed))
                return false

PRE

This line:

MID

        if (first == m_last.load(std::memory_order_relaxed))
            return false;


should be:

        if (first == m_last.load(std::memory_order_acquire))
            return false;


POST

Otherwise, on the next line you may load the wrong value out of <code>m_buffer</code> due to the load being reordered before the load to <code>m_last</code>.  I spotted this because I noticed a <code>memory_order_release</code> without a corresponding <code>memory_order_acquire</code>.  The <code>pop()</code> function also needs a load of <code>m_last</code> with <code>memory_order_acquire</code>.

You have the same problem in <code>push()</code>.  If you don't load <code>m_first</code> with <code>memory_order_acquire</code>, you run the risk of writing to the buffer when it is full, thus overwriting some element.  Even the assertion won't help because you could have overwritten the buffer and then loaded a modified value for <code>m_first</code>.

Since your comment indicated that I didn't explain thoroughly enough, I will give an example of how the pop could go wrong.

SUBMITTED

lxml.etree.ElementTree

PRE

nitpick: Cleaning at the ElementTree would prevent your filesystem to see two different versions. Say at some point you decide to use <a href="https://github.com/gorakhargosh/watchdog" rel="nofollow">watchdog</a>, the callback will kick in before you have a chance to run <code>clean_xml</code>, which could cause subtle bugs.

MID

lxml.etree

POST

SUBMITTED

Now()
    ActiveSheet

PRE

MID

ActiveSheet

POST

SUBMITTED

addKid.grid

PRE

MID

grid

POST

Now, the things I think need improving:

SUBMITTED

FileUtils.ReadFile

PRE

MID

ReadFile

POST

The <code>Map</code> usage in <code>ReadFile</code> could be improved.

In the first branch, when the <code>List</code> already is in the <code>Map</code>, putting it back in is redundant.

In <code>ReadFile</code>. you know that every key you access shall exist. You could use <code>computeIfAbsent()</code>, like this:

SUBMITTED

amp;p1;

void updateCounters(){
  // Update the counters for each player
  if (p0.isActive) {
    p0.secondsRun += millis()/1000 - (
      p0.secondsRun + 
      p1.secondsRun + 
      p2.secondsRun
      );
    }
  if (p1.isActive) {
    p1.secondsRun += millis()/1000 - (
      p0.secondsRun + 
      p1.secondsRun + 
      p2.secondsRun
      );
    }
  if (p2.isActive) {
    p2.secondsRun += millis()/1000 - (
      p0.secondsRun + 
      p1.secondsRun + 
      p2.secondsRun
      );
    }
}

void setup()
{
 lcd.begin(16, 2);  
 lcd.setCursor(0,0);
 lcd.print("P1 ChessClock P2");
}

// Main loop
void loop()
{
 updateCounters();  // do this every loop
 lcd_key = read_LCD_buttons();  
 if (isUsingMenu) {
   switch (lcd_key)               
   {
     case btnUP:
       {
        // increase minutes

PRE

You have quite a few blocks of code there that are just copy-paste changing one or two parameters. Code duplication is a source of many problems and pretty much the reason why programmers invented constructs like functions and classes. For instance, in <code>updateCounters</code>:

MID

void updateCounters() {
 if (p0.isActive) {
   p0.secondsRun += millis()/1000 - (
     p0.secondsRun + 
     p1.secondsRun + 
     p2.secondsRun
     );
   }
 if (p1.isActive) {
   p1.secondsRun += millis()/1000 - (
     p0.secondsRun + 
     p1.secondsRun + 
     p2.secondsRun
     );
   }
 if (p2.isActive) {
   p2.secondsRun += millis()/1000 - (
     p0.secondsRun + 
     p1.secondsRun + 
     p2.secondsRun
     );
   }
}


POST

Notice how the three blocks are identical, except for the first player instance? That calls for a separate function! Make that <code>secondsRun</code> update logic a member of <code>Player</code> and let each player handle its update. Be sure to pass the other two player instances as function parameters, to avoid relying on globals.

Moving to <code>loop()</code>, there are repeated blocks in the main <code>switch</code> as well. Try to identify the repeated blocks of code and refactor then into auxiliary functions, always using function parameters when you need to pass them some data.

SUBMITTED

start the wiper
    system("cat /dev/null &gt; ~/.bash_history;history

PRE

Let me explain step by step why this is equivalent:

MID

cat /dev/null &gt; ~/.bash_history

&gt; ~/.bash_history

POST

SUBMITTED

void drawString

PRE

MID

drawString()

POST

SUBMITTED

char* buf

PRE

MID

buf

sprintf(&amp;buf[8], ":%03u", start.millitm);

sprintf(buf + 8, ":%03u", start.millitm);

POST

SUBMITTED

void logd

PRE

MID

logd

POST

The visual difference between <code>loge</code> and <code>logd</code> is tiny. Using more different names (e.g., <code>log_error</code>, <code>log_debug</code>), or passing the log_level as a parameter to a single <code>log</code> function:

SUBMITTED

playable = new Array();
    torrent

PRE

MID

new Array();

POST

SUBMITTED

catch and discard exceptions.
                }
                try {
                    ::operator delete(buffer);
                } catch(...) {}
            }
            void

PRE

Still missing all the <code>size/capacity/empty</code> accessors. <code>front/back</code> might also
be interesting. If you have lots of free time, why not also go for some iterators?

As far as I know, <code>delete</code> is always noexcept, so this should be pointless:

MID

try {
    ::operator delete(buffer);
} catch(...) {}


POST

BTW, I also agree that catching an exception from the user destructor is dangerous. Could hide more serious problems. You might consider just letting the program terminate or call <code>std::terminate/std::abort</code> directly to trap right there and then.

Other than what was already said in Deduplicator's answer, it looks quite good.

SUBMITTED

contentsOfURL: NSURL

PRE

MID

NSURL

POST

SUBMITTED

fi
    else
        echo -n " [NO SYS]  "
    fi
    if CHECK_DATA; then
        if CHECK_DATA_NEMPTY  ; then 
            echo "[DATA]"
        fi
    else
        echo "[NO DATA]"
    fi
    # menu options
    if CHECK_DB ; then
        PRINT_LINE3
    else
        PRINT_LINE3
        echo "pre      - prepare"
        PRINT_LINE
    fi    
    if CHECK_DB

PRE

But it seems that in some cases the output might be broken, in the case when the condition chain on <code>CHECK_DATA</code> doesn't print a newline character. That is, when <code>CHECK_DATA</code> is true but <code>CHECK_DATA_NEMPTY</code> is false, the <code>rom</code> line will not be terminated with a newline character, and the <code>+-+-+</code> line will be printed starting from the middle of the <code>rom</code> line. It would be better to write like this:

MID

if CHECK_DATA; then
    if CHECK_DATA_NEMPTY  ; then 
        echo -n "[DATA]"
    fi
else
    echo -n "[NO DATA]"
fi
echo
# ...
PRINT_LINE3


POST

SUBMITTED

do |color_weight

PRE

MID

|color_weight|

POST

SUBMITTED

default is false)
    """

    case = case.lower

PRE

MID

case = case.lower()

POST

SUBMITTED

var CommentView = Backbone.View.extend({
    el: $("#comments_section"),
    render: function() {
        var notNullComments = comments.wellFormedComments();
        if (notNullComments.length &gt; 0) {
            $("#target_dom").show();
        }
        var html = commentsTmpl(notNullComments.toJSON());
        $(this.el).append(html

PRE

All in all, I would go with something like this:

MID

var CommentView = Backbone.View.extend({
    el: $("#comments_section"),
    render: function() {
        var comments= comments.wellFormedComments();
        if (!comments.length) {
            return
        }
        $("#a_descriptive_id").show();
        var html = commentsTmpl(notNullComments.toJSON());
        $(this.el).append(html);
    },
});


POST

SUBMITTED

RPNOPSTAB_H_
using namespace std;
#include &lt

PRE

I see a number of things that may help you improve your code.

MID

using namespace std

POST

Putting <code>using namespace std</code> at the top of every program is <a href="https://stackoverflow.com/questions/1452721/why-is-using-namespace-std-considered-bad-practice">a bad habit</a> that you'd do well to avoid.  It's especially bad to put it into header files, so please don't do that.

In files such as <code>RpnOpsTab.cpp</code>, there are a number of included Boost headers, but unfortunately, they're not in the standard hierarchy.  For example, the code currently includes these lines:

SUBMITTED

File.open

PRE

Some notes:

MID

open

POST

SUBMITTED

prints out contents of file being compressed along with integer values of
     * the characters being compressed, and will return your file name with an
     * appended ".lzw"
     *
     * @param args - The command line arguments
     * @throws java.io.IOException - File input/output failure
     */
    public static void main(String[] args) throws IOException {
        try {
            LZWCompression lzw = new LZWCompression();

            Scanner input = new Scanner(System.in);

            System.out.println("Enter the name of your (input.txt) file.");

            String str = input.nextLine();

            File file = new File(str);

            Scanner fileScanner = new Scanner(file);

            String line = "";

            while (fileScanner.hasNext()) {
                line = fileScanner.nextLine();
                System.out.println("Contents of your file being compressed: \n"
                        + line);
            }
            lzw.compress(str);
            System.out.println("\nCompression of your file is complete!");
            System.out.println("Your new file is named: " + str.concat(".lzw"));
        } catch (FileNotFoundException e) {
            System.out.println("File was not found

PRE

MID

        try {
            LZWCompression lzw = new LZWCompression();

            Scanner input = new Scanner(System.in);

            System.out.println("Enter the name of your (input.txt) file.");

            String str = input.nextLine();

            File file = new File(str);

            Scanner fileScanner = new Scanner(file);

            String line = "";

            while (fileScanner.hasNext()) {
                line = fileScanner.nextLine();
                System.out.println("Contents of your file being compressed: \n"
                        + line);
            }
            lzw.compress(str);
            System.out.println("\nCompression of your file is complete!");
            System.out.println("Your new file is named: " + str.concat(".lzw"));


But the early part of this can't throw a <code>FileNotFoundException</code>, so it doesn't need to be in the <code>try</code> block.  

        LZWCompression lzw = new LZWCompression();

        Scanner input = new Scanner(System.in);
        System.out.println("Enter the name of your (input.txt) file.");
        String filename = input.nextLine();

        try (Scanner = new Scanner(new File(filename))) {


            while (fileScanner.hasNext()) {
                String line = fileScanner.nextLine();
                System.out.println("Contents of your file being compressed: \n"
                        + line);
            }

            lzw.compress(filename);

            System.out.println("\nCompression of your file is complete!");
            System.out.println("Your new file is named: " + filename.concat(".lzw"));


POST

Now the <code>fileScanner</code> will be managed by the <code>try</code> statement.  

SUBMITTED

fname in file_haystack:

        fio = open(fname, "r")
        fct = fio.read()
        fio.close()

        metamatches[fname] = fuzzy_grep(needle, fct, **kwargs

PRE

While it's a small nitpick, it was bothering me a little. On these three lines, you're opening a file, reading it and then closing it:

MID

fio = open(fname, "r")
fct = fio.read()
fio.close()


While this is a small chunk of code, if an exception occurs between the file opening, or closing (while the file is being read, for example), the resources used to open the file are not released. If you want to ensure that the resources are properly released, you need to use a <a href="https://www.python.org/dev/peps/pep-0343/" rel="nofollow">context manager</a> by writing out a <code>with</code> statement. Your above code would become this:

with open(fname, "r") as fio:
    fct = fio.read()

# continue to do things with `fct`


If you need to support pre-Python 2.5 for some reason, then you'd have to write some hacky code using <code>try</code> and <code>finally</code>. You'd end up with something looking like this:

fio = open(fname, "r")

try:
    fct = fio.read()
finally:
    fio.close()

# Do more stuff with `fct


POST

This line of code is particularly nasty:

SUBMITTED

def int_to_bin

PRE

MID

int_to_bin

POST

There should probably also be a very long lists of tests to make sure
that the serialisation works as expected and e.g. on both Python 2 and 3
for that matter.

In general overly long methods like <code>_encode_value</code> should be split into
meaningful parts.  As a reader it's very hard to keep track of all the
different things that happen in both of them.

I'd suggest to splitting out size calculation, headers and any common
code into methods.

Also, since this is Python 2, consider <code>xrange</code> and any other generators
instead of allocating lists.

For possible extensions, consider the changes you'd need to make to
support serialisation of custom classes / objects.

SUBMITTED

def getDirections

PRE

While Python is a particularly powerful language when it comes to doing a <em>LOT</em> of things in one line... This usually (almost always) is <strong>not</strong> the best idea.  Both for readability, as well as for <em>maintainability</em>.  After all, <a href="https://codegolf.stackexchange.com/questions/75425/find-the-longest-path-avoiding-obstacles-in-a-2d-plane">this isn't Code Golf</a>.

Additionally, you are also <em>constructing</em> the dictionary in <strong>each</strong> call - this is certainly not best practise performance wise (although in this case Python has <em>probably</em> optimized this for you).
But in general, if you have a lookup data structure that will not change throughout your program, you would make it a global variable, or class variable if you were using OOP.

Taken from <a href="https://www.python.org/dev/peps/pep-0008/" rel="nofollow noreferrer">PEP8</a> section on <a href="https://www.python.org/dev/peps/pep-0008/#function-names" rel="nofollow noreferrer">Function Names</a>:

Function names should be lowercase, with words separated by underscores as necessary to improve readability.<br>
  mixedCase is allowed only in contexts where that's already the prevailing style (e.g. threading.py), to retain backwards compatibility

Your function names resemble Java methods, rather than Python functions.  This strikes me as particularly unusual since you seem to be coding in a procedural style. (Often Java programmers will name things in a Java way, but they also use OO).

Rather than:

MID

getDirections

POST

SUBMITTED

h3, #next

PRE

MID

$("#next");

POST

SUBMITTED

background = "yellow";
                            setTimeout(function(e){e.style.background = "";}, 3500, destinationMessage);
                            maxHash = Math.max(destinationMessage.id.slice(destinationMessage.id.indexOf("-")+1), maxHash);
                            elements

PRE

you should probably decide on one

MID

maxHash = Math.max(destinationMessage.id.slice(destinationMessage.id.indexOf("-")+1), maxHash)


that is <em>waaaay</em> to much in one line for a code reviewer like me ;) to be supporting. This:

destinationMessage.id.slice(destinationMessage.id.indexOf("-")+1)


looks like it can become a regex:

( /-(\d+)/.exec(destinationMessage.id) || [])[1]


or even better:

destinationMessage.id.split("-")[1]


POST

SUBMITTED

final String

PRE

MID

String

POST

I do not like the use of <code>String</code> for representing board position and grid candidates. For board positions I think you would have been better to just use grid index \$0\le i\lt 9^2\$. Not only is this more effective because you don't have to do a lot of string comparisons and manipulation, and you don't have to compute the string hash for every lookup in the <code>candidateMap</code>, but it is also more clear to read. 

For the candidates for a given position I think that a <code>Set&lt;Integer&gt;</code> would be better. Again it communicates the intent better and <code>HashSet</code> allows faster, \$\mathcal{O}\left(1\right)\$ lookup compared to <code>String.contains</code> which is \$\mathcal{O}\left(n\right)\$.

I think overall using <code>Map&lt;Integer, Set&lt;Integer&gt;&gt;</code> for <code>candidateMap</code> would be much cleaner and easier to read.

The <code>propagate()</code> function checks for wrong solutions and performs constraint propagation. Because you have <code>isWrong()</code> which you are checking in the DFS then then I don't think that <code>propagate()</code> needs to, or even should check for wrong solutions. 

I think that some of the constants, <code>SQUARES</code>, <code>UNITS</code>, <code>PEERS</code> are a bit hard to understand at a glance. I think mainly this is due to the use of <code>String</code> everywhere. And I think that they subtract from readability.

For example look at the <code>UNITS</code> constant, it is used at exactly one place, in <code>isWrong()</code>. When reading <code>isWrong()</code> I have to look at both the constants and the code and figure out how they relate. For me I would have liked to just read the complete logic in <code>isWrong()</code> without flicking back and forth between constants and board. Same thing goes for <code>PEERS</code> and propagate. 

With that in mind I'm not going to review <code>Constants.java</code> further, even though I think the name is spectacularly bad, at least name it <code>SudokuConstants</code> same thing with <code>Parser</code> and <code>Board</code>.

I don't find the parser particularly interesting and the comments I have already given about use of <code>String</code> would make any review here moot I think.

The name is a bit hard to understand, possible what? Reading the code I see that it repeatedly propagates until either the solution is deemed invalid or there is no change in the board. To be honest I think that this should be done by <code>Board.Propagate()</code> simply because I can't think of a case where you wouldn't want to propagate all the way. 

The depth first search that you have implemented is using back-tracking. The conceptual implementation is this:

SUBMITTED

break
    return items


@given(st.lists(elements=st.integers()))
def test_bubblesort(x):
    assert bubblesort(x) == sorted(x

PRE

Your code looks nice and well tested: congratulations. I have  a few comments anyway.

<strong>A little design/API comment</strong>

Compare <a href="https://docs.python.org/3/library/functions.html?highlight=sorted#sorted" rel="nofollow"><code>sorted</code></a>:

sorted(iterable[, key][, reverse])

<strong>Return a new</strong> sorted list from the items in iterable.

and <a href="https://docs.python.org/3/library/stdtypes.html#list.sort" rel="nofollow"><code>list.sort</code></a>:

sort(*, key=None, reverse=None)

This method sorts the list <strong>in place</strong>[...] it <strong>does not return</strong> the sorted sequence.

The difference is that one operates in place and the other one returns a new list. Your code does both which is likely to be confusing.

<strong>Other various comments</strong>

You could (and probably should) pass the sorting function as a parameter to your testing function. You'd have something like :

MID

@given(st.lists(elements=st.integers()))
def test_sort(x, my_sorted):
    assert my_sorted(x) == sorted(x)


POST

and :

SUBMITTED

output = line.decode(codec, "replace")
if max_width:
    output = "".join(c for c in output if c.isprintable())
    print(output[:max_width])
else:
    print(output

PRE

Something that may help performance wise could be <a href="https://docs.python.org/3.5/library/itertools.html#itertools.islice" rel="nofollow"><code>itertools.islice</code></a>.
This will allow you to call <code>str.isprintable()</code> <code>max_width</code> amount of times,
as this is a binary file that may not have many <code>\n</code>s it can save a lot of effort.

MID

output = line.decode(codec, "replace")
if max_width:
    print("".join(itertools.islice((c for c in output if c.isprintable()), max_width)))
else:
    print(output)


This on it's own may not help on files that have a lot of <code>\n</code>s.
The bottle neck in these file would most likely be the overhead incurred by <code>print</code>.
And so it's much faster to build a string to display once.
In these cases you would want to use something like:<br>
(Untested code)

def read_data(path):
    with open(path) as f:
        for line in f:
            output = line.decode(codec, "replace")
            if max_width:
                yield "".join(itertools.islice(
                    (c for c in output if c.isprintable()),
                    max_width))
            else:
                yield output

print('\n'.join(read_data(...)))


POST

However the above is not good on machines with limited memory or extremely large files.
In these cases you would want to use a buffer and print the buffer when a threshold has been reached.

After <a href="https://www.python.org/dev/peps/pep-3138" rel="nofollow">PEP 3138</a> your method to remove non-printables seems to be the correct way.

SUBMITTED

function __autoload

PRE

MID

__autoload

POST

SUBMITTED

in the order they are played
    std::reverse(m_cardPlays.begin(), m_cardPlays.end());

    bool playListFine = true;
    for(size_t i = 0; i &lt; m_cardPlays.size(); ++i) {
        if(!isValidCard(m_cardPlays.at(i))) {
            playListFine = false;
            break;
        }
    }

    // If invalid card list was given
    if(!playListFine) {
        throw input_file_error("Invalid card play list is given.");
    }
}

Game::Game(const std::string&amp; fName)
{
    getDataFromFile(fName);
}

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Game&amp; cGame)
{
    for(auto

PRE

The constructor for <code>Game</code> currently includees this:

MID

bool playListFine = true;
for(size_t i = 0; i &lt; m_cardPlays.size(); ++i) {
    if(!isValidCard(m_cardPlays.at(i))) {
        playListFine = false;
        break;
    }
}

// If invalid card list was given
if(!playListFine) {
    throw std::runtime_error("Invalid card play list is given.");
}


This could be much simplified since there isn't much point to continuing looking at cards once one invalid one is found:

for (const auto card : m_cardPlays) {
    if (!isValidCard(card)) {
        throw std::runtime_error("Invalid card play list is given.");
    }
}


POST

To answer the question asked in a comment above the <code>Game::sortByAlternatingScore()</code>, yes, there is a nicer way to do it.  Instead of allocating a separate vector, the operation can be done entirely in place:

SUBMITTED

int test(char test[])
{
    int     i;
    char    *pos1

PRE

This is a weird indentation level, it doesn't match anything else and is unnecessary. It literally just complicates how you read it.

MID

int test(char test[])

POST


Naming both your function and variables <code>test</code> is bad practice. How am I meant to tell as an outsider reading your code what it is that your code does.

SUBMITTED

Cell.Text

PRE

This code has basically the same performance issue as your <a href="https://codereview.stackexchange.com/q/123820/36565">last question</a>, and the performance solution is pretty much the same.  Other things to note:

MID

Cell

POST

SUBMITTED

include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;stdlib.h&gt;
#include &lt;fstream&gt;

using namespace std;


void mainmenu();


int choice; 
bool cinfail; 
int confirmation; 
string username, password, password2;

void writetofile(string username){
    ofstream writefile

PRE

Use C++ headers instead of C headers. Change <code>#include &lt;stdlib.h&gt;</code> to <code>#include &lt;cstdlib&gt;</code>. You could actually remove this header altogether because you really should not be calling <code>exit()</code> in this program.

Avoid <code>using namespace std;</code>. You are polluting the global namespace and increasing the probability of naming clashes. If you put <code>using namespace std;</code> into a header, you pollute the global namespace of every user that uses your header. Putting it into a CPP file is not as bad as putting it into a header, but the same dangers exist. <a href="https://stackoverflow.com/questions/1452721/why-is-using-namespace-std-in-c-considered-bad-practice">See this link</a> for more information.

Avoid using global variables when they are not necessary. You want to limit the scope of your variables as much as possible. This program can be rewritten to use no global variable at all.

Use appropriate function names. <code>mainmenu()</code> should be either <code>main_menu()</code> or <code>MainMenu()</code>, <code>writetofile()</code> should be either <code>write_to_file()</code> or <code>WriteToFile()</code>, etc.

Get rid of the unnecessary recursion. Recursion is very nice an clean in some situations. Unfortunately, it's very ugly in this situation. This program can be rewritten to use no recursion at all.

Learn about <a href="http://www.stroustrup.com/bs_faq2.html#finally" rel="nofollow noreferrer">RAII</a>. It is one of the most important aspects of the C++ language. In your <code>writetofile</code> function, you manually call <code>writefile.close();</code>. You do not have to do this. The <code>std::ofstream</code> will automatically clean up its own resources once it goes out of scope. This is one of the reasons why limiting the scope of your variables is important.

Learn about <a href="http://en.cppreference.com/w/cpp/types/numeric_limits" rel="nofollow noreferrer">std::numeric_limits</a>. While <code>cin.ignore(10000,'\n');</code> should work in most cases, <code>std::cin.ignore(std::numeric_limits &lt;std::streamsize&gt;::max(), '\n');</code> will work in more cases.

Now with that out of the way, let's see how we can rewrite this program.

<strong>Headers</strong>

MID

#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;limits&gt; // for std::numeric_limits
#include &lt;string&gt;


<strong>Create a function to get user input</strong>

We want to get rid of the ugly recursion that we have going on. One thing we can do is create a helper function that can read user input for various values. This is a function template. It can return <code>int</code>s, <code>std::string</code>s, and other variable types. If bad input is given to this function, then it asks the user to try again.

template &lt;typename T&gt;
T get_input(const std::string &amp;strQuery)
{
    std::cout &lt;&lt; strQuery &lt;&lt; "\n&gt; ";
    T out = T();

    while (!(std::cin &gt;&gt; out)) {
        std::cin.clear();
        std::cin.ignore(std::numeric_limits &lt;std::streamsize&gt;::max(), '\n');
        std::cout &lt;&lt; "Error!" "\n";
        std::cout &lt;&lt; strQuery &lt;&lt; "\n&gt; ";
    }

    return out;
}


POST

<strong>Rewrite the <code>mainmenu()</code> function</strong>

First we will rename <code>mainmenu()</code> to <code>main_menu()</code>. Second we will use our new <code>get_input()</code> function. Notice that in C++, two string literals next to each other (such as "[1] Login" "\n") are automatically concatenated into one string literal by the compiler. Even if the string literals are on separate lines, as long as there are no semicolons or anything else between them, then the compiler will concatenate them. Using this strategy make your <code>main_menu()</code> class easier to read. Notice that we only need two switch cases. All other cases result in nothing being done.

SUBMITTED

Command : ICommand

PRE

Your implementation looks fine to me. In real life application, you will have base implementations for <code>INotifyPropertyChanged</code> interface, which will cover some of the most common use cases (firing the event, data validation, commit/rollback scenario). You implement those once, and then simply re-use them in your actual view models.

Also:

MID

ICommand

POST

SUBMITTED

echo read : \'"$readSystemGroup

PRE

The script starts with <code>#!/bin/sh</code>, but actually it's using several Bash features that not all implementations of <code>/bin/sh</code> will have. So it's better to make that clear by making the first line <code>#!/bin/bash</code>.

Instead of this:

MID

    echo read : \'"$readSystemGroup"\'


This is exactly the same, just simpler to write and read:

    echo read : "'$readSystemGroup'"


POST

Remember to enclose path variables within double-quotes. You failed to do that for <code>$1</code> here:

SUBMITTED

sys/mman.h&gt;


    //Shared Global variables to control processes 
    static int

PRE

This is ok but unusual, don't put a space between the <code>#</code> and <code>include</code> unless you have a good reason to (sometimes used to show some &quot;indentation&quot; with conditional includes).

MID

//Shared Global variables to control processes 


POST

Those are only used inside <code>main</code>, so no need to make them global. Better would be to separate the two main parts (parent vs child) in two functions, and pass the required data as arguments to those (possibly creating a nice <code>struct</code> to wrap the up).

SUBMITTED

WHERE `Timestamp

PRE

MID

Timestamp

POST

SUBMITTED

pr)
          echo

PRE

The benefit of this approach is that it doesn't run extra programs (no <code>sed</code>, no <code>echo</code>, no piping).

A minor note, the original <code>sed</code> didn't need the <code>g</code> flag.

You don't need <code>""</code> to just echo a blank line:

MID

echo ""


This is exactly the same:

echo


POST

SUBMITTED

line_num: []})
                for value in line.split(delimiter):
                    lines[line_num].append(value)

        else:

            lines = []
            for line_num, line in enumerate(data.split('\n')):
                lines.append([])
                for value in line.split(delimiter):
                    lines[line_num].append(value)

    return lines

PRE

I would like to offer some suggestions that will organize your code a little better and give you some tips that to make things less confusing.

I should first point out that there is already a Python CSV module that already accomplishes what you are setting out to to: <a href="https://docs.python.org/2/library/csv.html" rel="nofollow">https://docs.python.org/2/library/csv.html</a> However I will be constructive with some advice in your current code.

Your doc string is misleading and not complete. According to your description you would expect to give it a file path to a CSV file. Your parameter descriptions are missing what the argument means and the expected value. For example your "field_names" in the doc says "bool" when this is not accurate as it is really a list of column names in the data. Do be as descriptive as possible if your arguments are unclear.

The flexibility in Python allows you to do this and it can be a blessing and also abused. I would think carefully before committing to do this. Ask yourself if a function can return two different types of data, are they actually two different functions? Can one type of data return be easily converted or used to the other if the user so desired? Is your function trying to be too clever? Could there be a separate function that can convert one type to the other so the user can easily understand and control what is going to happen?

In your example, I don't see a need for using a dictionary for preserving line numbers as you can use the index of a list as the line number.

There is a lot of unneeded use of enumerate and dictionary updates in your code. This is both inefficient and doesn't take advantage of Python's strengths.

For example:

MID

lines = []
for line_num, line in enumerate(data.split('\n')):
    lines.append([])
    for value in line.split(delimiter):
        lines[line_num].append(value)


Could be written like this which is more efficient and easier to read:

lines = []
for dataLine in data.split('\n'):
    lines.append(dataLine.split(delimiter))


If using field names, instead of this:

lines = []
for line_num, line in enumerate(data.split('\n')):
    lines.append({})
    for index, value in enumerate(line.split(delimiter)):
        lines[line_num].update({field_names[index]: value})


Do this:

lines = []
for dataLine in data.split('\n'):
    lines.append(dict([(name, value) for name, value in zip(field_names, dataLine.split(delimiter))]))


As I said I would probably break this up into two functions, one to parse and break up the data into lists and return it. Then another function that will accept this data and convert it into a dictionary of dictionaries when using field names:

def parseCSVData(dataString, delimiter=','):
    lines = []
    for data in dataString.split('\n'):
        lines.append(data.split(delimiter))
    return lines

def buildFieldNameDict(csvListData, fieldNames):
    result = []
    for line in csvListData:
        result.append(dict([(name, value) for name, value in zip(fieldNames, line)]))
    return result

csvListData = parseCSVData(myCSVString)
csvFieldDataDict = buildFieldNameDict(csvListData, ['Name', 'Fav_num', 'Birth_month', 'Birth_date', 'Birth_year'])


POST

Overall I would not try to reinvent the wheel if Python provides what you need since it's already written and maintained for you. But this can be a good learning exercise. 

SUBMITTED

computeStandardDeviation(Number... collection) {
        if

PRE

MID

Number... collection

POST

SUBMITTED

upperbound = (int) Math.sqrt

PRE

MID

Math.sqrt()

POST

SUBMITTED

close

PRE

MID

close

POST

SUBMITTED

int sizeDynArr

PRE

You have some helper functions that are only needed inside the <code>dynamicArray.c</code> file. You have suffixed them with an underscore to indicate this. It would be better to (additionally) declare them <code>static</code>. This way, they will be truly private to your implementation file and cannot clash with other functions in other files. It might also make the code smaller and faster.

The function <code>createDynArr</code> is never defined. On the other hand, there is <code>initDynArr</code> which is not declared in the header. This is good, because the function is not needed by clients. You should delete the declaration of <code>createDynArr</code> from the header file and make <code>initDynArr</code> a <code>static</code> function.

MID

sizeDynArr

POST

SUBMITTED

_update: function(oHtml, oConfig) {
        var _this = this;
        var oParent;
        if (oConfig.attributes != null) {
            oConfig.attributes.forEach(function(oAttr) {
                //debugger;
                oParent = oHtml.find("#" + oAttr.id);
                switch (oAttr.action) {
                    case 'upd':
                        _this._updateAttr(oParent, oAttr);
                        break;
                    case 'new':
                        _this._insertAttr(oParent, oAttr);
                        break;
                    case 'del':
                        _this._removeAttr(oParent, oAttr);
                }
            });
            return oHtml

PRE

You can try something like this, saving the names of the functions in a variable, and then accessing the variable with the name of the action, you can also save the reference of the functions of the variable in the properties and you would not have to use 'this'

MID

_update: function(oHtml, oConfig) {
    var _this = this;
    var oParent;
    var actionsToExecute = {
      upd : '_updateAttr',
      new : '_insertAttr',
      del : '_removeAttr'
    }
    if (oConfig.attributes != null) {
        oConfig.attributes.forEach(function(oAttr) {
            //debugger;
            oParent = oHtml.find("#" + oAttr.id);
            _this[actionsToExecute[oAttr.action]](oParent,oAttr)
        });
        return oHtml;
    }
},


POST

SUBMITTED

and 2");
                    }
                }
                catch

PRE

MID

catch

POST

SUBMITTED

nextchoice

PRE

MID

nextchoice()

POST

SUBMITTED

xyzmin = np.min(xyz,axis=0)
xyzmax = np.max(xyz,axis

PRE

I have twisted the problem a little and find a way of optimize it at the cost of only get the information of one level of subdivision.

Whith this I mean that the bellow method obtains the same result as the method posted on the question (it assings 1 unique index to all the points that are inside a node) but instead of having a concatenation of the indexes obtained along all the subdivisions untill the last one, the indexes are only based on one unique level (what would be the last level in the previous method) of subdivision.

So, starting again from a point cloud, I get the minimum bounding box as before:

MID

xyzmin = np.min(xyz,axis=0)
xyzmax = np.max(xyz,axis=0)


POST

But now I also instanciate a variable <code>n</code> wich represent the subdivision level where I want to locate the points. In the above question this variable correspond to the <code>X</code> in the line first line of the while loop: <code>while n &lt; X</code>

SUBMITTED

Game {

    List&lt;Player&gt; listOfPlayers = new ArrayList&lt;&gt;();
    private Dice dice = new Dice();
    private int scoreToWin

PRE

<a href="https://en.wikipedia.org/wiki/Javadoc" rel="nofollow">Javadoc, Javadoc, Javadoc</a>

MID

List&lt;Player&gt; listOfPlayers = new ArrayList&lt;&gt;();


<code>players</code> is a completely sufficient name, as it already tells me that it is a collection of some sort. Also, why is this member package private?

while (optionSelected &lt; 0 || 5 &lt; optionSelected) {


That's odd to read, easier to understand is this:

while (optionSelect &lt; 0 || optionSelected &gt; 5) {


POST

SUBMITTED

lt;TMessageDataType&gt;(SourceQueue);
            while (message != null)
            {
                // This overload of WorkBatch returns void
                WorkBatch(message.Data, workMethod);
                ExecuteOnQueue&lt;TMessageDataType

PRE

I'm not sure if this would work as intended, but what if <strong>instead of not returning anything, you'd return nothing</strong>?

Think <strong>null object pattern</strong>: return an object that behaves "neutral" and doesn't do anything except moving along with the flock like any other regular object would do.

MID

// This overload of WorkBatch returns void
WorkBatch(message.Data, workMethod);


POST

What if you make this <code>WorkBatch</code> <strong>return an empty <code>IEnumerable&lt;TNextQueueMessageDataType&gt;</code></strong> instead?

You can then feed it to <code>Message&lt;TNextQueueMessageDataType&gt;.WithData()</code> and it wouldn't do anything, because it operates on an empty list.

Of course this assumes that an <strong>empty <code>IEnumerable&lt;TNextQueueMessageDataType&gt;</code> is nothing that <code>WorkBatch(message.Data, compositionFunction)</code> would regularly produce</strong> or that would <strong>cause <code>Message&lt;TNextQueueMessageDataType&gt;.WithData()</code> to have some functionality that's different from it not being executed</strong>.

I guess<code>Enumerable.Empty&lt;TNextQueueMessageDataType&gt;();</code> would do the trick of returning the empty <code>IEnumerable&lt;TNextQueueMessageDataType&gt;</code>.

SUBMITTED

_subscriptions.add(
                jamSpeakServiceApi.getAllWords()
                        .subscribeOn(Schedulers.io())
                        .observeOn(AndroidSchedulers.mainThread())
                        .subscribe(new Observer&lt;List&lt;WordApi&gt;&gt;() {
                            @Override
                            public void onCompleted() {
                                Log.d("retroffit Completed", "Completed");
                            }

                            @Override
                            public void onError(Throwable e) {
                                Log.d("retroffit error", e.toString());
                            }

                            @Override
                            public void onNext(List&lt;WordApi&gt; wordApis) {
                                /*Observable.from(wordApis)
                                        .filter(s -&gt; Word.getWordFormDatabase(s.getWord()) != null)
                                        .filter(s -&gt; s.getCountry().toLowerCase().equals("jamaica"))
                                        .filter(s -&gt; Word.getWordLikeFormDatabase(s.getWord()) != null)
                                        .subscribe();*/

                                for (WordApi x: wordApis){
                                    if(x.getCountry().toLowerCase().equals("jamaica")== true){
                                        Word.saveWordFromApi(x);
                                        Log.d(x.getWord(),x.getWord

PRE

You should use <code>flat</code> to emit each <code>wordApi</code> and then you will be able to filter your data and apply your function one by one. 

Your stream should look like this:

MID

jamSpeakServiceApi.getAllWords()
            .subscribeOn(Schedulers.io())
            .flatMap(wordApis -&gt; Observable.from(wordApis))
            .filter(wordApi -&gt; wordApi.getCountry().toLowerCase().equals("jamaica"))
            .observeOn(AndroidSchedulers.mainThread())
            .subscribe(new Observer&lt;WordApi&gt;() {
                @Override
                public void onCompleted() {
                    Log.d("retroffit Completed", "Completed");
                }

                @Override
                public void onError(Throwable e) {
                    Log.d("retroffit error", e.toString());
                }

                @Override
                public void onNext(WordApi wordApi) {
                    Word.saveWordFromApi(wordApi);
                    Log.d(wordApi.getWord(),wordApi.getWord());
                }
            })


POST

I used some lambdas, and I recommend you to use them too. Take a look at the Retrolambda Gradle plugin. It works well with an Android environment.

SUBMITTED

last_char == "append":
                args[current_args_index] += char
            elif last_char == " ":
                args.append("")
                #To

PRE

I wouldn't convert it to an integer within a <code>lambda</code> function.  I would create a whole function that uses a <code>try</code> block in case the user doesn't type a valid number.  That is also helpful if the user does type a number, but types a number that is too big or too small.

MID

elif last_char == "append"
...
    last_char = "append"


POST

Don't use magic numbers (or magic values).  You should define a constant called <code>APPEND</code> that can really be assigned to any object except a single-character string.

SUBMITTED

load view

PRE

MID

$view

POST

SUBMITTED

using System.Linq;
using

PRE

MID

System.Linq

POST

SUBMITTED

InitializeComponent();

            // sends array of buttons, alertTextBlock and resetButton to TicTacToe game
            textAlert = AlertTextBlock;
            buttons = new Button[9];

            buttons[0] = button1x1;
            buttons[1] = button1x2;
            buttons[2] = button1x3;
            buttons[3] = button2x1;
            buttons[4] = button2x2;
            buttons[5] = button2x3;
            buttons[6] = button3x1;
            buttons[7] = button3x2;
            buttons[8] = button3x3;
            resetButt = resetButton;


            game = new TicTacToeGame(buttons, textAlert, resetButt

PRE

You can do something similar for the Tie checking.

7 . Use braces <code>{ }</code> even one line <code>if</code> statements should have those it brings more readability to your code.

One last addition, that's something you might want to do (not necessary). 

MID

        buttons = new Button[9];

        buttons[0] = button1x1;
        buttons[1] = button1x2;
        buttons[2] = button1x3;
        buttons[3] = button2x1;
        buttons[4] = button2x2;
        buttons[5] = button2x3;
        buttons[6] = button3x1;
        buttons[7] = button3x2;
        buttons[8] = button3x3;


POST

You already have an array of buttons. Just create everything during the runtime set the <code>Location</code>,<code>Size</code>, and all the other properties of a button you need from the code behind.

SUBMITTED

require "complex"

a = complex.new (0,1)
b = complex.new (7,1) 
c = complex.new (1,6.4) 

t = {a="a",
    b="b",
    c="c"}

print (t["a

PRE

If you are trying to print the numbers, your syntax is wrong.

MID

require "complex"
a = complex.new (0,1)
b =    complex.new (7,1)
c = complex.new (1,6.4)
t = {a="a", b="b", c="c"}
print (t["a"])


This will only print "a"

require "complex"
a = complex.new(0, 1)
b = complex.new(7, 1)
c = complex.new(1, 6.4)
t = {
  a = a,
  b = b,
  c = c
}
print(t.a)


Try that

To iterate through the table, you might do this

require "complex"
a,b,c = ...
t = ...
for K,V in next,t do
  print(K,V)
end


POST

SUBMITTED

PieceColor).Item1

PRE

MID

Item1

POST

SUBMITTED

m/matrix (reverse m)))

(defn rotate-left [m]
  "rotates the matrix m 90 degrees to the left."
  (-&gt; m
      transpose
      reverse-rows))

(defn rotate-and-chop [m]
  "repeatedly rotates matrix m 90 degrees and cuts off the 
   top till matrix is empty."
  (if (empty? m) nil
      (conj (rotate-and-chop (-&gt; m
                                 delete-first-row
                                 rotate-left))
            (get-first-row m))))

(defn spiral [size]
  "creates list of values

PRE

Your <code>get-first-row</code>, <code>delete-first-row</code>, <code>transpose</code>, and <code>reverse-rows</code> functions are equivalent to the already available <a href="http://clojuredocs.org/clojure.core/first" rel="nofollow noreferrer"><code>first</code></a>, <a href="http://clojuredocs.org/clojure.core/rest" rel="nofollow noreferrer"><code>rest</code></a>, <a href="https://mikera.github.io/core.matrix/doc/clojure.core.matrix.html#var-transpose" rel="nofollow noreferrer"><code>transpose</code></a>, and <a href="http://clojuredocs.org/clojure.core/reverse" rel="nofollow noreferrer"><code>reverse</code></a> functions, respectively, so I would just remove them; they add no value to your code.

It's <a href="https://github.com/bbatsov/clojure-style-guide#body-indentation" rel="nofollow noreferrer">conventional</a> to indent the "then" branch (and the "else" branch, if present) of an <a href="http://clojuredocs.org/clojure.core/if" rel="nofollow noreferrer"><code>if</code></a> or <a href="http://clojuredocs.org/clojure.core/when" rel="nofollow noreferrer"><code>when</code></a> expression by two spaces. So in <code>rotate-and-chop</code>, since your first branch is <code>nil</code>, it would be more idiomatic to write it as <code>(when-not (empty? m) ,,,)</code> or just <code>(when (seq m) ,,,)</code>. Also, it might be more readable to put the call to <code>rotate-and-chop</code> into the threading macro:

MID

(defn rotate-and-chop
  "repeatedly rotates matrix m 90 degrees and cuts off the
  top till matrix is empty."
  [m]
  (when (seq m)
    (conj (-&gt; m rest rotate-left rotate-and-chop)
          (first m))))


POST

In <code>spiral</code>, you use <code>flatten</code> to concatenate the elements of the sequence returned by <code>rotate-and-chop</code> into a single sequence. While this does work in your case, I would generally advise against using <code>flatten</code>, because it can lead to unexpected behavior when you don't know what type of data is in the sequences you're concatenating. Usually you just need to flatten the outermost layer, in which case you can simply <a href="http://clojuredocs.org/clojure.core/apply" rel="nofollow noreferrer"><code>apply</code></a> the <a href="http://clojuredocs.org/clojure.core/concat" rel="nofollow noreferrer"><code>concat</code></a> function:

SUBMITTED

lt;Card

PRE

MID

Card

Specify the access modifiers of the class and members properly.
Use proper names for members:

class  Card{
    Suit s;
    Rank r;


POST

for example:

SUBMITTED

lt;/img&gt;');
                                        });
                                };
                            });
                        });
                    });
&lt;/script&gt;

&lt;script&gt;
            $('#hearthstone').click(function(){
            $('#twitch').children().fadeOut(500).promise().then(function() {
            $('#twitch').empty();;
            var twitchApi = "https://api.twitch.tv/kraken/streams?game=Hearthstone:%20Heroes%20of%20Warcraft";
            $.getJSON(twitchApi, function (json) {
            for (var i = 0; i &lt; 9; i++) {
            var streamGame = json.streams[i].game;
            var streamThumb = json.streams[i].preview.medium;
            var streamVideo = json.streams[i].channel.name;
            $('#twitch').append('&lt;img style="width: 250px; height: 250px;" src="' + streamThumb + '"&gt;&lt;/img&gt;'); 
        }
    });
});});
&lt;/script&gt;

&lt;script&gt;
            $('#cs').click(function(){
            $('#twitch').children().fadeOut(500).promise().then(function() {
            $('#twitch').empty();
            var twitchApi = "https://api.twitch.tv/kraken/streams?game=Counter-Strike:%20Global%20Offensive";
            $.getJSON(twitchApi, function (json) {
            for (var i = 0; i &lt; 9; i++) {
                var streamGame = json.streams[i].game;
            var streamThumb = json.streams[i].preview.medium;
            var streamVideo = json.streams[i].channel.name;
            $('#twitch').append('&lt;img style="width: 250px; height: 250px;" src="' + streamThumb + '"&gt;&lt;/img&gt;'); 
        }
    });
});});
&lt;/script&gt;

    &lt;/div&gt

PRE

So you can setup a jQuery selector to respond to click events for each <code>div</code> inside the parent <code>div</code> with <code>id="games"</code>. This would then be placed inside your document ready function <code>$(function(){...});</code>. Once the event is triggered you can find the <code>p</code> element inside the div that was clicked and get the <code>text()</code> value which would be the name of the game. 

MID

$('div#games div').onclick(function(){
   var gameDiv = $(this); // Get which div was clicked here
   $('#twitch').children().fadeOut(500).promise().then(function() {
        $('#twitch').empty();
        var gameName = $(gameDiv).find('p').text().replace(' ', '%20');  // Get the game name
        var twitchApi = "https://api.twitch.tv/kraken/streams?game=" + gameName;   // Build the URL here
        $.getJSON(twitchApi, function(json) {
            for (var i = 0; i &lt; 9; i++) {
                var streamGame = json.streams[i].game;
                var streamThumb = json.streams[i].preview.medium;
                var streamVideo = json.streams[i].channel.name;
                $('#twitch').children().fadeIn(500).promise().then(function() {
                    $('#twitch').append('&lt;img style="width: 250px; height: 250px;" src="' +streamThumb + '"&gt;&lt;/img&gt;');
                });
            }
        });
    });
});


POST

SUBMITTED

def bezier

PRE

Did you mean pythagoras? Oh, no, you meant <code>distance</code>.

MID

bezier

POST

What are f,g? It looks like it returns two values based on <code>t</code>, but it is not clear to me what the expressions signify. How did you get those expressions?

It probably derives somehow from <code>f(x) = sqrt(1-x^2)</code> and its derivatives.

Maybe it would help if you could show us what the code looks like for the arclength of the arc formed by <code>f(x) = 1</code> between -1 and 1 (it should return 2).

Also, the arc-length runs the risk of running into a recursion-error. And it's slow due to function calls.

Suggested implementation (typed on phone, untested):

SUBMITTED

dir = Path.GetDirectoryName(entry.FileName);
                    if (!Directory.Exists(dir))
                    {
                        Directory.CreateDirectory(dir);
                    }
                    if (entry.Length &gt; INTERNAL_BUFFER)
                    {
                        fs = File.Create(entry.FileName, INTERNAL_BUFFER);
                    }
                    else
                    {
                        fs = File.Create(entry.FileName);
                    }
                    fs.SetLength(entry.Length);
                    fs

PRE

<strong>Ternary operator</strong>

You can shorten this with the help of the ternary operator (I've already used that in one of the examples of the <code>using</code> statement):

MID

if (entry.Length &gt; INTERNAL_BUFFER)
{
    fs = File.Create(entry.FileName, INTERNAL_BUFFER);
}
else
{
    fs = File.Create(entry.FileName);
}


fs = entry.Length &gt; INTERNAL_BUFFER
    ? File.Create(entry.FileName, INTERNAL_BUFFER)
    : File.Create(entry.FileName);


POST

<strong>Empty try/catch block</strong>

Empty try/catch blocks are generally a bad practice, you either handle the exception in a way, or you fix the code so that there is no such exception.

SUBMITTED

result = new ArrayList&lt;String&gt;();
            for (List&lt;String&gt; string : subList) {
                result

PRE

Otherwise I would have needed to use more lines in the caller.  

This version outputs the products in the same order as shown in your question, where your code outputs them in reverse order.  I don't know if this matters or not.  

I find this to be more straightforward than your version.  It builds up to the answer.  Your version builds the answer on its way back from the recursion, which is why the results are backwards.  

It also avoids some things that I didn't like about your version:  

MID

            for (List&lt;String&gt; string : subList) {


POST

I'm not sure exactly what it is, but it's not a <code>string</code>.  It's a <code>List</code>.  I'd have probably called it something like <code>strings</code> or <code>pieces</code> in lieu of a better name.  

SUBMITTED

If

    If IsEmpty(inputValue) Then
        PrintErrorMessage EMPTY_ERROR_TEXT
        Stop
    End If

    On Error Resume Next
        If Len(inputValue) = 0 Then
            PrintErrorMessage ZLS_ERROR_TEXT
            Stop
        End If
    On Error GoTo 0

End Sub

Private Sub GetBounds(Optional

PRE

I learned something from this

MID

On Error Resume Next
    If Len(inputValue) = 0 Then
        PrintErrorMessage ZLS_ERROR_TEXT
        Stop
    End If
On Error GoTo 0


POST

I learned that <code>On Error GoTo 0</code> <em>disables error handling in the current procedure</em>. The <a href="https://msdn.microsoft.com/en-us/library/5hsw66as.aspx" rel="nofollow">KB</a> also says:

Without an On Error GoTo 0 statement, an error handler is
  automatically disabled when a procedure is exited.

So you really don't need it. I also can't figure out under what conditions the <code>len</code> would error. The only thing I could think of is if it's an object, but you've exited by that point. It can't be a negative length can it?

SUBMITTED

a state
    var id : String { get

PRE

MID

var id: String

POST

SUBMITTED

Collections.sort(listEntries, new Comparator&lt;LogEntry&gt;() {
            @Override
            public int compare(LogEntry lhs, LogEntry rhs) {
                Calendar lhsCreatedAt = Calendar.getInstance();
                Calendar rhsCreatedAt = Calendar.getInstance();
                lhsCreatedAt.setTimeInMillis(lhs.getCreatedAt());
                rhsCreatedAt.setTimeInMillis(rhs.getCreatedAt());
                if (lhsCreatedAt

PRE

Main problem that I see, is cast to <strong>int</strong>, as it will overflow in
   23 days!!!

Regarding 24:00 correctness, that depends is that ticks in local timezone or UTC and if you care, but I'd suggest to write Unit Test that validates this algorithm on some set of events, for whole year, and lot of events per day, to verify every case.

Additionally make millisecondsPerDay a constant inside Comparator, but upper then method

MID

new Comparator&lt;LogEntry&gt;() {
        static final long MILLISECONDS_PER_DAY = 86400000;
        @Override
        public int compare(LogEntry lhs, LogEntry rhs) { ...}
}


<strong>EDIT</strong>

You don't need Math.floor, as this is integral numbers, so dividing gives number of days as integral number.

I'd suggest following code:

Collections.sort(listEntries, new Comparator&lt;LogEntry&gt;() {

        static final long MILLISECONDS_PER_DAY = 86400000;

        @Override
        public int compare(LogEntry lhs, LogEntry rhs) {
            long lhsCreatedAt = lhs.getCreatedAt();
            long rhsCreatedAt = rhs.getCreatedAt();

            long lhsDays = lhsCreatedAt/MILLISECONDS_PER_DAY;
            long rhsDays = rhsCreatedAt/MILLISECONDS_PER_DAY;
            if(lhsDays == rhsDays){
                 return (int)(lhsCreatedAt%MILLISECONDS_PER_DAY - rhsCreatedAt%MILLISECONDS_PER_DAY)
            }
            return (int)(rhsDays-lhsDays);
        }
    });


POST

Well, if block can be following, as long as we are in the same day, no need to divide additional time:

SUBMITTED

No log file found.\n" ${1%.*}
    fi
}

if [[ -z $1 ]]; then getAll; fi
while [[ ! -z $1 ]]; do
    getOnly $1
    shift
done

PRE

This code is a bit sloppy, because if <code>$1</code> is empty,
then the <code>while</code> doesn't need to be executed:

MID

if [[ -z $1 ]]; then getAll; fi
while [[ ! -z $1 ]]; do
    getOnly $1
    shift
done


It would be more appropriate to move the loop inside the <code>else</code> branch:

if [[ -z $1 ]]; then
    getAll
else
    while [[ ! -z $1 ]]; do
        getOnly $1
        shift
    done
fi


I'm guessing that the intention here is to call <code>getAll</code> if there are no arguments.
But strictly speaking <code>[[ -z $1 ]]</code> doesn't mean there are no arguments,
it just means that the first argument is empty.
The correct way to check that there are no arguments:

if [[ $# == 0 ]]; then


And instead of a <code>while</code> loop, it would be more natural to use a <code>for</code> loop here:

    for commandfile in "$@"; do
        getOnly "$commandfile"
    done


POST

Lastly, at many places you did not quote variables that are paths.
I'm guessing you did that because you are certain they will never contain spaces. Even so, it's a good habit to double-quote such variables.

SUBMITTED

namespace PdfScriptTool

PRE

Boy, that's <em>a lot</em> of <code>using</code> statements. A number of things don't look right here:

MID

namespace

POST

SUBMITTED

nQueens.backTrackRoutine

PRE

MID

backTrackRoutine

POST

SUBMITTED

def index
    @weights = Weight.where(:user_id =&gt; current_user.id).order(day: :desc)
    @weight_loss = WeightCalculator.new(@profile, current_user).weight_loss
    @weeks = WeightCalculator.new(@profile, current_user).timeframe

    @result = {}
    Weight.where(:user_id =&gt; current_user.id).each do |weight

PRE

There is really quite a lot wrong here.

As a <em>very</em> simple improvement, why aren't you using ActiveRecord's associations? Why do you constantly do this...

MID

Weight.where(:user_id =&gt; current_user.id).each ...
# ...
@current_weight = Weight.where(:user_id =&gt; @user.id).order(:day).last


Instead of this?

current_user.weights.each ...
# ... 
current_weight = @user.weights.order(:day).last


POST

That alone would drastically improve the readability of your code.

You can also make the loop in your <code>index</code> action more idiomatic:

SUBMITTED

Optional vDefaultValue

PRE

MID

vDefaultValue

POST

SUBMITTED

argv, stdin

PRE

MID

stdin

POST

SUBMITTED

else{return err

PRE

Lastly...

MID

else{return err;}


POST

Don't you want to <code>throw</code> instead?

SUBMITTED

Array

PRE

MID

Array

POST

SUBMITTED

sec

PRE

MID

"sec"

POST

SUBMITTED

in range(1,13):
        monthlyInterestRate = annualInterestRate / 12.0
        minimumMonthlyPayment = round(monthlyPaymentRate * balance, 2)
        monthlyUnpaidBalance = balance - minimumMonthlyPayment
        updatedBalanceEachMonth = round(monthlyUnpaidBalance + (monthlyInterestRate * monthlyUnpaidBalance

PRE

There exists a style guide for python, <a href="https://www.python.org/dev/peps/pep-0008/" rel="nofollow">PEP8</a>, which programmers are encouraged to follow. It recommends <code>lower_case</code> variable and function names. While doing that I would choose slightly shorter (but still descriptive) names to improve readability.

If you move your string describing the function into the function definition itself, it becomes a <code>docstring</code>. This allows you e.g to call <code>help(function_name)</code> to get a description of the function.

Try to avoid using string addition because it creates an additional temporary variable for each addition. Rather use <code>format</code> (with its syntax described <a href="https://docs.python.org/2/library/string.html#format-specification-mini-language" rel="nofollow">here</a>). You can also use multi-line strings here.

I would move the calculation of the monthly interest rate out of the loop, it does not change.

Avoid unused temporary variables. The variable <code>updatedBalanceEachMonth</code> is only used for printing and assigning <code>balance</code> to its value at the end. Rather update <code>balance</code> right away.

The calculation of the new balance can also be simplified somewhat from:

MID

monthlyUnpaidBalance = balance - minimumMonthlyPayment
        updatedBalanceEachMonth = round(monthlyUnpaidBalance + (monthlyInterestRate * monthlyUnpaidBalance) , 2) 


to:

    updatedBalanceEachMonth = round((1 + monthlyInterestRate) * (balance - minimumMonthlyPayment), 2) 


This way, the intermediate variable is no longer needed.

If you did not want to print the minimum payment, it could even be simplified further:

balance = round((1 + interest_rate) * (1 - payment_rate) * balance, 2)


POST

I would make the function return either the new balance or the total amount paid. This way it could be used elsewhere. For this to be practical, you should maybe make the printing optional and guard the test call guarded by a <code>if __name__ == "__main__":</code> clause.

<strong>Final code:</strong>

SUBMITTED

test.num_infinite_cycles

PRE

MID

num_infinite_cycles

POST

SUBMITTED

gt; ();
        var img = button.AddComponent&lt;Image&gt; ();
        var nav = new Navigation ();
        nav.mode = Navigation.Mode.None;
        b.navigation = nav;
        b.targetGraphic = img;
        img

PRE

<em>(2) This:</em>

MID

var nav = new Navigation ();
nav.mode = Navigation.Mode.None;
b.navigation = nav;


<em>(2) Could Be:</em>

b.navigation = new Navigation()
{
    mode = Navigation.Mode.None
};


POST

<em>(3) This:</em>

SUBMITTED

final int SECOND_NUMBER_INDEX = 1;

    public int[] sort(int[] numbers

PRE

MID

int[] sort(int[] numbers)

POST

SUBMITTED

index)=='x

PRE

So if the input string is "xxhixx":

MID

x

POST

SUBMITTED

Treenode {
      public int value;
      public Treenode right;
      public Treenode left;
      public Treenode(int value) {
        this.value = value;
        this.left = null;
        this.right = null;
    }
    }
    public class SearchTree

PRE

<strong>Introduction</strong>

I noticed that your demo binary tree is not sorted by values, so I assume that we are dealing with the unsorted version of the data structure.

<strong>Default values for reference fields</strong>

MID

public Treenode(int value) {
    this.value = value;
    this.left = null;
    this.right = null;
}


In Java, the reference fields are initialized with the value <strong><code>null</code></strong> by default. You can simply write

public Treenode(int value) {
    this.value = value;
}


POST

<strong>Actual algorithms</strong>

Your BFS and DFS seem like overkilling it. See <strong>Summa summarum</strong> for an alternative implementation.

<strong>Static vs. non-static</strong>

SUBMITTED

var title

PRE

MID

title

POST

A final advice is that writing code follows the same rules as writing prose, dont repeat yourself (too much) aka DRY.

SUBMITTED

lt;vector&gt;
using namespace std

PRE

MID

using namespace std;


POST

<a href="https://stackoverflow.com/q/1452721">Why is “using namespace std;” considered bad practice?</a>

Personally, I find code more readable if it says what namespace is being used.  E.g. <code>std::sqrt</code>.  

SUBMITTED

include &lt;functional&gt;


template&lt;typename F, typename... Args&gt;
class finally
{
public:

  finally(F action, const Args&amp;... args) :
      _action(std::bind(action, args...))
  {}
  ~finally()
  {
    if(enabled)
      _action();
  }

  bool enabled = true;

private:

  std::function&lt;void()&gt; _action

PRE

You can avoid specifying argument types twice by employing a constructor template:

MID

template&lt;typename F&gt;
class finally
{
public:
  template&lt;typename... Args&gt;
  finally&lt;F&gt;(F action, const Args&amp;... args) { /* business as usual */ }
  ...
};


But that's not everything. The <code>std::bind</code>'s arguments are either copied or moved, they are never passed by reference. Thus, despite <code>const Args&amp;... args</code>, you might end up copying your arguments.

To void this issue, consider using perfect forwarding (as well as ditching <code>std::bind</code>):

template&lt;typename... Args&gt;
finally&lt;F&gt;(F action, Args&amp;&amp;... args) :
    _action([action, &amp;args...]{ action(std::forward&lt;Args&gt;(args)...); }) {}


POST

Another thing worth considering is the exception safety of <code>action</code>. Since you're invoking it in a destructor, you're risking facing <code>std::terminate</code> if it throws. A small <code>try</code> block will fix it. Also, as of now, <code>enabled</code> seems redundant.

And yes, even with all these fixes, the semantics of <code>finally</code> seems rather unpleasant compared to <a href="https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Scope_Guard" rel="nofollow">more traditional scope guards.</a> At least to me.

Edit: full code - <a href="https://ideone.com/iThn0i" rel="nofollow">https://ideone.com/iThn0i</a>

SUBMITTED

b

PRE

MID

b

b

b

POST

SUBMITTED

String Path){
        File f = new File(Path);
        if (!(f.exists() &amp;&amp; !f.isDirectory())) {  
           return false;
        }else {
           return true;
        }
    }
   public void loadPoints() throws IOException

PRE

In general if you're creating a constant you use the keywords <code>static</code> and <code>final</code> and name it with all capital letters with underscores to separate words - for example: TXT_PATH_PLAYER. You can read <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/classvars.html" rel="nofollow">this page</a> for more details about why this is done.

This is somewhat a personal preference but I find that positive expressions are more easy to read than negative ones. For example in your <code>fileExists</code> method you have this: 

MID

if (!(f.exists() &amp;&amp; !f.isDirectory())) {  
   return false;
}else {
   return true;
}


This forces me to stop for a moment and think through what the logic is doing. If it were written like this: 

if (f.exists() &amp;&amp; !f.isDirectory()) {  
   return true;
}else {
   return false;
}


POST

I can very easily see that it is going to return true when a file exists and is not a directory. You could even simplify this method more by directly returning the result of your boolean expression like this: 

<code>return f.exists() &amp;&amp; !f.isDirectory();</code>

Looking at the <code>updatePoints</code> method I think the different game modes or "options" as they're called in the code deserve to be represented as objects. The <code>updatePoints</code> logic is handling the calculation of points for each mode when, if you had an object to represent each mode, the objects themselves could have a method that takes <code>numGuesses</code> as a parameter and returns the number of points the player earned. Also, the <code>Game.options</code> method would be simplified as each object could have its own value for <code>numberOfMines</code> and <code>max</code>. If you really feel ambitious you could use an <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html" rel="nofollow">enum</a> to represent them since there is a fixed number of them and they do not change.

In conclusion I think you've done some great work so far. You have a good start on a modular design and most of the code is easy to read. Just don't be afraid to go back and change names of methods and variables. Try to think from an outsider perspective and consider the purpose of each variable or method when you name them. Remember that sometimes less is more - a simple method is easier to maintain than a complex one. If you have a complex task try to break it into smaller reusable pieces. To help with debugging I recommend you either throw in some System.out.println statements or research some java logging frameworks like SLF4J, Apache Commons Logging, log4j, logback, etc. Logging can be a huge help - especially in larger projects. Another thing you should consider is learning about <a href="http://junit.org/junit4/" rel="nofollow">JUnit</a> and creating some automated tests for your code.

Take care!

SUBMITTED

def runningSums

PRE

<code>pairwise</code> can easily be found in the <a href="https://docs.python.org/3/library/itertools.html#recipes" rel="nofollow"><code>itertools</code> documentation</a>.

MID

runningSums

POST

I think that referencing the list while you are building it is overcomplicated, I would use a variable to be incremented:

SUBMITTED

let foldScript (storeAppScripts : seq&lt;string * string * string&gt;) =
    storeAppScripts
       |&gt; Seq.choose( fun (store, app, script) -&gt;
                            match script with
                                | "" -&gt; None
                                | _ -&gt; Some (store, app, script) )
       |&gt; Seq.groupBy(fun (store, app, script) -&gt; store)
       |&gt; Seq.map(fun (store, group) -&gt; store, (group
                                                    |&gt; Seq.groupBy(fun (_, app, _)-&gt; app)
                                                    |&gt; Seq.map(fun (app, group) -&gt; app , (group |&gt;  Seq.fold(fun accum (_,_, script) -&gt; sprintf "%s\r\n%s" accum script) ""))
                                                    |&gt; Seq.map(fun (app, script) -&gt; sprintf "\r\n\tuse Application = %s  %s"  app (script.ToString()))))
        |&gt; Seq.map(fun (store, script) -&gt;
                                    sprintf "use Store=%s%s" store (script |&gt; Seq.fold( fun accum appScript -&gt; sprintf "%s%s" accum appScript) ""))
        |&gt; Seq.fold(fun acc script -&gt; sprintf "%s\r\n%s" acc script) ""

let s = [("s1", "a1", "script1"); ("s1", "a2", "script2");  ("s2", "a3", "script4")]
let r = foldScript s

//Expected result 
// use Store=s1
//    use Application = a1
//      script1
//    use Application = a2
//      script2
// use Store=s2
//    use Application = a3
//      script1

PRE

I'll start with the code and explain after

MID

let foldScript =
  let isScriptNonEmpty { Script = script } = script &lt;&gt; ""
  let foldAppScripts =
    let foldScripts = Seq.fold (fun acc { Script = script } -&gt; sprintf "%s\r\n%s" acc script) ""
    Seq.groupBy (fun { App = app } -&gt; app)
    &gt;&gt; Seq.map (fun (app, group) -&gt; sprintf "\r\n\tuse Application = %s  %s" app &lt;| foldScripts group)
    &gt;&gt; Seq.fold (sprintf "%s%s") ""

  Seq.filter isScriptNonEmpty
  &gt;&gt; Seq.groupBy (fun { Store = store } -&gt; store)
  &gt;&gt; Seq.map (fun (store, group) -&gt; sprintf "use Store=%s%s" store &lt;| foldAppScripts group)
  &gt;&gt; String.concat "\r\n"

let s = [ { Store = "s1"; App = "a1"; Script = "script1" }; { Store = "s1"; App = "a2"; Script = "script2" }; { Store = "s2"; App = "a3"; Script = "script4" }]
let r = foldScript s


First I made inner "function" to ease readability and reused the <code>Script</code> type <a href="https://stackoverflow.com/a/38253736/4925216">Reed</a> talked about because it's a good idea

Then you can pattern match (deconstruct) on record almost anywhere so<br>
(if there are multiple record type with same field name you'll have to qualify it but that's not the case here)

The <code>foldAppScripts</code> "function" have itself an inner "function"

I choose to favor function composition (and so made "function value") if it doesn't suit you, you can put back the argument and pipe over it

I used the backward pipe to avoid using parenthesis (also a matter of taste)

The last <code>Seq.fold</code> of <code>foldAppScripts</code> use eta-reduction (transforming <code>fun arg -&gt; fct arg</code> in just <code>fct</code>)

Your <code>script.ToString ()</code> isn't needed as <code>script</code> is already a string

I replace your last fold by a call to String.concat

Performance wise you could try to use a <code>StringBuilder</code> (and use <code>Printf.bprintf</code>) but it's not so easy to use

We could go further and remove each lambda by a named function (self documentation) but that's maybe overkill.

After toying a little more with this I think I managed to make the StringBuilder version working.<br>
<em>Not sure it was worth the effort my (simplistic) measurements show a quicker first version (some ms for 100k items so negligible) but the second has a little less pressure on GC gen 1</em><br>
But that was mainly for the experiment (I finally used <code>Printf.kbprintf</code>)

here is the code :

let foldScript storeAppScripts =
  let builder = System.Text.StringBuilder (60 * Seq.length storeAppScripts)
  let bprintf format = Printf.bprintf builder format
  let kbprintf continuation format = Printf.kbprintf continuation builder format

  let isScriptNonEmpty { Script = script } = script &lt;&gt; ""
  let writeAppScripts storeAppScripts () =
    let writeScripts scripts () = Seq.iter (fun { Script = script } -&gt; bprintf "\r\n%s" script) scripts

    storeAppScripts
    |&gt; Seq.groupBy (fun { App = app } -&gt; app)
    |&gt; Seq.iter (fun (app, group) -&gt; kbprintf (writeScripts group) "\r\n\tuse Application = %s  " app)
    bprintf "\r\n"

  storeAppScripts
  |&gt; Seq.filter isScriptNonEmpty
  |&gt; Seq.groupBy (fun { Store = store } -&gt; store)
  |&gt; Seq.iter (fun (store, group) -&gt; kbprintf (writeAppScripts group) "use Store=%s" store)

string &lt;| builder.Remove (builder.Length - 2, 2)


POST

SUBMITTED

int&gt;( list-&gt;front() );
}
temp2 = list;
temp2 -&gt; pop_front

PRE

template 
binary_tree_node* balanced_tree_rec(list* list,Item count)

MID

    temp2 = list;
    temp2 -&gt; pop_front();


POST

template  void push(Item&amp; test)

SUBMITTED

on round result
  function privateAlertRoundResults(results) {
    switch (results) {
      case 0:
        alert('Draw !');
        break;
      case 1:
        alert('You lose !');
        break;
      case 2:
        alert('You win !');
        break;
    }
  }

  // Display a message with total winrate from 0 to 100% (rounded)
  function privateAlertTotalResults() {
    var results = Math.floor((privateGameDB / privateGameCount) * 100);
    alert

PRE

I like your question,

I think if you are going to export one function, and then immediately execute it, then you are better served with a <a href="http://markdalgleish.com/2011/03/self-executing-anonymous-functions/">self executing query</a>.

You are writing a game, I would use a revealing pattern for the model, the controller, and the view.

Always consider if you can replace control structures with data structures:

MID

// Display a message depending on round result
function privateAlertRoundResults(results) {
  var resultsMessages = [ 'Draw !', 'You lose !','You win !'];
  alert( resultsMessages[ results ];
}


instead of

// Display a message depending on round result
function privateAlertRoundResults(results) {
  switch (results) {
    case 0:
      alert('Draw !');
      break;
    case 1:
      alert('You lose !');
      break;
    case 2:
      alert('You win !');
      break;
  }
}


POST

For extra points, consider how you can convert this into a data structure:

SUBMITTED

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ConsoleApplication
{
    class Program
    {
        static void Main()
        {
            var input = GetInput();
            Console.WriteLine("Your input:\n{0}", input);

        }
        static string GetInput() 
        {
            Console.WriteLine("Please input somthing");
            var input = Console.ReadLine();
            return input

PRE

You sure can, you can use something even smaller such as:

MID

using System;

namespace ConsoleApplication
{
    class Program
    {
        static void Main()
        {
            Console.WriteLine("Please input something");
            Console.WriteLine("Your input: \n{0}", Console.ReadLine());
            Console.ReadLine(); //stops the console from closing
        }
    }
}


POST

SUBMITTED

NewTable = Sheets("Calculations").ListObjects("Full_Bearings_List")

    NewTable.Range.SpecialCells(xlCellTypeVisible).Select
    NewTable.DataBodyRange.SpecialCells(xlCellTypeVisible).Copy
    Sheets("Temp").Range("A1").PasteSpecial

PRE

Here:

MID

    NewTable.Range.SpecialCells(xlCellTypeVisible).Select
    NewTable.DataBodyRange.SpecialCells(xlCellTypeVisible).Copy


POST

You can drop the first line entirely and it will still run perfectly fine.

Get used to using <code>Sheet.Cells(row, column)</code> instead of <code>Sheet.Range("[Address]")</code>. Not only is it faster, but it's semantically closer to what cells actually are, and you can't do things like this anywhere near as easily with addresses:

SUBMITTED

int[] concat

PRE

<strong>Testing</strong>

MID

concat

POST

SUBMITTED

class Store

PRE

MID

Store

POST

SUBMITTED

start_link) 
                end_url

PRE

MID

end_url

POST

SUBMITTED

void main

PRE

Not only can you avoid cluttering up the code with more of the same variables (if more of them will be added), but you can take advantage of <code>ArrayList</code>'s features.

MID

main()

POST

SUBMITTED

pair&lt;int,int&gt;&gt; pairs;
    vector&lt;vector&lt;int&gt;&gt; output;

    if

PRE

Memory allocations take time, significant time if you do them in your inner most loop.

For starters, change:

MID

vector&lt;vector&lt;int&gt;&gt; output;


to:

vector&lt;std::tuple&lt;int, int, int&gt;&gt; output;


POST

This converts your putput vector from "A vector of pointers to fixed size dynamic elements" (note the oxymoron, fixed size dynamic elements, there's your problem) to "A vector of fixed size elements". Not only will you be avoiding lots and lots of memory allocations but you will also improve your cache performance by miles because your entire output vector is now contiguous and cache friendly.

Then change:

SUBMITTED

class MFVideoEncoder

PRE

MID

MFVideoEncoder

POST

SUBMITTED

return

PRE

MID

return

POST

SUBMITTED

d:\n", row+1);
        getline(cin, currentRow);
        strToUpper(currentRow);
        if(isNumeric

PRE

This is a C++ iterator.  It's more common to call index variables (what you originally had) <code>i</code>.  

MID

        strToUpper(currentRow);
        if(isNumeric(currentRow)){


You don't need to convert numeric rows to uppercase.  You only need to convert to upper case if it is not upper case.  

        if (isNumeric(currentRow)) {
// ...
        } else {
            strToUpper(currentRow);


POST

SUBMITTED

interest:
# A line goes from node_from[x] to node_to[x]. So 1-2, 2-3, 4-6, 6-8, 12-15

#==============================================================================

nodes_from = [1, 2, 4, 6, 12] 
nodes_to =   [2, 3, 6, 8, 15]

nodes_from_string = [str(x) for x in nodes_from]
nodes_to_string = [str(x) for x in nodes_to]

branch_string = [nodes_from_string[x] +'-' +nodes_to_string[x] for x in range(0, len(nodes_from))]
#==============================================================================
# Create Excel-file and give names to sheets.
# Sheets will be called

PRE

You're right,

MID

nodes_from_string = [str(x) for x in nodes_from]
nodes_to_string = [str(x) for x in nodes_to]

branch_string = [nodes_from_string[x] +'-' +nodes_to_string[x] for x in range(0, len(nodes_from))]


could maybe better be written as:

branch_string = [ str(nodes_from[x]) + '-' + str(nodes_to[x]) for x in  range(len(nodes_from))


or even better, perhaps:

branch_string = [ "%d-%d" % (nodes_from[x], nodes_to[x]) for x in range(len(nodes_from)) ]


or a little less clear (but shorter):

branch_string = [ "%d-%d" % (x, nodes_to[i]) for i, x in enumerate(nodes_from) ]


POST

Other tips:

SUBMITTED

testcase_id

    fail_or_pass

PRE

MID

fail_or_pass

POST

SUBMITTED

d{7}$/])
      raise

PRE

MID

raise

POST

SUBMITTED

stackInput = [1,2,3,4,5]
expOutput = [4,5,3,2,1] # return True
#expOutput = [4,3,5,1,2] # return False
stack = []
outputIndex = 0
result = True
i = 0

while i &lt; (len(stackInput)):
    stack.append(stackInput[i])
    i

PRE

Ta-da, your whole program works without needing manual commenting-and-uncommenting! And as a bonus, you've gotten started on writing <em>unit tests</em> for your function.

By the way, I called the parameters <code>stackInput</code> and <code>expOutput</code> because that's what you did; but in practice I would call them <code>input</code> and <code>output</code>.

MID

i = 0
while i &lt; (len(stackInput)):
    stack.append(stackInput[i])
    i += 1


First, <code>(len(stackInput))</code> is a silly way to write <code>len(stackInput)</code>.

Second, you should learn about for-loops. What you wrote is equivalent to

for value in stackInput:
    stack.append(value)


POST

and if you actually needed the <code>i</code> for some reason, you could have written

SUBMITTED

bmi?"]

male=["male","m"]

female=["female", "f"]

def bmi_q():
    print "Very good

PRE

You also switch between putting a space after commas in lists, and not doing so. I would change these lines:

MID

male=["male","m"]

female=["female", "f"]


to look like this (notice the space after the first comma):

male = ["male", "m"]

female = ["female", "f"]


POST

Variables should always begin with a lowercase letter. Classes and constants can and should be capitalized, but not normal variables. So the <code>Gender</code> variable should be renamed to <code>gender</code>.

You should consider not asking for the user's gender and age unless you actually do something with that data, or at least don't assign it to variables because it'll go unused.

I would also rename <code>bmi_q</code>, <code>bmi_c</code>, and <code>consent_q</code> to something more clear, so other people reading your code can immediately know what those function are supposed to do. <code>bmi_c</code> could definitely be renamed to something like <code>calculate_bmi</code>, or even <code>calc_bmi</code>.

And lastly, I'd always make sure your indention doesn't get messed up when pasting your code into a site like this. There's a few problems with invalid indention, but I'd imaging that happened when you put it in this question. (the indention in the question has been fixed now though)

But overall, good job on writing your first program! Congrats, keep it up, and remember this quote from Phil Karlton: 

There are only two hard things in Computer Science: cache invalidation and naming things.

SUBMITTED

write f(...)'
Public Function func(ParamArray args()) As Variant
Attribute func.VB_UserMemId = 0
    'Do some

PRE

<strong>Implicit Variant Types</strong>
You've been diligent with Type declarations, but in <code>IFunction</code> you have omitted the Variant type of the ParamArray:

MID

Public Function func(ParamArray args()) As Variant


POST

<strong>Use meaningful names</strong>

Your use of <code>i</code>, <code>f</code> and <code>var</code> are 3 examples of meaningless variable names. Consider more meaningful names.

<strong>Use independent loop bounds</strong>
Your Loop uses <code>i</code> as the loop variable <em>and</em> the starting index:

SUBMITTED

template&lt;class T, class C&gt;
void parallel_for_each(std::vector&lt;T&gt;* ts, C callable, uint poolsize = (std::thread::hardware_concurrency()+1)*2) {

    atomic&lt;size_t&gt; index(0);
    std::vector&lt;thread&gt; threads;

    for (uint i = 0; i &lt; poolsize; i++) {
        threads.emplace_back([&amp;]() {    
            while(index &lt; ts-&gt;size()) {
                callable(ts-&gt;at(index++));
            }
        });
    }
    for (auto&amp;&amp; thread : threads) {
        thread.join();
    }
}

//use like:
std::vector&lt;int&gt; is= { 4,5, 6,7,8,3,2,25,44,34,562,356,235,66,3,45,66};
parallel_for_each(&amp;is, print

PRE

If you are not going to create a long running thread pool (and manage the threads over many jobs), then I would let the system do it for you; the <code>async()</code> function potentially runs stuff in parallel and manages a thread pool for you.

MID

// Not tested.
// You may need to play with it.
template&lt;class T, class C&gt;
void parallel_for_each(std::vector&lt;T&gt;&amp; ts, C callable)
{
    size_t index =;
    std::vector&lt;std::future&gt; results;

    for(auto const&amp; value: ts)
    {
        results.emplace_back(async(callable, value));
    }
    for (auto&amp; result : results)
    {
        result.wait();
    }
}


POST

One of your parameters is:

SUBMITTED

UTF8, JsonRequestBehavior.AllowGet);

    if (country.Institutions == null || country.Institutions.Count &lt;= 0)
        return Json(string.Empty, "application/json", Encoding.UTF8, JsonRequestBehavior.AllowGet);

    var institutions = country.Institutions
        .OrderBy(i =&gt; i.Name)
        .Where(i =&gt; !i.Name.Contains("institutiontest1"))
        .Where(i =&gt; !i.Name.Contains("institutiontest2"))
        .Select(i =&gt; new SelectListItem { Text = i.Name, Value = i.Id.ToString() });

    return Json(institutions, "application/json", Encoding.UTF8, JsonRequestBehavior.AllowGet

PRE

And then select your data:

MID

var institutions = country.Institutions
    .OrderBy(i =&gt; i.Name)
    .Where(i =&gt; !i.Name.Contains("institutiontest1"))
    .Where(i =&gt; !i.Name.Contains("institutiontest2"))
    .Select(i =&gt; new SelectListItem { Text = i.Name, Value = i.Id.ToString() });


hmm.. what's with these <code>.Where</code> statements? Filtering out test data? So if you go and add some <code>institutiontest3</code> you'll need to add yet another <code>.Where</code> call?

Don't do that. Make yourself a separate, dev/test database, and have another database for your production data - and use proper configuration to determine which connection string to use to initialize your <code>Session</code>.

TL;DR:

[AjaxOnly]
public ActionResult GetInstitutions(string parent)
{
    var country = _countryRespository.GetByCountryCode(parent);
    if (country == null || !country.Institutions.Any())
    {
        return Json(string.Empty, "application/json", Encoding.UTF8, JsonRequestBehavior.AllowGet);
    }

    var institutions = country.Institutions
                              .OrderBy(institution =&gt; institution.Name)
                              .Select(institution =&gt; new SelectListItem
                              { 
                                  Text = institution.Name,
                                  Value = institution.Id.ToString()
                              });
    return Json(institutions, "application/json", Encoding.UTF8, JsonRequestBehavior.AllowGet);
}


POST

If the filtered-out values are meant to be <em>specific</em> values, consider making them explicit:

SUBMITTED

ExportCodeFixProvider(LanguageNames.CSharp, Name = PredefinedCodeFixProviderNames.RemoveDocCommentNode), Shared]
internal class CSharpRemoveDocCommentNodeCodeFixProvider : AbstractRemoveDocCommentNodeCodeFixProvider&lt;XmlElementSyntax&gt;
{
    /// &lt;summary&gt;
    /// Duplicate param tag
    /// &lt;/summary&gt;
    private const string CS1571 = nameof(CS1571);

    /// &lt;summary&gt;
    /// Param tag with no matching parameter
    /// &lt;/summary&gt;
    private const string CS1572 = nameof(CS1572);

    /// &lt;summary&gt;
    /// Duplicate typeparam tag
    /// &lt;/summary&gt;
    private const string CS1710 = nameof(CS1710);

    public override ImmutableArray&lt;string&gt; FixableDiagnosticIds { get; } = ImmutableArray.Create(CS1571, CS1572, CS1710);

    protected override string DocCommentSignifierToken { get; } = "///";

    protected override SyntaxTriviaList GetRevisedDocCommentTrivia(string docCommentText)
        =&gt; SyntaxFactory.ParseLeadingTrivia(docCommentText

PRE

There is also a rarely used multiline syntax <code>/**</code> for documentation comments. I <em>think</em> your code will handle that correctly. Is that intentional? Have you tested it?

You're calling <code>GetParamNode()</code> in <code>RegisterCodeFixesAsync()</code> and then again in <code>RemoveDuplicateParamTagAsync()</code>. This <em>feels</em> inefficient to me (no idea if it actually affects performance) and I think getting rid of the duplication would simplify the code a bit.

MID

/// &lt;summary&gt;
/// Duplicate param tag
/// &lt;/summary&gt;
private const string CS1571 = nameof(CS1571);

/// &lt;summary&gt;
/// Param tag with no matching parameter
/// &lt;/summary&gt;
private const string CS1572 = nameof(CS1572);

/// &lt;summary&gt;
/// Duplicate typeparam tag
/// &lt;/summary&gt;
private const string CS1710 = nameof(CS1710);

public override ImmutableArray&lt;string&gt; FixableDiagnosticIds { get; } = ImmutableArray.Create(CS1571, CS1572, CS1710);


This is fairly verbose code, just to create a collection of strings. What about:

public override ImmutableArray&lt;string&gt; FixableDiagnosticIds { get; } =
    ImmutableArray.Create(
        // Duplicate param tag
        "CS1571",
        // Param tag with no matching parameter
        "CS1572",
        // Duplicate typeparam tag
        "CS1710");


Or:

public override ImmutableArray&lt;string&gt; FixableDiagnosticIds { get; } =
    ImmutableArray.Create(
        "CS1571", // Duplicate param tag
        "CS1572", // Param tag with no matching parameter
        "CS1710"  // Duplicate typeparam tag
    );


POST

SUBMITTED

return

PRE

In a number of cases, as with the <code>if</code> statement mentioned above, curly braces (<code>{}</code>) were <em>not</em> used, but they <em>are</em> used for each <code>case</code> statement.  In fact, they're not needed in either case, but I'd recommend using braces for constructs such as <code>for</code>, <code>while</code> and <code>if</code> and omitting them for <code>case</code>.

The <code>RemoveComments</code> function is currently written to return <code>int</code> but the only value it ever returns is <code>0</code>. I'd recommend either returning something useful, such as, for instance a number of comments removed, <em>or</em> to change it to a <code>void</code> function.

MID

return 0

POST

When a C or C++ program reaches the end of <code>main</code> the compiler will automatically generate code to return 0, so there is no need to put <code>return 0;</code> explicitly at the end of <code>main</code>.  

<strong>Note:</strong> when I make this suggestion, it's almost invariably followed by one of two kinds of comments:  "I didn't know that." or "That's bad advice!"  My rationale is that it's safe and useful to rely on compiler behavior explicitly supported by the standard.  For C, since C99; see ISO/IEC 9899:1999 section 5.1.2.2.3:

[...] a return from the initial call to the <code>main</code> function is equivalent to calling the <code>exit</code> function with the value returned by the <code>main</code> function as its argument; reaching the <code>}</code> that terminates the <code>main</code> function returns a value of 0.

For C++, since the first standard in 1998; see ISO/IEC 14882:1998 section 3.6.1:

If control reaches the end of main without encountering a return statement, the effect is that of executing return 0;

All versions of both standards since then (C99 and C++98) have maintained the same idea.  We rely on automatically generated member functions in C++, and few people write explicit <code>return;</code> statements at the end of a <code>void</code> function.  Reasons against omitting seem to boil down to <a href="https://stackoverflow.com/questions/2581993/what-the-reasons-for-against-returning-0-from-main-in-iso-c/2582015#2582015">"it looks weird"</a>.  If, like me, you're curious about the rationale for the change to the C standard <a href="https://stackoverflow.com/questions/31394171/what-was-the-rationale-for-making-return-0-at-the-end-of-main-optional">read this question</a>.  Also note that in the early 1990s this was considered "sloppy practice" because it was undefined behavior (although widely supported) at the time.  

So I advocate omitting it; others disagree (often vehemently!)  In any case, if you encounter code that omits it, you'll know that it's explicitly supported by the standard and you'll know what it means.

SUBMITTED

word_counts(f

PRE

MID

f[:-1]

u = f[:];u.pop()

POST

To improve your code I'd add <code>collections.defaultdict</code>.
This will allow you to remove the innermost if/else.
This is as if the value isn't in the dictionary it'll default it to something for you.

SUBMITTED

input:checkbox

PRE

MID

$('input:checkbox')

POST

SUBMITTED

Dim i

PRE

MID

i

POST

SUBMITTED

bool alreadyin

PRE

MID

alreadyin

alreadyin

!alreadyin

POST

So know that I know what you mean we can optimize the code.

The first thing would be naming. The vector containing the modes should be named <code>modes</code> rather than <code>maxs</code>. Similarly I would rather name <code>max</code> as <code>currentMode</code> or better <code>modeStrength</code>.

The second point would be the update of the vector. Currently you always clear it. However, if it only has one mode you can just change that value.

SUBMITTED

printDate.AddDays(1);
            ChangeColor(ConsoleColor.Magenta);
            Console.WriteLine("== Day {0} ==", printDate.ToLongDateString());

            var timePointsDuringtDay = forecast.TimePoints.Where((weatherTimePoint

PRE

I think it's a good idea to stick to the <code>Print</code> &amp; <code>PrintLine</code> convention like the console does it.

Then you can turn this:

MID

 ChangeColor(ConsoleColor.Magenta);
 Console.WriteLine("== Day {0} ==", printDate.ToLongDateString());


into:

Print(Style.Header, "== Day {0} ==", printDate.ToLongDateString());


You can go even further and create a special method called <code>PrintHeader</code> and do all the magic there like so:

PrintHeader(printDate)
{
    Print(Style.Header, "== Day {0} ==", printDate.ToLongDateString());
}


POST

This way your printing becomes even cleaner and you can manipulate the header separately.

The same applies for other cases.

SUBMITTED

Algorithm 1

    boolean ft = true;

    String s = new String

PRE

Lots of answers already, but most of them seem to be about alternative solutions. I'll review your code on the details and show you how to refactor your code step by step. (<strong>This is a long answer, <a href="https://codereview.stackexchange.com/questions/140268/how-to-print-out-10-rows-of-10-characters-or-strings-in-java-non-tediously#comment262748_140304">link to bottom of answer</a></strong>)

MID

String s = new String();


POST

Creating a new String could be simplified to <code>""</code>. The only time you'll actually use the String constructor is for creating strings from arrays like <code>char[]</code> or <code>byte[]</code>.

SUBMITTED

new_avg

  }else

PRE

MID

else

POST

SUBMITTED

shared_ptr()
        {
            this-&gt;destroy();
        }

        shared_ptr(const shared_ptr &amp;p) : refCount(nullptr), t(nullptr)
        {
            if(p.isvalid())
            {
                refCount = p.refCount;
                t = p.t;

                if(isvalid())
                (*this-&gt;refCount)++;
            }
        }

        void destroy()
        {
            if(isvalid())
            {
                --(*refCount);
                if((*refCount) &lt;= 0)
                {
                    delete refCount;
                    delete t;
                }

                refCount = nullptr;
                t = nullptr;
            }   
        }

        shared_ptr&amp; operator

PRE

If <code>p.isvalid()</code> is true then <code>isvalid()</code> will be true after the copy.

MID

    shared_ptr(const shared_ptr &amp;p) : refCount(nullptr), t(nullptr)
    {
        if(p.isvalid())
        {
            refCount = p.refCount;
            t = p.t;

            if(isvalid())
            (*this-&gt;refCount)++;
        }
    }


Also this could be much simplified.

    shared_ptr(const shared_ptr &amp;p)
        : refCount(p.refCount)
        , t(p.t)
    {
        if(isvalid()) {
            (*refCount)++;
        }
    }


    shared_ptr&amp; operator =(const shared_ptr &amp;p)
    {
        if(this != &amp;p)
        {
            /* This LOOKS LIKE A BUG */
            /* Don't think the ! should be there. */
            if(!p.isvalid())
            {
                this-&gt;destroy();
                this-&gt;refCount = p.refCount;
                this-&gt;t = p.t;

                if(isvalid())
                (*this-&gt;refCount)++;

                return (*this);
            }

            if(!isvalid())
            {
                this-&gt;refCount = p.refCount;
                this-&gt;t = p.t;

                if(isvalid())
                (*this-&gt;refCount)++;

                return (*this);
            }
            else
            {
                this-&gt;destroy();
                this-&gt;refCount = p.refCount;
                this-&gt;t = p.t;

                if(isvalid())
                (*this-&gt;refCount)++;                    
            }
        }
        return (*this);
    }


Sorry that function is big and clumsy and hard to read. It also does not provide the strong exception guarantee. You modify the content of this object doing exception dangerous work (call destroy) before updating the content of this object.

To do any work in exception safe way you need to follow a three step processes.

This 3 step process is ipitimized by the copy and swap idiom.

 shared_ptr&amp; operator =(const shared_ptr &amp;p)
 {
     shared_ptr  temp(p);    // Constructor copies. Destructor destoryes.
     temp.swap(*this);       // Perform an exception safe transfer of state.
     return *this;
 }


Lots of people take this one step further. And do the copy in the parameter:

 shared_ptr&amp; operator =(shared_ptr p)  // Notice the pass by value.
 {                                     // this gets your copy.
     p.swap(*this);
     return *this;
 }


POST

These two functions do not mutate the state of the object.

SUBMITTED

lt;button type="submit" name="btn-login"&gt;Login&lt;/button&gt;
   &lt;/form&gt;
 &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt

PRE

MID

&lt;&gt;h&lt;&gt;e&lt;&gt;l&lt;&gt;l&lt;&gt;o

POST

SUBMITTED

n
    V %= n
    return _int_tuple(U, V, Qk

PRE

In my opinion it's not putting too much into a line to make that (following Graipher's suggestion)

MID

    return (U % n, V % n, Qk)


POST

SUBMITTED

i = SetLongevity

PRE

OK. I assume that you know Singelton is also considered an anti-pattern. If you think about it there are usually better ways of doing things.

You have implemented some code that guarantees an order of destruction on your singletons (hopefully there are not that many that this is a big worry!). It looks like it should work.

Couple of issues I have are:

MID

SetLongevity()

POST

SUBMITTED

public void setBySpaceShip(SpaceShip spaceShip) {
        xBulletPosition = spaceShip.getXSpaceShipPosition() + TO_CENTER;
        yBulletPosition = spaceShip.getYSpaceShipPosition();
        isActive = true

PRE

While these two are obviously magic numbers, you are being very inconsequent by deriving a lot of other magic numbers in your codebase (essentially all screen space coordinates!) based on the value of these two.

Take e.g. the bounding boxes in <code>MouseInput</code>, every single occasion where you are drawing an UI element at a fixed location, or even the ingame object placement.

<strong><em>All</em></strong> of these should have been derived from these two constants!

You absolutely love writing duplicate code, don't you?

MID

xBulletPosition = spaceShip.getXSpaceShipPosition() + TO_CENTER;
yBulletPosition = spaceShip.getYSpaceShipPosition();


POST

In every single location in your codebase where you need to handle either 2D coordinates, or 2D bounding boxes, you always chose to store each single component in an individual variable.

Why?

But you didn't just duplicate the pattern of storing the components individually, you also typed the bounding box tests over an over again manually.

It's so simple to solve that, just group 2D coordinates into a <code>Point</code> object, and bounding boxes into <code>Box</code> object. The <code>Box</code> class should also contain the commonly used methods for test for <code>Box</code> with <code>Box</code> collisions, and <code>Point</code> in <code>Box</code> inclusions.

What could possibly go wrong?...

SUBMITTED

i++];
    while(j &lt;= right)              result[k++] = vec[j++];

    for(k=0; k &lt; size; k++)
    {
        vec[left+k] = result[k];
    }
}

template&lt

PRE

Hope that helps.

<strong>Peformance</strong>

In <a href="https://gist.github.com/coderodde/862697e0aacce0d2a24cf26385ca67ef" rel="nofollow">this Gist</a> you can get everything needed for a performance demonstration. I get the following figures:

<strong>Space consideration</strong>

At any given instant, you have \$\Theta(N)\$ worth memory allocated. However, if you count all <strong><code>std::vector&lt;T&gt; result(size);</code></strong>, you will get \$\Theta(N \log N)\$ worth memory allocated. 

You can do better. You can allocate a <strong><code>vector</code></strong> that is of the same length and content as the input <strong><code>vector</code></strong>. Then, you merge from one vector to another; and at the next recursion level you swap their roles and so on. That way, you can eliminate

MID

for(k=0; k &lt; size; k++)
{
    vec[left+k] = result[k];
}


POST

in the merging function.

Suppose also that we are sorting 8 elements. At the very highest recursion level you allocate a vector of 8 elements. After that you visit both left and right subranges of length 4 elements each. That's 8 elements in vector(s) more. You continue the same argument until you reach the bottom recursion level. Since each level allocates \$N = 8\$ worth memory, and there is \$\Theta(\log N)\$ levels total, you get \$\Theta(N \log N)\$.

SUBMITTED

var maxValue

PRE

MID

maxValue

POST

SUBMITTED

String[] args) throws java.lang.Exception
    {
      // edge cases

PRE

MID

throws java.lang.Exception

POST

SUBMITTED

collections::HashMap;
use std::collections::VecDeque;

#[derive(Debug, Copy, Clone

PRE

MID

use std::collections::{HashMap, VecDeque};

POST

SUBMITTED

gt; right;
    Node() : left(), right() {}
    Node(int data) : data(data), left(), right() {}
};

template &lt;typename It&gt;
It get_midpoint_iterator(It start, It end) {
    auto midpoint = std::distance(start, end) / 2;
    It mid = start;
    std::advance(mid, midpoint);
    return mid;
}

template &lt;typename It&gt;
void create_bst_helper(std::unique_ptr&lt;Node&gt;&amp; root

PRE

Your <code>get_midpoint_iterator()</code> function can be simplified. Here is how it currently looks:

MID

template &lt;typename It&gt;
It get_midpoint_iterator(It start, It end) {
    auto midpoint = std::distance(start, end) / 2;
    It mid = start;
    std::advance(mid, midpoint);
    return mid;
}


These statements:

It mid = start;
std::advance(mid, midpoint);
return mid;


Can be replaced with:

return std::next(mid, midpoint);


View the documentation here: <a href="http://en.cppreference.com/w/cpp/iterator/next" rel="nofollow noreferrer">http://en.cppreference.com/w/cpp/iterator/next</a>

Since your function's body now looks like this:

auto midpoint = std::distance(start, end) / 2;
return std::next(start, midpoint);


You can simply erase <code>midpoint</code> and put the calculation at the function call location:

return std::next(start, std::distance(start, end) / 2);


You end up with a concise function that is guaranteed copy elision in C++17.

template &lt;typename It&gt;
It get_midpoint_iterator(It start, It end) {
    return std::next(start, std::distance(start, end) / 2);
}


As <a href="https://codereview.stackexchange.com/users/112441/miscco">@miscco</a> points out, this obfuscates the operation slightly, so you might also want to add a comment indicating that <code>std::distance(start, end) / 2</code> is the midpoint.

Your <code>create_bst_helper()</code> function currently initializes a <code>std::unique_ptr&lt;&gt;</code> in the following fashion:

root = std::move(std::unique_ptr&lt;Node&gt;(new Node(*midpoint)));


POST

This can be more clearly expressed with:

SUBMITTED

with the remaining arguments
        $(type "$1" | sed -E 's/^.*`(.*).$/\1/') "${@:2}"
    else 
        # run

PRE

Now, the output of your <code>sed</code> command is not what you expect:

MID

$ type foo | sed -E 's/^.*`(.*).$/\1/' 
$ 


That will return nothing since the <code>^.*`</code> means "match the longest possible string from the beginning of the string to a backtick" and, therefore, will match everything except the final <code>'</code>. A better approach would be to use a tool that has non-greedy matching like <code>perl</code>:

$ type foo | perl -pe 's/^.*?\`(.*).$/\1/'
ls `which sudo`


POST

You will also need to <code>eval</code> it in order for it to run correctly:

SUBMITTED

def simplex(n, dim):
    if dim == 1:
        return n
    else:
        i = 1
        ret = 0
        while i &lt;= n:
            ret += simplex(i, dim-1)
            i+=1
        return ret

PRE

You should use a <code>for</code> loop rather than a <code>while</code> loop to solve the problem.
This is as you're just re-writing a for loop.
Using a for loop you can change the loop to a comprehension, and take the <code>sum</code> of it.
This allows you to get the code:

MID

def simplex(n, dim):
    if dim == 1:
        return n
    dim -= 1
    return sum(simplex(i, dim) for i in range(1, n + 1))


However this can be simplified.
When dim is the bullet point the function is:

Since we're getting a pattern, we know that the top part of the fraction is:

\$\Pi_{i = 0}^{dim - 1} n + i\$

And if we use <a href="https://oeis.org/search?q=2%2C+6%2C+24%2C+120&amp;sort=&amp;language=english&amp;go=Search" rel="nofollow">oeis to find the denominator</a> it says it's probably the factorial sequence.
And so it's likely:

\$\frac{\Pi_{i = 0}^{dim - 1} n + i}{dim!}\$

This is actually really easy to write in Python.
And so you can get a significant speed up.

from functools import reduce
from math import factorial
from operator import mul

def simplex(n, dim):
    return reduce(mul, (n + i for i in range(dim))) // factorial(dim)


POST

SUBMITTED

the sequence with the item using a
    # set to avoid duplicates.
    seq = set(seq)
    seq.update([item])

    # Converts the sequence to a list and re-sorts it. 
    sorted_seq = sorted(seq)

    middle = len(sorted_seq) // 2
    middle_value = sorted_seq[middle]

    first_half = sorted_seq

PRE

MID

seq = set(seq)
seq.update([item])

# Converts the sequence to a list and re-sorts it. 
sorted_seq = sorted(seq)


POST

In worst case, <strong><code>sorted()</code></strong> will take \$\Theta(n \log n)\$, where \$n = \$ <strong><code>len(seq)</code></strong>. Even worse, if you did not found the value, you recur to half of the original sequence, and so on.

So, instead of presorting the sequence, just proceed to doing the actual search; if the caller fails to input a sorted list, it's not your fault.

I have this in mind, runs in worst case logarithmic time and behaves exactly as your implementation:

SUBMITTED

Action function)
        {
            if (started

PRE

MID

if (started) ...

this.started = true;

POST

SUBMITTED

for i

PRE

MID

i

POST

So here is my complete solution:

SUBMITTED

include &lt;macros.h&gt;
#include &lt;structures.h&gt

PRE

MID

#include &lt;structures.h&gt;

#include "structures.h"

POST

SUBMITTED

struct Game

PRE

MID

Game *

Game

POST

SUBMITTED

StringBuilder()
    for

PRE

MID

for

POST

The nested <code>for</code> loops in <code>Maze.toString</code> look too imperative-style.

The nesting can be avoided with

SUBMITTED

with os.scandir(path

PRE

MID

os.scandir

POST

SUBMITTED

i].length + j * blockWidth;
            int toIndex = fromIndex + blockWidth;
            Arrays.fill(dest, fromIndex, toIndex, src[i][j]);
        }
        int srcPos = i * blockWidth * blockHeight * src[i].length;
        for (int k = 1; k &lt; blockHeight; k++) {
            int destPos = srcPos + k * blockWidth * src[i].length;
            System.arraycopy(dest, srcPos, dest, destPos, src[i].length * blockWidth);
        }
    }
    return dest

PRE

Now, the above logic is far from "obvious", but it makes for a remarkably simple loop:

MID

public static int[] expand(int[][] src, int blockWidth, int blockHeight) {
    int span = src[0].length * blockWidth;
    int[] dest = new int[src.length * blockHeight * span];
    for (int i = 0; i &lt; dest.length; i++) {
        dest[i] = src[(i / span) / blockHeight][(i % span) / blockWidth];
    }
    return dest;
}


POST

You can see the above running in ideone: <a href="https://ideone.com/sJhksT" rel="nofollow">https://ideone.com/sJhksT</a>

Note that the concept of describing an element in an output array as a function of the output index is sometimes a nice "trick" and neatens things up. You have to be able to spot this, though, in real code. Note that the above code basically says <code>dest[i] = fn(i)</code> where <code>fn(i)</code> is some function taking <code>i</code> as an argument.

Your code, on the other hand, works off the source index, and it tries to calculate the indexes in the output array from the source location. That's not "wrong", but as you can see, it makes for a nested, and ugly loop.

Knowing when to reverse the logic is more of an art than a science, but being able to identify these logic inversions is important.

SUBMITTED

derive(Debug, Clone)]
struct Item {
    value: usize,
    weight: usize,
}

impl Item {

    fn new(pvalue: usize, pweight: usize) -&gt; Item { 
        Item { value: pvalue, weight: pweight }
    }
}

#[derive(Debug, Clone)]
struct Info {
    ks_value: usize,
    added_weight: usize,
    included: bool,
}

impl Info {
    fn new(pks_value: usize, padded_weight: usize, pincluded: bool) -&gt; Info{
        Info {
            ks_value: pks_value,
            added_weight: padded_weight,
            included: pincluded,
        }  
    }
}

impl std::cmp::Ord for Info {
    fn cmp(&amp;self, other: &amp;Info) -&gt; std::cmp::Ordering {
        self.ks_value.cmp(&amp;other.ks_value)
    }
}

impl PartialOrd for Info {
    fn partial_cmp(&amp;self, other: &amp;Info) -&gt; Option&lt;std::cmp::Ordering&gt; {
        Some(self.cmp(other))
    }
}

impl PartialEq for Info {
    fn eq(&amp;self, other: &amp;Info) -&gt; bool {
        self.ks_value == other.ks_value
    }
}

impl Eq for Info {}

fn _0_1_knapsack_items&lt;'a&gt;(items: &amp;'a[Item], max_weight: usize, subproblems: &amp;[Vec&lt;Info&gt;]) -&gt; Vec&lt;&amp;'a Item&gt;{
        (1..items.len() + 1).rev()
        .scan(max_weight, |w, i| {
                let sub    = &amp;subproblems[i][*w];
                let result = (i, sub.included);
                *w -= sub.added_weight;
                Some(result)
        })
        .filter(|&amp;(_, inc)| inc)
        .take_while(|&amp;(i, _)| i &gt; 0)
        .map(|(i, _)| &amp;items[i - 1])
        .collect::&lt;Vec&lt;&amp;Item&gt;&gt;()
}

fn _0_1_knapsack&lt;'a&gt;(items: &amp;'a [Item], max_weight: usize) -&gt; Vec&lt;&amp;'a Item&gt;{
    let mut subproblems = vec! [ vec! [ Info::new(0, 0, false);
                                       max_weight + 1 ]; 
                                 items.len() + 1 ];
    for i in 0..items.len() {
        for w in 0..max_weight + 1 { 
            let w_i      = items[i].weight;
            let exc_cost = subproblems[i][w].ks_value;
            subproblems[i + 1][w] = if  w &lt; w_i {
                Info::new(exc_cost, 0, false)
            } 
            else {
                let inc_cost = subproblems[i][w - w_i].ks_value 
                               + items[i].value;
                std::cmp::max(Info::new(exc_cost, 0, false), 
                              Info::new(inc_cost, w_i, true))     
            }
        }
    }
    _0_1_knapsack_items(items, max_weight, &amp;subproblems)
}


fn main() {
    let items = [ Item::new(92, 23),  //1
                  Item::new(57, 31),  //1
                  Item::new(49, 29),  //1
                  Item::new(68, 44),  //1
                  Item::new(60, 53),  //0
                  Item::new(43, 38),  //1
                  Item::new(67, 63),  //0
                  Item::new(84, 85),  //0
                  Item::new(87, 89),  //0
                  Item::new(72, 82) ];//0

    for i in _0_1_knapsack(&amp;items, 165){
        println!("{:?}", i

PRE

Check out <a href="https://github.com/rust-lang-nursery/rustfmt" rel="nofollow">Rustfmt</a>.

There's a <a href="https://github.com/Manishearth/rust-clippy" rel="nofollow">Clippy</a> warning for <code>zero_one_knapsack</code>: <code>explicit lifetimes given in parameter types where they could be elided</code>.

Don't prefix every parameter with <code>p</code>. There's no naming conflict and it adds confusion to everyone that tries to use the API. Especially for variables like <code>padded_weight</code>, where "padded" is another English word!

Introduce a <code>key</code> method to DRY up <code>Ord</code> / <code>PartialEq</code> / <code>Hash</code> implementations.

A leading <code>_</code> means that item is <strong>unused</strong> but must be present for some reason; don't call your methods that. Switch to words since identifiers can't start with numbers

Start iteration in <code>zero_one_knapsack_items</code> at 0. This simplifies the logic and shows that <code>take_while</code> can be removed.

This also leads to using <code>iter</code> and <code>enumerate</code> instead of operating on a range.

In turn, this leads to removing the need for indexing into <code>items</code>.

Remove the <code>result</code> temporary variable. It doesn't introduce a useful name and doesn't need to occur in a different temporal location.

There is a <code>filter_map</code> that does two operations in one, but I like the separation of <code>filter</code> and <code>map</code> here. You almost want a <code>scan_map</code>.

There's no need to specify type on <code>collect</code>; it's inferred from the return type of the function.

I'm not a fan of the truncated variable names. Computers don't care about long names, but humans do care about short names. This is especially true when there are overlapping meanings for prefixes like <code>inc</code> (<code>included</code> or <code>inclusive</code>).

Prefer iterating on a slice instead of on a range of numbers. If you <em>need</em> the number, use <code>enumerate</code>; this avoids out-of-bounds checking on each index operation.

Implement <code>Default</code> for your type if there's an appropriate value.

Import <code>Ord</code> and <code>max</code> to make that code a bit cleaner to read.

MID

use std::cmp::{Ord, max};

#[derive(Debug, Clone)]
struct Item {
    value: usize,
    weight: usize,
}

impl Item {
    fn new(value: usize, weight: usize) -&gt; Item {
        Item {
            value: value,
            weight: weight,
        }
    }
}

#[derive(Debug, Clone)]
struct Info {
    ks_value: usize,
    added_weight: usize,
    included: bool,
}

impl Info {
    fn new(ks_value: usize, added_weight: usize, included: bool) -&gt; Info {
        Info {
            ks_value: ks_value,
            added_weight: added_weight,
            included: included,
        }
    }

    fn key(&amp;self) -&gt; usize {
        self.ks_value
    }
}

impl Ord for Info {
    fn cmp(&amp;self, other: &amp;Info) -&gt; std::cmp::Ordering {
        self.key().cmp(&amp;other.key())
    }
}

impl PartialOrd for Info {
    fn partial_cmp(&amp;self, other: &amp;Info) -&gt; Option&lt;std::cmp::Ordering&gt; {
        Some(self.cmp(other))
    }
}

impl PartialEq for Info {
    fn eq(&amp;self, other: &amp;Info) -&gt; bool {
        self.key() == other.key()
    }
}

impl Eq for Info {}

impl Default for Info {
    fn default() -&gt; Info {
        Info::new(0, 0, false)
    }
}

fn zero_one_knapsack_items&lt;'a&gt;(items: &amp;'a [Item],
                               max_weight: usize,
                               subproblems: &amp;[Vec&lt;Info&gt;]) -&gt; Vec&lt;&amp;'a Item&gt;
{
    items.iter().enumerate()
        .rev()
        .scan(max_weight, |w, (i, item)| {
            let subproblem = &amp;subproblems[i+1][*w];
            *w -= subproblem.added_weight;
            Some((item, subproblem.included))
        })
        .filter(|&amp;(_, included)| included)
        .map(|(item, _)| item)
        .collect()
}

fn zero_one_knapsack(items: &amp;[Item], max_weight: usize) -&gt; Vec&lt;&amp;Item&gt; {
    let mut subproblems = vec![vec![Info::default(); max_weight + 1]; items.len() + 1];

    for (i, item) in items.iter().enumerate() {
        for w in 0..max_weight + 1 {
            let w_i = item.weight;
            let exclusive_cost = subproblems[i][w].ks_value;
            subproblems[i + 1][w] = if w &lt; w_i {
                Info::new(exclusive_cost, 0, false)
            } else {
                let inclusive_cost = subproblems[i][w - w_i].ks_value + item.value;
                max(Info::new(exclusive_cost, 0, false),
                    Info::new(inclusive_cost, w_i, true))
            }
        }
    }

    zero_one_knapsack_items(items, max_weight, &amp;subproblems)
}

fn main() {
    let items = [Item::new(92, 23),  // 1
                 Item::new(57, 31),  // 1
                 Item::new(49, 29),  // 1
                 Item::new(68, 44),  // 1
                 Item::new(60, 53),  // 0
                 Item::new(43, 38),  // 1
                 Item::new(67, 63),  // 0
                 Item::new(84, 85),  // 0
                 Item::new(87, 89),  // 0
                 Item::new(72, 82)]; // 0

    for i in zero_one_knapsack(&amp;items, 165) {
        println!("{:?}", i);
    }
}


POST

SUBMITTED

MoviesContext : DbContext

PRE

MID

DbContext

POST

The <em>ViewModel</em> is doing I/O and database work in its constructor; this means if a network or any other error occurs, the runtime will fail to construct the object instance, and who knows what's going to happen then.

A constructor is responsible for <em>constructing</em> an object - assigning private <code>readonly</code> fields for example. Picture:

SUBMITTED

num;
    char

PRE

Both <em>algorithms</em> perform &theta;(<em>n</em>) operations for strings of length <em>n</em>.  Since the task always requires examining every character of the input, there can be no alternative that provides better asymptotic complexity than these do.  Additionally, each has memory overhead that does not vary with the input, which affords no asymptotically better implementation in that respect either.  Of course, implementations with the same asymptotic complexity are not all equivalent by either measure.

See also below, however: your <em>implementations</em> of these algorithms are potentially flawed and less efficient.

MID

char

POST

Your codes assume that the string elements all have numeric value between 1 and 126, inclusive, but <code>char</code> can be a signed type, and whether signed or unsigned it can have more than 7 value bits.  Also, <code>(char) 127</code> is always a valid <code>char</code> (from C's perspective).  As a result, on any conforming C implementation there are valid C strings which, if provided as input to either of your functions, will cause that function to exhibit undefined behavior.

To solve this problem I suggest declaring your arrays with dimension <code>UCHAR_MAX + 1</code>, and casting input <code>char</code>s to type <code>unsigned char</code> before using them as indexes.

Each function exhibits somewhat surprising behavior for non-empty inputs that contain no unrepeated characters.  They return that character among those with the minimum number of repeats whose first appearance is earliest in the string.  It's unclear what the function is supposed to do in that case, but the the actual behavior is potentially misleading.  It would be better to return an error code.

You could use 0 as an error code, as it is the only <code>char</code> value that cannot appear <em>inside</em> a string.  Your functions will already return 0 when presented with an empty string as input, though I'm uncertain whether that's by design.  Alternatively, the functions could return type <code>int</code>, with the result being -1 when there is no unrepeated character, else the first non-repeated one cast to <code>unsigned char</code>.  This is the scheme the <code>getchar()</code> function uses.

Both codes contain loops with <code>i &lt; strlen(string)</code> for their termination condition.  The compiler can lift the evaluation of <code>strlen()</code> out of the loop only if it makes several assumptions about that function.  Inasmuch as that's a standard library function, it is conceivable that that would happen, but by no means certain.  If it doesn't happen then your implementations become &theta;(<em>n</em><sup>2</sup>) instead of &theta;(<em>n</em>); I therefore recommend lifting the <code>strlen()</code> call out of the loop manually.

Alternatively, consider avoiding <code>strlen()</code> altogether -- since you need to iterate through the whole string anyway, just break the iteration when you reach the terminator.  That should be more efficient.

SUBMITTED

gt;element);
        free(head);
        head = head-&gt;next;
        size--;
    }
    return 0;
}

void print_stack

PRE

I see a number of things that may help you improve your code.

Right now, one can only have one stack at a time.  Worse, if one calls <code>stack_init</code> after some items have already been pushed onto the stack, there will be a memory leak.  An alternative scheme would be to have <code>stack_init()</code> return a pointer to a <code>Stack</code> and then use that as a parameter for all other calls.  That way, one could have multiple stacks simultaneously, making it that much more useful.

In the <code>stack_init</code> routine, the <code>head</code> variable is initialized, but neither <code>head-&gt;element</code> nor <code>head-&gt;next</code> are initialized.  It's also probably a good idea to explicitly zero the <code>size</code>.  Although it's already zeroed at the moment because it's a file scope variable, if you follow the other advice on this list, you'll have to initialize it yourself.

Right now, the only way to free memory is to repeatedly call <code>pop()</code>.  Unfortunately, the calling program has no way to know how many items are on the stack or to know when the stack is empty, so it's not going to be able to know how many times to do so.  I'd suggest providing at least an explicit <code>isEmpty()</code> call.

At the moment, there isn't any way to actually use the stack except to call <code>print_stack()</code> which limits its usefulness in the extreme.  I'd suggest that adding a means of examining the top of the stack, as with a call to <code>top()</code> that returns the <code>value</code> for that item might be a good idea.

These lines have a problem:

MID

free(head);
head = head-&gt;next;


The problem is that after you've freed <code>head</code>, you dereference it to get the <code>next</code> pointer.  This is undefined behavior -- anything could happen and it probably won't be good!  Better would be to save a copy of the pointer, do your housekeeping and then free the copy like this:

struct Node* temp = head;
head = head-&gt;next;
free(temp);


POST

There is no way at the moment to use <code>pop</code> without it printing something.  In a real program that use such a stack, that's unlikely to be the desired effect.  Better would be to have <code>pop()</code> just do what it needs to do and leave printing to the calling program.

Most of your non-void functions return something useful, but <code>pop</code> always returns 0 which isn't very useful.

The <code>size</code> and <code>head</code> elements are closely related items.  For that reason (and to accomodate suggestion #1 on this list), I'd recommend combining them into a struct instead like this:

SUBMITTED

parallelOptions )
{
    ConcurrentBag

PRE

MID

ConcurrentBag

POST

SUBMITTED

public class Employee implements ActionListener {

public static String div = &quot;------------------------------------------&quot;;
public static ArrayList&lt;Integer&gt; ids, salary;
public static ArrayList&lt;String&gt; firstNames, lastNames, startDates;
public static JTextArea display;
public static JButton[] buttons = new JButton[3];
public static JLabel[] subTitles = new JLabel[5];
public static JTextField[] inputs = new JTextField[5];

public static void main(String[] args) {
    // Defining all array lists
    ids = new ArrayList();
    salary = new ArrayList();
    startDates = new ArrayList();
    firstNames = new ArrayList();
    lastNames = new ArrayList();

    // Fonts
    Font titleFont = new Font(&quot;Courier New&quot;, 1, 24);
    Font subFont = new Font(&quot;Courier New&quot;, 1, 16);

    // Frame
    JFrame frame = new JFrame(&quot;Employee Records&quot;);
    frame.setSize(550, 450);
    frame.setLocationRelativeTo(null);
    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    frame.setResizable(false);

    // Container
    JPanel container = new JPanel();
    container.setLayout(null);
    frame.setContentPane(container);

    // Title
    JLabel title = new JLabel(&quot;Employee Records&quot;);
    title.setFont(titleFont);
    title.setForeground(Color.blue);
    title.setBounds(160, 10, 250, 24);

    // Lablels and text fields
    for (int i = 0; i &lt; subTitles.length; i++) {
        subTitles[i] = new JLabel();
        subTitles[i].setFont(subFont);
        subTitles[i].setBounds(5, 50 + (i * 35), 190, 16);
    }
    subTitles[0].setText(&quot;Employee ID#: &quot;);
    subTitles[1].setText(&quot;First Name: &quot;);
    subTitles[2].setText(&quot;Last Name: &quot;);
    subTitles[3].setText(&quot;Annual Salary: &quot;);
    subTitles[4].setText(&quot;Start Date: &quot;);

    for (int i = 0; i &lt; subTitles.length; i++) {
        inputs[i] = new JTextField();
        inputs[i].setBounds(160, 47 + (35 * i), 150, 22);
    }

    // Buttons
    for (int i = 0; i &lt; buttons.length; i++) {
        buttons[i] = new JButton();
        buttons[i].addActionListener(new Employee());
        buttons[i].setBounds(330, 47 + (35 * i), 200, 20);
    }
    buttons[0].setText(&quot;Add (REQUIRES ALL FIELDS)&quot;);
    buttons[1].setText(&quot;Remove (by ID#)&quot;);
    buttons[2].setText(&quot;List&quot;);

    // Text area
    display = new JTextArea();
    display.setEditable(false);
    JScrollPane scrollPane = new JScrollPane(display);
    scrollPane.setBounds(5, 217, 535, 200);

    // Adding everything
    container.add(title);
    container.add(scrollPane);
    // Since # of textfields will always equal # of subtitles, we can use the
    // max value of subtitles for the loop
    for (int i = 0; i &lt; subTitles.length; i++) {
        container.add(subTitles[i]);
        container.add(inputs[i]);
    }
    for (int i = 0; i &lt; buttons.length; i++) {
        container.add(buttons[i]);
    }

    // Extras
    frame.toFront();
    frame.setVisible(true);
}

public void actionPerformed(ActionEvent event) {
    if (event.getSource().equals(buttons[0])) {
        // Pass boolean to check if the program should continue or not
        boolean pass = true;
        // Loop to check if all textfields have data
        for (int i = 0; i &lt; inputs.length; i++) {
            if (inputs[i].getText().equals(&quot;&quot;)) {
                display.setText(&quot;Error: enter data for ALL fields.&quot;);
                pass = false;
            }
        }

        // If the user passed, the program continues
        if (pass == true) {
            // Checking if ID# already exists
            if (ids.contains(Integer.parseInt(inputs[0].getText()))) {
                // Displaying error message if entered ID# exists
                display.setText(&quot;Error: employee ID# exists, use another.&quot;);
                // If not, it adds all the data
            } else {
                // Adding all the info to the arrays
                ids.add(Integer.parseInt(inputs[0].getText()));
                firstNames.add(inputs[1].getText());
                lastNames.add(inputs[2].getText());
                salary.add(Integer.parseInt(inputs[3].getText()));
                startDates.add(inputs[4].getText());
                display.setText(&quot;Employee #&quot; + inputs[0].getText() + &quot; added to record(s).&quot;);
                // Loop to set all textfields to empty
                for (int i = 0; i &lt; inputs.length; i++) {
                    inputs[i].setText(null);
                }
            }
        }
    } else if (event.getSource().equals(buttons[1])) {
        // Loop to search list for requested removal
        for (int i = ids.size() - 1; i &gt;= 0; i--) {
            // If the request is found, it removes all data
            if (Integer.parseInt(inputs[0].getText()) == ids.get(i)) {
                display.setText(&quot;Employee #&quot; + ids.get(i) + &quot; has been removed from the records.&quot;);
                ids.remove(i);
                firstNames.remove(i);
                lastNames.remove(i);
                salary.remove(i);
                startDates.remove(i);
                break;
                // If not, the ID# does not exist
            } else {
                display.setText(&quot;Error: employee ID# does not exist, try again.&quot;);
            }
        }
    } else {
        // Resets text area and lists all the data
        display.setText(null);
        for (int i = 0; i &lt; ids.size(); i++) {
            display.append(div + &quot;\nEmployee ID#: &quot; + ids.get(i) + &quot;\nFirst Name: &quot; + firstNames.get(i)
                    + &quot;\nLast Name: &quot; + lastNames.get(i) + &quot;\nAnnual Salary: $&quot; + salary.get(i)
                    + &quot;\nStart Date: &quot; + startDates.get(i) + &quot;\n&quot

PRE

...and the UI:

MID

import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import javax.swing.*;

public class EmployeeUI implements ActionListener {

public static String div = "------------------------------------------";
public static List&lt;Employee&gt; employees = new ArrayList&lt;Employee&gt;();
public static JTextArea display;
public static JButton[] buttons = new JButton[3];
public static JLabel[] subTitles = new JLabel[5];
public static JTextField[] inputs = new JTextField[5];

public static void main(String[] args) {

    // Fonts
    Font titleFont = new Font("Courier New", 1, 24);
    Font subFont = new Font("Courier New", 1, 16);

    // Frame
    JFrame frame = new JFrame("Employee Records");
    frame.setSize(550, 450);
    frame.setLocationRelativeTo(null);
    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    frame.setResizable(false);

    // Container
    JPanel container = new JPanel();
    container.setLayout(null);
    frame.setContentPane(container);

    // Title
    JLabel title = new JLabel("Employee Records");
    title.setFont(titleFont);
    title.setForeground(Color.blue);
    title.setBounds(160, 10, 250, 24);

    // Lablels and text fields
    for (int i = 0; i &lt; subTitles.length; i++) {
        subTitles[i] = new JLabel();
        subTitles[i].setFont(subFont);
        subTitles[i].setBounds(5, 50 + (i * 35), 190, 16);
    }
    subTitles[0].setText("Employee ID#: ");
    subTitles[1].setText("First Name: ");
    subTitles[2].setText("Last Name: ");
    subTitles[3].setText("Annual Salary: ");
    subTitles[4].setText("Start Date: ");

    for (int i = 0; i &lt; subTitles.length; i++) {
        inputs[i] = new JTextField();
        inputs[i].setBounds(160, 47 + (35 * i), 150, 22);
    }

    // Buttons
    for (int i = 0; i &lt; buttons.length; i++) {
        buttons[i] = new JButton();
        buttons[i].addActionListener(new EmployeeUI());
        buttons[i].setBounds(330, 47 + (35 * i), 200, 20);
    }
    buttons[0].setText("Add (REQUIRES ALL FIELDS)");
    buttons[1].setText("Remove (by ID#)");
    buttons[2].setText("List");

    // Text area
    display = new JTextArea();
    display.setEditable(false);
    JScrollPane scrollPane = new JScrollPane(display);
    scrollPane.setBounds(5, 217, 535, 200);

    // Adding everything
    container.add(title);
    container.add(scrollPane);
    // Since # of textfields will always equal # of subtitles, we can use the
    // max value of subtitles for the loop
    for (int i = 0; i &lt; subTitles.length; i++) {
        container.add(subTitles[i]);
        container.add(inputs[i]);
    }
    for (int i = 0; i &lt; buttons.length; i++) {
        container.add(buttons[i]);
    }

    // Extras
    frame.toFront();
    frame.setVisible(true);
}

public void actionPerformed(ActionEvent event) {
    if (event.getSource().equals(buttons[0])) {
        // Pass boolean to check if the program should continue or not
        boolean pass = true;
        // Loop to check if all textfields have data
        for (int i = 0; i &lt; inputs.length; i++) {
            if (inputs[i].getText().equals("")) {
                display.setText("Error: enter data for ALL fields.");
                pass = false;
            }
        }

        // If the user passed, the program continues
        if (pass == true) {
            // Checking if ID# already exists
            if (employees.contains(Integer.parseInt(inputs[0].getText()))) {
                // Displaying error message if entered ID# exists
                display.setText("Error: employee ID# exists, use another.");
                // If not, it adds all the data
            } else {
                // Adding all the info to the array
                employees.add(new Employee(Integer.parseInt(inputs[0].getText()),//id
                        inputs[1].getText(),                //firstname
                        inputs[2].getText(),                //last name
                        Integer.parseInt(inputs[3].getText()),  //salary
                        new Date(inputs[4].getText())                   //startDate
                        ));
                display.setText("Employee #" + inputs[0].getText() + " added to record(s).");
                // Loop to set all textfields to empty
                for (int i = 0; i &lt; inputs.length; i++) {
                    inputs[i].setText(null);
                }
            }
        }
    } else if (event.getSource().equals(buttons[1])) {
        // Loop to search list for requested removal
        for (int i = employees.size() - 1; i &gt;= 0; i--) {
            // If the request is found, it removes all data
            if (Integer.parseInt(inputs[0].getText()) == employees.get(i).getId()) {
                display.setText("Employee #" + employees.get(i).getId() + " has been removed from the records.");
                employees.remove(i);
                break;
                // If not, the ID# does not exist
            } else {
                display.setText("Error: employee ID# does not exist, try again.");
            }
        }
    } else {
        // Resets text area and lists all the data
        display.setText(null);
        for (int i = 0; i &lt; employees.size(); i++) {
            display.append(div + "\nEmployee ID#: " + employees.get(i).getId() + "\nFirst Name: " + employees.get(i).getFirstName()
                    + "\nLast Name: " + employees.get(i).getLastName() + "\nAnnual Salary: $" + employees.get(i).getSalary()
                    + "\nStart Date: " + employees.get(i).getStartDate() + "\n");
        }
    }
}

}


POST

SUBMITTED

public List

PRE

MID

List

POST

SUBMITTED

operators

    &gt;&gt;&gt; solve('(~(0 ∧ 0) ↔ (~0 ∨ ~0))')
    1
    """
    while len(valued_statement) &gt; 1:
        valued_statement = simplify(valued_statement)
    return int

PRE

The problem is here:

MID

while len(valued_statement) &gt; 1:
    valued_statement = simplify(valued_statement)


POST

Of course the input <code>'AB'</code> is invalid, but I would expect to get a <code>SyntaxError</code> instead of an infinite loop.

Other inputs containing syntax errors result in exceptions that are hard to understand. For example:

SUBMITTED

int main

PRE

MID

main

int main(int argc, char **argv)

POST

SUBMITTED

width=1.0cm

PRE

MID

++(1cm,0)

POST

SUBMITTED

include &lt

PRE

This is simply an array named <code>inst</code> of 10 pointers to member functions. The syntax would be similar for C-style functions except of course they would not have a <code>Machine::</code> anywhere.

MID

#include

The code makes use of <code>std::string</code> and <code>std::stoi</code> but does not <code>#include &lt;string&gt;</code>.  It should.

#include

POST

It doesn't appear to me that this program actually needs anything from either <code>&lt;sstream&gt;</code> or <code>&lt;fstream&gt;</code> so these two lines can safely be deleted:

SUBMITTED

boardArray(9)
        Dim gameWinner As String
        Dim isWon As Boolean
        Dim move As Integer
        Dim square As Integer
        Dim player As Integer
        For iterator As Integer = 0 To boardArray.Length
            move = iterator + 1
            square = moveArray(iterator)
            Select Case move
                Case 1, 3, 5, 7, 9
                    player = 1
                    boardArray(square) = 1
                Case 2, 4, 6, 8
                    player = 2
                    boardArray(square) = 2
            End Select
            If move &gt; 4 Then isWon = CheckWin(boardArray, square)
            If isWon Then
                gameWinner = &quot;Game #&quot; &amp; gameNumber &amp; &quot; is won by Player &quot; &amp; player &amp; &quot; on move #&quot; &amp; move &amp; &quot; in square #&quot; &amp; square &amp; &quot;.&quot;
                Return gameWinner
            End If
        Next
        Return &quot;Game #&quot; &amp; gameNumber &amp; &quot; is a draw.&quot;
    End Function

    Private Function CheckWin(ByVal boardarray As Integer(), ByVal square As Integer) As Boolean
        Dim isWin As Boolean
        isWin

PRE

I think you can see where this is going, simply use LINQ <code>.Any</code> in your <code>CheckWin</code> method and bam, you've extracted the ugly switch statement and conditionals to a much cleaner (and more robust) alternative. Now if, for some reason, you want to add more rows/columns, it's trivial.

In the following snippet:

MID

    For iterator As Integer = 0 To boardArray.Length
        move = iterator + 1
        square = moveArray(iterator)
        Select Case move
            Case 1, 3, 5, 7, 9
                player = 1
                boardArray(square) = 1
            Case 2, 4, 6, 8
                player = 2
                boardArray(square) = 2
        End Select
        If move &gt; 4 Then isWon = CheckWin(boardArray, square)
        If isWon Then
            gameWinner = "Game #" &amp; gameNumber &amp; " is won by Player " &amp; player &amp; " on move #" &amp; move &amp; " in square #" &amp; square &amp; "."
            Return gameWinner
        End If
    Next


POST

If performance is not a concern, it's trivial to use:

SUBMITTED

lt;i32

PRE

Now adding and removing a value each only require a single location computation and lookup.

Parameterizing the key can be done by:

MID

i32

POST

SUBMITTED

double size

PRE

MID

size

POST

SUBMITTED

cin &gt;&gt; name;
          cin &gt;&gt; age;
          for(int i =0 ; i&lt; 6; i++){
              cin &gt;&gt; marks[i];
          }
      }

      public:
        void putdata(){
             id++;
             float markSum = 0;
            for(int i =0 ; i &lt; 6; i++){
                markSum += marks[i];
            }
            cout &lt;&lt; name + " "&lt;&lt; age &lt;&lt; " "&lt;&lt;markSum&lt;&lt;" "&lt;&lt;getID()&lt;&lt;"\n";
        }        
};
int Student::id

PRE

Your code only works because there is only one <code>putdata</code> on each object in the right order. Any other usage would not work as intended.

You also appear to mix string concatenation and stream output to put a space between elements: get consistent. You can also chain the stream <code>operator &gt;&gt;</code> to condense the code a bit without loosing on readability:

MID

class Professor: public Person {
    static int id;

    protected:
        int publications; 
        int current_id;

    public:
        void getdata () { 
            std::cin &gt;&gt; name &gt;&gt; age &gt;&gt; publication;
            current_id = ++id;
        }

        void putdata() {
             std::cout
                 &lt;&lt; name &lt;&lt; " " &lt;&lt; age &lt;&lt; " " &lt;&lt; publications
                 &lt;&lt; " " &lt;&lt; current_id &lt;&lt; "\n";
        }
};

int Professor::id = 0;


class Student: public Person{
    float marks[6];
    static int id;
    int getID(){return id;}
    public:
      void getdata () { 
          cin &gt;&gt; name;
          cin &gt;&gt; age;
          for(int i =0 ; i&lt; 6; i++){
              cin &gt;&gt; marks[i];
          }
      }
      public:
        void putdata(){
             id++;
             float markSum = 0;
            for(int i =0 ; i &lt; 6; i++){
                markSum += marks[i];
            }
            cout &lt;&lt; name + " "&lt;&lt; age &lt;&lt; " "&lt;&lt;markSum&lt;&lt;" "&lt;&lt;getID()&lt;&lt;"\n";
        }        
};
int Student::id = 0;


Appart from remarks I already said for <code>Professor</code>, I was surprised to see that you store the marks as <code>float</code>s. Nothing in the text nor in the example input lead me to such conclusion, I would expect <code>int</code>s here.

class Student: public Person {
    static int id;

    protected:
        int marks[6];
        int current_id;

    public:
        void getdata () { 
            std::cin &gt;&gt; name &gt;&gt; age;
            for(int i = 0; i &lt; 6; ++i) {
                std::cin &gt;&gt; marks[i];
            }
            current_id = ++id;
        }

        void putdata() {
            int markSum = 0;
            for(int i = 0; i &lt; 6; ++i){
                markSum += marks[i];
            }
            std::cout
                &lt;&lt; name &lt;&lt; " " &lt;&lt; age &lt;&lt; " "
                &lt;&lt; markSum &lt;&lt; " " &lt;&lt; current_id &lt;&lt; "\n";
        }        
};

int Student::id = 0;


POST

One thing that I didn't enforce here but that you should get into the habit of using is qualifying attribute access using <code>this-&gt;</code> (such as <code>this-&gt;name</code> or <code>this-&gt;current_id</code>). It does not matter much here as the code is fairly simple but it can help a lot to understand things more easily when the code is more consequent.

Lastly, reading at the parameters ranges, you can consider using <code>unsigned int</code>s rather than <code>int</code>s.

SUBMITTED

self, text

PRE

MID

text

POST

SUBMITTED

hey body

PRE

MID

body

POST

SUBMITTED

lang racket

(require
  (for-syntax
   racket/string
   racket/list
   racket/syntax
   syntax/parse
   syntax/parse/experimental/template
   syntax

PRE

Starting at the top, you have a lot of unused imports. Fortunately, DrRacket can tell you which imports are unused, since it will highlight them in red when you hover your mouse over them. Additionally, if you click the Check Syntax button, it will color all the unused imports red. Using that, we can trim the import list down to the following set:

MID

(require (for-syntax racket/list
                     racket/syntax
                     syntax/parse))


POST

Next, let’s take a look at the bulk of your code, <code>generate-debug-version</code>. First of all, it’s a bit odd that you’re using <code>syntax-case</code> for the outer macro, but <code>syntax-parse</code> for the inner one. Just use <code>syntax-parse</code> everywhere; there’s really no reason to ever use <code>syntax-case</code> in Racket.

Furthermore, the <a href="http://docs.racket-lang.org/syntax/Defining_Simple_Macros.html" rel="noreferrer"><code>syntax/parse/define</code></a> module provides a nice <a href="http://docs.racket-lang.org/syntax/Defining_Simple_Macros.html#%28form._%28%28lib._syntax%2Fparse%2Fdefine..rkt%29._define-syntax-parser%29%29" rel="noreferrer"><code>define-syntax-parser</code></a> abbreviated form, which helps to simplify things slightly and remove some redundancy:

SUBMITTED

true
    $suspicious

PRE

MID

$suspicious

POST

SUBMITTED

numbers
), policy_dates

PRE

MID

policy_dates

POST

After that it gets a bit trickier.

Your <code>policy_data</code> CTE needs to be cleaned up. Right now your <code>HAVING</code> clause is going to be pretty difficult for the optimizer to clean up. What you actually wanted was to find all <code>PolicyNumber</code>s that have only valid <code>ClassCode</code>s, correct? Using <code>NOT EXISTS</code> and a normal <code>WHERE</code> clause still gets you the semi-join, but SARGably.

SUBMITTED

defaultEventServerPort  = 9090;
    static int defaultClientServerPort = 9099;

    static {
        try {
            APP_PROPERTIES.load(ClassLoader.class.getResourceAsStream("/app.properties"));
            String

PRE

Notice that instead of using <code>Integer.valueOf</code>, which returns an <code>Integer</code> object, we can directly use <code>Integer.parseInt</code>, which returns a primitive <code>int</code>. This way, we don't need to have a boxing, and then unboxing conversion.

There is another problem with how the Properties object is loaded: you have a potential memory leak!

MID

APP_PROPERTIES.load(ClassLoader.class.getResourceAsStream("/app.properties"));


This is opening an <code>InputStream</code>, but it is never closed. Instead, use a try-with-resources construct:

try (InputStream is = ClassLoader.class.getResourceAsStream("/app.properties")){
    APP_PROPERTIES.load(is);
} catch (IOException ex) {
    // ...
}


With those changes, you can have the following:

ApplicationConfig() {
    try (InputStream is = ClassLoader.class.getResourceAsStream("/app.properties")){
        APP_PROPERTIES.load(is);
    } catch (IOException ex) {
         // do the logging
    }
    eventServerPort = getAsIntOrDefault(APP_PROPERTIES, "server.event.port", DEFAULT_EVENT_SERVER_PORT);
    clientServerPort = getAsIntOrDefault(APP_PROPERTIES, "server.client.port", DEFAULT_CLIENT_SERVER_PORT);
}


POST

The <code>try-catch</code> block was also reduced so that it spans the minimal amount of code as possible. <code>try-catch</code> should be small and cover only the part of the code that can actually throw the exception you want to catch.

Last point, you can see the advantage of using a constructor here: later, you may want to remove hard-coding <code>"/app.properties"</code>. With a constructor, you can easily now pass the path to the properties file, which would be complicated to do with a static initializer.

Nitpick: <code>isValidNumeric</code> won't return <code>true</code> for negative numbers, so you may want to rename it to <code>isValidPositiveInteger</code>. Also, does <code>APP_PROPERTIES</code> really need to be static final as well? I would imagine it is only used to fetch all of the configuration values once, and unused later on.

SUBMITTED

content="width

PRE

MID

width

POST

SUBMITTED

is dead.";
        } else {
            message = "xPos: " + xPos
                    + "\nyPos: " + yPos
                    + "\nName: " + name
                    + "\nAge: " + age
                    + "\nHealth: " + health
                    + "\nHeight: " + height;
        }
        return message

PRE

You see, <code>toString</code>, <code>clone</code>, <code>equals</code> and <code>hashCode</code> are methods of <code>Object</code>, so absolutely ALL classes <strong>must</strong> abide by the contract defined by the <code>Object</code> class. And you still have that last one to code...

This also means the <code>public String toString();</code> declaration in <code>HumanInterface</code>  is useless.

MID

message = "\n[ASSASSIN]"
                + "\nxPos: " + xPos
                + "\nyPos: " + yPos
                + "\nName: " + name
                + "\nAge: " + age
                + "\nHealth: " + health
                + "\nPoison: " + poison
                + "\nHeight: " + height;


POST

Please use a <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/StringBuilder.html" rel="nofollow noreferrer">StringBuilder</a> when concatenating many <code>Strings</code>, or (better here) a <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/String.html#format(java.lang.String,%20java.lang.Object...)" rel="nofollow noreferrer">String.format</a> to make this safe and more efficient.

SUBMITTED

d.toString());
    }
    function showDateOnly(){
        alert(d.toDateString());
    }
    function showTimeOnly(){
        alert(d.toLocaleTimeString());
    }
};
})(jQuery);

$('#button').showDateTime({date:"date only

PRE

In my opinion it's a good idea to get rid of the <strong>switch case</strong> by using better naming for the inputs and by changing the structure of your functions to <strong>Object</strong> based functions, i.e. if you change your functions to this:

MID

var showDate={
    all:function (){
        alert(d.toString());
    },
    date:function showDateOnly(){
        alert(d.toDateString());
    },
    time:function (){
        alert(d.toLocaleTimeString());
    }
};


POST

and the setting options you get are <code>['all' , 'date' , 'time']</code>

then you can call these functions like this:

SUBMITTED

pricing

PRE

This way it's clearly rid of any ambiguity!<br>
But it lacks taking in account what we guess about your need:

MID

pricing

POST

SUBMITTED

var $pw

PRE

MID

pw

POST

SUBMITTED

public:
    Chip8(const char

PRE

MID

const char *

POST

SUBMITTED

badAnswers = 0;
        char letter = 'x';
        String guess;
        boolean success;
        String answers = "";


        while (badAnswers &lt; 11) {
            success = false;
            System.out.println("Type a char.");
            while (!success) {
                guess = input.nextLine();
                if (guess.length() == 1 &amp;&amp; !(answers.contains(guess))) {
                    letter = guess.charAt(0);
                    success = true;
                    answers = answers + letter + ", ";
                } else if (!(guess.length() == 1)){
                    System.out.println("Type exactly one char!");
                }
                else if (answers.contains(guess

PRE

You could declare all these inside the loop instead by changing 

MID

            success = false;
            System.out.println("Type a char.");
            while (!success) {
                guess = input.nextLine();
                if (guess.length() == 1 &amp;&amp; !(answers.contains(guess))) {
                    letter = guess.charAt(0);
                    success = true;
                    answers = answers + letter + ", ";


to 

            char letter;
            boolean success = false;
            System.out.println("Type a char.");
            while (!success) {
                String guess = input.nextLine();
                if (guess.length() == 1 &amp;&amp; !(answers.contains(guess))) {
                    letter = guess.charAt(0);
                    success = true;
                    answers = answers + letter + ", ";


or even better, get rid of <code>success</code> entirely.  

            char letter;
            System.out.println("Type a char.");
            while (true) {
                String guess = input.nextLine();
                if (guess.length() == 1 &amp;&amp; !(answers.contains(guess))) {
                    letter = guess.charAt(0);
                    answers = answers + letter + ", ";
                    break;


POST

or consider something like 

SUBMITTED

int coins

PRE

MID

coins

POST

SUBMITTED

ErrorKind, Result

PRE

MID

Result

POST

SUBMITTED

io.Serializable

PRE

Your package name is <code>ATM</code>.
That violates the Java Code Conventions.
It is recommended that package names are all lowercase or at least lowerCamelCase.
And they should be the reverse domain name.
So it should be <code>atm</code> or better <code>com.yourdomain.atm</code> or something like that.

Most Java developers that I know find it better to avoid star imports and let the IDE manage explicit imports.
Explicit imports give a better overview over the fan-out (outgoing dependencies) of your class than star imports.
Also, explicit imports avoid the problem that with star imports, class names can be ambiguous of two imported packages contain classes with the same name.

MID

Serializable

POST

SUBMITTED

behavior').position().top;
    var $scrollTop = $(this).scrollTop();
    $window

PRE

MID

var $scrollTop = $(this).scrollTop();

this

$(window).scrollTop()

POST

SUBMITTED

d", &amp;r, &amp;s);
    }while(r &lt; 1 || s &gt; 15);

    char matrix[r][s];

    for (i = 0; i &lt; r; i ++){
        for(j = 0; j &lt; s; j++){
            scanf(" %c", &amp;matrix[i][j]);
        }
    }

    for (i = 0; i &lt; r; i ++){
        for(j = 0; j &lt; s; j++){
            if (matrix[i][j - 1] == '.' &amp;&amp; matrix[i][j] == '#' &amp;&amp; matrix[i][j + 2] == '.'
                &amp;&amp; matrix[i + 1][j] == '.' &amp;&amp; matrix[i + 1][j + 1] == '#' &amp;&amp; matrix[i + 1][j + 2] == '#' &amp;&amp; matrix[i + 1][j + 3] == '.'){

                matrix[i][j] = '*';
                matrix[i][j + 1] = '*';
                matrix[i + 1][j + 1] = '*';
                matrix[i + 1][j + 2] = '*';

            }
        }
    }

    for (i

PRE

I honestly have no idea from your code what it is that it's supposed to do.  I've run it several times and am still no better off.

Naming is an important aspect of coding.  It makes your code much more approachable / self documenting.  Almost none of your names give me any kind of hint as to what they represent or do.  <code>i,j,r,s</code> They may mean something to you, but they don't to me.  Put them together and you get this line <code>if (k[i * s + j] == '*')</code>.  Give your variables meaningful names.  Your method names are similarly abstract '<code>check</code>', check what?  '<code>toLadders</code>' which seems to replace '*' with '#' for some reason.

You may write the best program in the world, but if you can't convince people to use it then it has almost no value.  Your program needs some information from the user, however they aren't told what it is.  You simply start scanning characters from stdin.  Maybe this is ok because stdin is always redirected from a file, but if not tell your users what you're expecting.  Ask them for input, then try to get it, don't just assume they're going to know what's expected of them.

<strong>Bounds Checking</strong>

Some of your bounds checking looks off to me.  You create a <code>matrix[r][s]</code> then do this:

MID

for (i = 0; i &lt; r; i ++){
    for(j = 0; j &lt; s; j++){
        if (matrix[i][j - 1] == '.' &amp;&amp; matrix[i][j] == '#' &amp;&amp; matrix[i][j + 2] == '.'
            &amp;&amp; matrix[i + 1][j] == '.' &amp;&amp; matrix[i + 1][j + 1] == '#' &amp;&amp; matrix[i + 1][j + 2] == '#' &amp;&amp; matrix[i + 1][j + 3] == '.'){


POST

It looks a lot like when <code>j=s-1</code>, you're going to be accessing <code>matrix[i + 1][s - 1 + 3]</code>, which is out of bounds...

Keep in mind I wrote this in 1 hour - all the time we had for the task.

Honestly, the amount of time you had initially to write the task is a side issue, you presumably had the option to revisit the code and make it the best you could offer before posting.  Meaningful naming costs very little time and usually pays for itself with maintained understanding.  It is the biggest step you could take to make your code more approachable.  The more approachable your code is, the more value you are likely to get from reviews as reviewers will spend less time getting to grips with what you're doing allowing them to focus more on the how and why.

SUBMITTED

run(self

PRE

As Simon points out, you shouldn't put the list of functions inside of <code>run</code>. It doesn't make much sense. Move them out into the class.

MID

self

POST

<code>self</code> in python is equivalent to <code>this</code> in C# and many other languages.

This:

SUBMITTED

methods in the node class
charNode::charNode() {this-&gt;next=NULL;}

charNode

PRE

But in the general case where the return value can be any type. This is not an exception safe method. This is why in standard containers <code>pop()</code> simply removes the top item, and there is another method <code>top()</code> for getting a copy of the top element. You may want to copy this pattern to be consistent with standard types.

Don't use <code>this</code>

MID

charNode::charNode() {this-&gt;next=NULL;}


The need to use <code>this</code> is only required if we have shadowed variables. Shadowed variables are dangerous as you can accidently forget to use <code>this</code> and then you will be changing the wrong variable (and how do you tell if you should be using a local or a member variable if they have the same name)!

Shadowed variables are bad practice and can be detected by the compiler (and thus removed). When you have removed shadowed variables (because you code compiles with no errors) there is no longer any need to use <code>this</code>.

The use of this only creates problems so don't use it.

Only put one statement per line.

void charQueue::add(char c) 
{
    if(rear==NULL) {rear= new charNode(c); front=rear; counter=1; return;}
    charNode* tmp=new charNode(c); tmp-&gt;setNext(rear); rear=tmp; this-&gt;incCounter();
}


This is hard to read (and its a very short function).

void charQueue::add(char c) 
{
    if(rear==NULL)
    {
        rear= new charNode(c);
        front=rear;
        counter=1; 
        return;
    }
    charNode* tmp=new charNode(c);
    tmp-&gt;setNext(rear);
    rear=tmp;
    this-&gt;incCounter();
}


POST

Now that I can see the code. I see a lot of common elements (and I am not sure  I believe it is correct). Looks like the tmp element is being set as the second last element in the list and rear points to this element.

SUBMITTED

position.normalized != PuzzleGrid.EmptySlot.transform.position.normalized)
        {
            transform.position = Vector3.MoveTowards(transform.position, PuzzleGrid.EmptySlot.transform.position, 10*Time.deltaTime);
            yield return null;
        }
        GameObject temp

PRE

<strong><em>Excellent.</em></strong> You know the importance of making 'magic numbers' not so magic, but what about this bit:

MID

transform.position = Vector3.MoveTowards(transform.position, PuzzleGrid.EmptySlot.transform.position, 10*Time.deltaTime);


POST

What is <code>10</code> for?

SUBMITTED

then return true */
        if( col &lt

PRE

They don't really convey information or make clearer what is happening there.

Additionally, I <strong>strongly</strong> suggest to avoid <code>/* block comments */</code> in methods. These should be reserved for either implementation notes (outside of methods), or for JavaDoc method- and class comments. (This may be a bit subjective, though)

No, this is <em>not</em> about the question of whether the <code>{</code> should be in the same line or in the next line ;-) This is about <strong>consistency</strong>: In most cases, you wrote

MID

if(...)
  return true;


but in one case, you wrote

if(...)
{
    return true;
}


POST

In most coding guidelines that I have read so far, the recommendation was to <em>always</em> use the <code>{</code> brackets <code>}</code> even for single-line blocks. 

Similarly, you sometimes wrote <code>matrix.length-4</code> and sometimes <code>matrix.length - 4</code>. Yes, I think that the spaces matter. 

Your mileage may vary. 

Although the task was to allow the user to enter the matrix, I cannot imagine how you tested this more than once or twice. Didn't it become boring to enter the same values again and again? The first thing that I did was replacing the contents of your <code>main</code> method with this:

SUBMITTED

Selection.Insert

PRE

MID

Insert

Insert

POST

SUBMITTED

void *listGetItem

PRE

You might also want to make the <code>List</code> structure's <code>size</code> member and the <code>outSize</code> parameter be of type <code>size_t</code> which has some guarantees about being able to hold any number of elements you could actually allocate.

MID

listGetItem()

POST

Since the <code>index</code> parameter is never changed in the function, it should be marked as <code>const</code>. It should probably also be an unsigned type since it's not valid to be less than 0. That would get rid of at least one condition in the function.

This function also doesn't check whether the <code>List</code> is valid or not. If <code>NULL</code> is passed in, it will crash. As with the other functions, you need to decide whether that should return an error value (in which case the current return value will need to become a parameter), or whether a <code>NULL</code> list is valid and the return value is just <code>NULL</code>, too. I'd make it consistent with whatever you decide for the other functions.

SUBMITTED

function search(el, list) {
    // list = list || LIST;
    var LIM = Math.ceil(Math.log2(list.length)),
        lb = 0,
        ub = list.length - 1,
        i;
    while (el !== list[i = ~~((lb + ub) / 2)] &amp;&amp; el !== list[++i]) {
        if (!--LIM) return ("NOT FOUND");
        if (el &gt; list[i]) lb = i;
        else ub = i;
    }
    return i

PRE

Also, following best practices, I recommend to use block marks for <code>if()</code>s.

All that said, here is a suggested improved (and corrected) version:

MID

function search(searchedValue, list) {
    var tries = Math.ceil(Math.log2(list.length)),
        lowerBound = 0,
        upperBound = list.length - 1,
        i;
    while (
        searchedValue !== list[i = ~~((lowerBound + upperBound) / 2)]
    &amp;&amp;
        searchedValue !== list[++i]
    ) {
        if (--tries &lt;= 0) {
            return ("NOT FOUND");
        }
        if (searchedValue &gt; list[i]) {
            lowerBound = i;
        } else {
            upperBound = i;
        }
    }
    return i;
}


POST

SUBMITTED

i++) {
            int cost = costs[i];
            int diff = m

PRE

MID

int diff = m- cost;


POST

This line is hard to understand without the context of the problem statement. I'd recommend you pick a better name for <code>m</code> - <code>targetSum</code> might be a good indication.

Similarly, you say that you spotted that you can solve this problem with a pair sum. I think you should put that in the method name - contrast <code>int[] solve(int m, int []costs)</code> with <code>int[] findPairSumIndices(int targetSum, int[] costs)</code>.

Another thing that bothers me, but now we're getting in pretty subjective territory, is the inconsistency in the placing of the array type.

SUBMITTED

next_node = None
        new_list.pre_node = None
        while

PRE

Firstly, the line

MID

new_list.pre_node = None


POST

doesn't do anything and can be removed. Secondly, your code can't handle circular double-linked lists.

When called on a circular double-linked list:

<code>Print_list</code> goes into an endless loop.

<code>Reverse_list</code> terminates late, giving a partially reversed list.

Your code could be easily improved to handle these issues. Preventing an endless loop requires keeping track of the identity of each node. Below, I've done this by incrementing a global variable <code>node_count</code>, but there are more Pythonic ways to keep a count of instances of objects.

The unique id is used to track when the cursor id matches <code>self.id</code>, terminating the while loops in <code>print_list</code> and <code>reverse_list</code> at the appropriate time for circular lists.

Lastly, <a href="https://www.python.org/dev/peps/pep-0008/" rel="nofollow noreferrer">PEP8</a> specifies methods within a class should be separated by a single line.

See below:

SUBMITTED

_augmentationTypeKeys = (T[])Enum.GetValues(typeof(T));
                }
                return _augmentationTypeKeys;
            }
        }

        public T[] Keys
        {
            get

PRE

and

MID

public T[] Keys
{
    get
    {
        return AugmentationTypeKeys;
    }
}


Having two public properties <code>AugmentationTypeKeys</code> and <code>Keys</code> returning the exact same values but under different names is confusing. You should use only one property.

If you are on C#6 all this could be replaced with an intialization for the private readonly field and a readonly property:

private static readonly T[] _keys = (T[])Enum.GetValues(typeof(T));

public T[] Keys =&gt; _keys;


if not then add a private setter and initialize it in the constructor.

Be aware of the fact that the array is not immutable and can be manipulated elsewhere.

public int this[T type]
{
  get
  {
      return GetAugmentation(type);
  }
  set
  {
      SetAugmentation(type, value);
  }
}


and

public void ClearAugmentation(T type)
{
  SetAugmentation(type, DefaultAugmentation);
}

public int GetAugmentation(T type)
{
  return _augmentationTable[type];
}


Again, multiple APIs doing the same thing. I'd keep the indexer and remove the methods.

public AugmentationType TableType { get; set; }


POST

This property is set in the constructor and yet it has a public setter. Are you sure you want to allow to change it later? I don't know of corse how it exactly is used but I'd say the setter should most probably be private.

SUBMITTED

public partial class AnalysisScreenView : Form, IAnalysisScreenView
{
    // Private members.
    private AnalysisScreenPresenter _presenter;

    // Public members.
    public List&lt;string&gt; Scenarios
    {
        get
        {
            var scenarios = new List&lt;string&gt;();
            foreach(var item in scenarioInput.Items)
            {
                scenarios.Add(item.ToString());
            }
            return scenarios;
        }
        set
        {
            foreach(var scen in value)
            {
                this.scenarioInput.Items.Add(scen);
            }
        }
    }
    public List&lt;string&gt; ThreatActors
    {
        get
        {
            var actors = new List&lt;string&gt;();
            foreach (var item in actorInput.Items)
            {
                actors.Add(item.ToString

PRE

MID

public List&lt;string&gt; Scenarios
{
    get
    {
        var scenarios = new List&lt;string&gt;();
        foreach(var item in scenarioInput.Items)
        {
            scenarios.Add(item.ToString());
        }
        return scenarios;
    }
    set
    {
        foreach(var scen in value)
        {
            this.scenarioInput.Items.Add(scen);
        }
    }
}


POST

This property (the other two similar as well) are very fragile. Everytime you use the setter you add new values to the ComboBoxes. I guess you want to call <code>Clear</code> before adding new items.

They can also be simplified because you can use the <code>AddRange</code> method instead of looping yourself.

SUBMITTED

typename T

PRE

MID

T

POST

SUBMITTED

user pointer to the copied functor
        this-&gt;userPtr_ = (void*) this-&gt;functorData_;

        // Create a simple function that calls the functor
        this-&gt;func_ = [](void *user, TArgs ... args) -&gt; void {
            TFunctor *functorPtr = reinterpret_cast&lt;TFunctor*&gt;(user);
            (*functorPtr)(args...);
        };

        return *this;
    }

    /**
     * Sets the callback function and user pointer by wrapping
     * a simple

PRE

MID

    // Create a simple function that calls the functor
    this-&gt;func_ = [](void *user, TArgs ... args) -&gt; void {
        TFunctor *functorPtr = reinterpret_cast&lt;TFunctor*&gt;(user);
        (*functorPtr)(args...);
    };


POST

This always raises a red flag for me. I understand that the <code>user</code> parameter is used to pass the actual functor instance, and it's a common technique to interface with C-style callback API's. 

May be it deserves more commenting why exactly it will be used here, and what exactly <code>user</code> is expected to carry.

SUBMITTED

alignas(64) volatile

PRE

This is a personal preference but one that I find makes code easier to read. I always order my fields as: <code>public</code> then <code>protected</code> then <code>private</code> with the motivation that the person using the class is interested in seeing the <code>public</code> API and this should thus be the first thing you see so that you don't have to search for it. 

MID

volatile

C++ (and C) has a thing called the <a href="http://en.cppreference.com/w/cpp/language/as_if" rel="nofollow noreferrer">"as-if rule"</a>. Which in essence says:

The compiler is allowed to generate ANY code as long as all reads and writes to <code>volatile</code> memory happens in the same order and with the same values <strong>as if</strong> the program was execute according to the language specification.

This is the only use <code>volatile</code> has in C++, it means that writes and writes to <code>volatile</code> memory will always happen and will happen in the order specified. For example the compiler can, and frequently does re-order stores and writes. The compiler can remove memory writes and reads if it can determine that they will not affect any <code>volatile</code> memory read or write. The compiler can even remove memory allocations if it so pleases (clang does this some times). 

For completeness, all inputs and outputs (files, <code>std::cout</code>, <code>std::cin</code>, <code>std::cerr</code>, <code>std::clog</code>, keyboard drivers, graphics display, sound buffers, networks packets) are volatile either directly or transitively. So the compiler cannot remove inputs or outputs of the program, but anything in-between basically.

volatile

Volatile should be used when you must be certain that a certain write or read is not removed by the compiler as dead. For example when you are writing a hardware driver, you would set control variables that must be written to some bus as volatile. 

volatile

That is pure luck that it is working on your compiler. The compiler is allowed to change the order of reads and writes AROUND your volatile accesses as long as they don't affect the values of the volatile accesses. Also the CPU may or may not re-order some stores or loads depending on the CPU (x86 has a conveniently strict memory model which only has one case where memory accesses may complete out of order). 

What you need is a <a href="https://en.wikipedia.org/wiki/Memory_barrier" rel="nofollow noreferrer">memory barrier</a>. A memory barrier forces both the compiler to generate code in such a way that all writes before the barrier happens before the barrier and tells the CPU to make sure all writes before the barrier has happened before the barrier completes. The above is a bit simplified, there are different memory types of barriers which say what must be completed before the barrier completes. If you're interested, see <a href="http://en.cppreference.com/w/cpp/atomic/memory_order" rel="nofollow noreferrer"><code>std::memory_order</code></a>.

volatile

POST

Yes, the compiler can do quite some fancy optimisations with re-ordering stores and loads and instructions so that they will effectively use the CPU's registers and to make sure that multiple issue kicks in on some CPUs. By using <code>volatile</code> you are prohibiting the compiler from doing some of these optimisations as you are forcing it to emit a read or write in a specific order.

In summary, don't use <code>volatile</code> unless you're absolutely sure that you need it.

You specify:

SUBMITTED

SymmetricDecryptionBlockCipherMode);
    String padding = manager.getStringValue(SymmetricDecryptionPadding);

    // Key bytes are only the first 16 bytes
    final int KEY_BYTES_STARTING_BYTE = 0;
    final int KEY_BYTES_ENDING_BYTE = 16;

    // IV bytes are only the first 16 bytes
    final int IV_BYTES_STARTING_BYTE = 0;
    final int IV_BYTES_ENDING_BYTE = 16;

    // Cipher bytes are everything after first

PRE

What manager is this, and why does the method have to perform its own configuration?

MID


// Key bytes are only the first 16 bytes
final int KEY_BYTES_STARTING_BYTE = 0;
final int KEY_BYTES_ENDING_BYTE = 16;

final int IV_BYTES_STARTING_BYTE = 0;
final int IV_BYTES_ENDING_BYTE = 16;



POST

Entirely not needed, and if they were they should be <code>private static</code> class variables, the Java equivalent of constants. What about using <code>Cipher#getBlockSize()</code>?

SUBMITTED

isfermat_alg2(prime):
                self.fermat_number_true += 1
                return True, prime
            else:
                self.fermat_number_false += 1
                return False, prime
    def next_fermatf(self):
        true, num = self.next_fermat()
        if true:
            print("%d\t\t%f" % (num, (self.fermat_number_true / (self.fermat_number_false + self.fermat_number_true)) * 100))
        else:
            print("%d\tX\t%f" % (num, (self.fermat_number_true / (self.fermat_number_false + self.fermat_number_true)) * 100))

    def fermat(self):
        while True: self.next_fermatf()

    def isfermat_alg1(self, num, squares):
        for square in squares:
            if num &gt; square:
                difference

PRE

since the <code>==</code> will always produce a bool.     

I would code:

MID

def next_fermatf(self):
    true, num = self.next_fermat()
    if true:
        print("%d\t\t%f" % (num, (self.fermat_number_true / (self.fermat_number_false + self.fermat_number_true)) * 100))
    else:
        print("%d\tX\t%f" % (num, (self.fermat_number_true / (self.fermat_number_false + self.fermat_number_true)) * 100))


more like:

def next_fermatf(self):
    is_next_fermat, num = self.next_fermat()

    msg = "" if is_next_fermat else "X"        
    print("%d\t%s\t%.1f%%" % (num, msg, 
        100.0 * self.fermat_number_true /
        (self.fermat_number_false + self.fermat_number_true))))


POST

SUBMITTED

_1.txt

PRE

As you can see, most of it is either error checking or command line arguments. The actual conversion is only one line of code. 

One issue I still found: 

MID

*.txt

POST

SUBMITTED

path import join, dirname

PRE

MID

path.join

POST

SUBMITTED

public static List&lt;Guid&gt; FilterOnContent&lt;T&gt;(List&lt;T&gt; ratedItems,
        List

PRE

MID

List&lt;Guid&gt; FilterOnContent&lt;T&gt;

You should use if/else structure when you need only a single condition to be triggered instead of multiple if's as the compiler will have to go over all of them, but that's not necessary because let's say <code>typeof(T) == typeof(Restaurant)</code> do you want to check <code>typeof(T) == typeof(AlgorithmRestaurant)</code> and the rest of your conditions? 
There is no point the type argument cant be 2 types at the same time.

var rated = (IEnumerable&lt;AlgorithmRestaurant&gt;)ratedItems;
var toFilter = (IEnumerable&lt;AlgorithmRestaurant&gt;)itemsToFilter;


Those helper variables seem pointless to me they just add 2 extra lines in each <code>if</code> branch.

The <code>.ToList()</code> also adds a few extra characters, while you can just call it once at the return statement.

You currently have only <code>if</code> statements so you cant guarantee for the compiler that there will always be exactly one condition that will be met, which means you need to allocate some extra memory at initialization:

var ratedRcis = new List&lt;RecommenderContentItem&gt;();


POST

But with multiple <code>else if</code>'s and a one <code>else</code> for the exception you wont need to do that.

The empty <code>.Any()</code> overload is O(1) operation but with <code>else</code> at the end you wont even need to do that.

With all of that in mind you can make your method look like this:

SUBMITTED

class DatabaseConnection
{
    public SqlConnection sqlconn { get; set; }
    public DatabaseConnection(string

PRE

I see a few issues with your class: 

<strong>Issue 1</strong> 

This property is open so anyone can set it:

MID

public SqlConnection sqlconn { get; set; }


POST

You probably want to make the setter private so only you can set it from within the class and it can be accessed from outside. 

<strong>Issue 2</strong> 

The property name should be <code>SqlCon</code> because the convention is to use <em>Pascal</em> naming in C#.

<strong>Issue 3</strong> 

You have this in your constructor: <code>OpenConn();</code> which means as soon as someone creates an instance of your class, you open the connection but what if the user of your class does not want to open the connection yet?

<strong>Issue 4</strong>

Why are you making the assumption that the user of you class will be using windows forms? What if I use your class from a console application, how will <code>MessageBox.Show</code> work?

SUBMITTED

double D

PRE

MID

D

POST

<strong>Solution issues:</strong>

the sign of v indicates the 'direction of counting' round the clock, positive increments from 0, negative decrements from m

SUBMITTED

combination.push_back

PRE

MID

push_back()

POST

SUBMITTED

x,y])


    # Step 2 - Initialize AccumulatorArray and EllipsesFound-Array
    AccumulatorArray = []
    EllipsesFound = []

    # Step 3 - Loop through all pixels
    ignore_indices = set()
    for i in range(len(EdgePixel)):
        if i in ignore_indices:
            continue
        # Step 4 - Loop through all pixels a second time
        for j in range(len(EdgePixel)):
            if j in ignore_indices:
                continue
            if i != j:
            xAverage, yAverage, aAverage, bAverage, orientationAverage = 0, 0, 0, 0, 0
            # (Step 12, clear Accumulator-Array)
            AccumulatorArray = []
            
            tmp = math.sqrt(abs(math.pow

PRE

It's not needed in this scope, and in the scope where it <em>is</em> used the first thing that happens is that it's reinitialised, so this line is completely pointless.

MID

for i in range(len(EdgePixel)):
    if i in ignore_indices:
        continue
    # Step 4 - Loop through all pixels a second time
    for j in range(len(EdgePixel)):
        if j in ignore_indices:
            continue
        if i != j:


POST

This should be one of <code>if i &lt; j:</code> or <code>if j &lt; i:</code> because otherwise any pair of points which is rejected as a major axis will be tested a second time with the indices reversed, doubling the workload.

SUBMITTED

i);
                break;
        }
    }

    console.log(result_array.join

PRE

You ought to return the <code>results</code> array from the function, instead of making the function print it. The advantage of that is if you need to do something else with the result, you can just let the caller handle it and not have to modify the function. Just replace <code>console.log(results.join(','));</code> with <code>return results</code>, then just call like this:

MID

console.log(multipleOf4Or7().join(','));


POST

Right now your function is not very flexible, because all the values are hard-coded into the function.

What if you wanted to run it for 30 instead of 10?

What if you wanted to use 3 and 5, instead of 4 and 7?

What if you wanted to use values other than <code>x</code> and <code>y</code>?

Right now, you can't do any of that without changing or copying the function. JavaScript functions can have <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters" rel="nofollow noreferrer">default parameters</a> which would make it to where regular function calls with no arguments will return the exact same results, but you do have the option to call it with different arguments.

To do that, let's move all the hard-coded values into named parameters in the function signature of a new function, and replace the hard coded values:

SUBMITTED

public HashMap&lt;String, List&lt;Integer&gt;&gt; createMap(String[] strs)
{
  HashMap&lt;String, List

PRE

MID

Map&lt;String, List&lt;String&gt;&gt;

HashMap&lt;String, List&lt;String&gt;&gt;

&lt;&gt;

new HashMap&lt;&gt;

new HashMap&lt;String, List&lt;String&gt;&gt;

POST

SUBMITTED

wait));
            boost::asio::write(args.first-&gt;socket_, boost::asio::buffer(&amp;args.second, sizeof(message_t)), ec);
            if (ec) std::cerr &lt;&lt; ec.message().c_str() &lt;&lt; std::endl;
        }
    }

public:
    SendRetarder

PRE

However, this has a major problem.  What if the object is destroyed after this thread is launched?  Everything within the <code>send_loop()</code> routine that relies on object variables is going to be potentially using de-allocated memory and non-existent objects!  Prevent this by using <code>shared_from_this</code> and a <code>std::shared_ptr</code> instead of just passing <code>this</code>.

What happens to the detached thread if the object is destroyed?  Nothing, at the moment, and that's a problem.  If the object is destroyed, it seems to me that either there should be a way to signal the detached thread that it's time to quit.  One simple way to do that is to close the underlying socket which is one thing that should probably be done in a destructor.

If you are using a compiler that supports at least C++11, consider using a better random number generator.  In particular, instead of <code>rand</code>, you might want to look at <a href="http://en.cppreference.com/w/cpp/numeric/random/uniform_int_distribution" rel="nofollow noreferrer"><code>std::uniform_int_distribution</code></a> and friends in the <code>&lt;random&gt;</code> header.

The line that writes the message  to the socket looks like this:

MID

boost::asio::write(args.first-&gt;socket_,
                   boost::asio::buffer(&amp;args.second, sizeof(message_t)), ec);


POST

That works right now, but what happens if you decide to have a variable size message?  For example, consider this:

SUBMITTED

where('Id',$request-&gt;input('campaignText'))-&gt;first();
        if(!empty($fromEmail) &amp;&amp; !empty($template) &amp;&amp; !empty($campaign)) {
            putenv("MAIL_USERNAME=$fromEmail

PRE

The same can be said for this subsequent conditional that has no <code>else</code> condition:

MID

if(!empty($fromEmail) &amp;&amp; !empty($template) &amp;&amp; !empty($campaign)) {


POST

I really do not understand why you would be setting variables that only have meaning in an execution context to your environment (your calls using <code>putenv()</code>).  Do you really want to change environmental variables every time you send an email?

SUBMITTED

else

PRE

MID

else

POST

Well, that's up to you, to be honest. You could put <code>let ... in</code> into a new line, for example:

SUBMITTED

page)
    a

PRE

MID

a

POST

SUBMITTED

sbrk

PRE

MID

sbrk

POST

SUBMITTED

a directory."""
        try:
            paths = tuple(source.iterdir())
        except

PRE

The docstrings are clear and helpful.
They should be unnecessary, redundant with the method name,
except that curiously the method starts "acquire" rather than "serialize".
Not sure what the motivation was.

MID

            paths = tuple(source.iterdir())


POST

This is not pythonic.
An arbitrary number of directory entries will come back.
Prefer <code>list</code> over <code>tuple</code> in such a case.
Assign <code>[]</code> at end of exception handler.

SUBMITTED

endl;
                                    giantHP = giantHP - abilitydmg;
                                    HP = HP - giantAttack;
                                    mana = mana - manaCost;
                                    goto giantFight;
                                }
                                else if(action3==3)
                                {
                                    if(hpPots&lt;=0)
                                    {
                                        std::cout   &lt;&lt; "You have no potions!\n\n";
                                        goto giantFight;
                                    }
                                    else
                                    std::cout   &lt;&lt; "You drink the potion.\n"
                                                "+10 Health!";
                                    HP = HP + 10;
                                    hpPots = hpPots - 1;
                                    goto giantFight;
                                }
                                else if(action3==4)
                                {
                                    if(manaPots&lt;=0)
                                    {
                                        std::cout   &lt;&lt; "You have no potions!\n\n";
                                        goto

PRE

I see a number of things that may help you improve your program.

All of the logic here is in <code>main</code> in one rather long and dense chunk of code.  It would be better to decompose this into separate functions.

There are inconsistent spaces at the beginning of lines, inconsistent indentation and inconsistent use and placement of curly braces <code>{}</code>.  Being consistent helps others read and understand your code.

In a number of places in the code, the indentation suggests that there is a problem with your <code>else</code> clauses.  For example, in this code: 

MID

if(hpPots&lt;=0)
{
    std::cout   &lt;&lt; "You have no potions!\n\n";
    goto giantFight;
}
else
std::cout   &lt;&lt; "You drink the potion.\n"
            "+10 Health!";
HP = HP + 10;
hpPots = hpPots - 1;
goto giantFight;


The only thing that's executed by the <code>else</code> clause is the <code>std::cout</code> line.  All lines following are executed no matter what.  In other words, it's as though the code were written like this:

if(hpPots&lt;=0)
{
    std::cout   &lt;&lt; "You have no potions!\n\n";
    goto giantFight;
}
else
{
    std::cout   &lt;&lt; "You drink the potion.\n"
                "+10 Health!";
}
HP = HP + 10;
hpPots = hpPots - 1;
goto giantFight;


POST

In this case it doesn't make much difference because of the <code>goto</code> line, but in general, it's wise to always use <code>{}</code> to make sure that both you and other readers of the code are clear about what's happening.  

There's more, but it's all essentially the exact <a href="https://codereview.stackexchange.com/questions/103740/text-based-rpg-game-in-c/103892#103892">same things I told you a year and a half ago.</a>

SUBMITTED

class Solver

PRE

MID

Solver

POST

SUBMITTED

fprintf(qFile, "%-1.1c", mod[cnt].name[30]);
          fprintf(qFile, "%-1.1c,", mod[cnt].name[31]);
          fprintf(qFile, "%.6i,", mod[cnt].dateStart);
          fprintf(qFile, "%.6i,", mod[cnt].dateEnd);
          fprintf(qFile,"\n");
          bytes = (bytes + 1328);
    };

    fclose(pFile);
    fclose(qFile);
    std

PRE

You could try merging all of your <code>fprintf()</code> calls into this single call:

MID

fprintf(qFile, &quot;%.32s,%.6i,%.6i,\n&quot;, mod[cnt].name, mod[cnt].dateStart,
        mod[cnt].dateEnd);


POST

The <code>%.32s</code> specifier means &quot;print a string up to 32 characters long&quot;.  From the example output you showed in the comments, I think that this would work for you.  If you don't need a trailing comma at the end of the line, you could remove it.  (Your code had it there but your example didn't so I left it in).

SUBMITTED

RandomPlayer( char _symbol ) : Player( _symbol ) {}
    virtual void makeMove()
    {
        std::vector &lt; int &gt; v;
        for( int i = 0; i &lt; 9; ++i )
            if( gameField[ i ] == ' ' )
                v.push_back( i );

        gameField[ v[ rand() % v.size() ] ] = symbol;
    }
};

struct WRandmomPolciy
{
    static int getMove(DataBaseType::iterator s)
    {
        const int sum = std::accumulate( s -&gt; second.weight, s -&gt; second.weight + 9, 0 );
        if( sum == 0 )
            return std::find( gameField, gameField + 9, ' ' ) - gameField;

        std::vector &lt; int &gt; coords;
        for( int i = 0; i &lt; 9; ++i )
            std::fill_n( std::back_inserter( coords ), precCoeff * s -&gt;second.weight[ i ] / sum, i );
        return coords[ rand() %  coords.size()];
    }
};


template &lt;class LearningPolciy&gt;
class SmartPlayer : public Player,
                    public LearningPolciy
{
private:
    struct HistoryElement
    {
        DataBaseType::iterator situation;
        int move;
        HistoryElement(DataBaseType::iterator s, int m )
            : situation( s

PRE

There are two problems with this approach. One is that the low order bits of the random number generator are not particularly random, so neither is your result. On my machine, there's a slight but measurable bias toward 0 with that.  The second problem is that unless <code>RAND_MAX</code> happens to be an integral multiple of <code>v.size()</code>, this will not result in a uniform distribution. A better solution, if your compiler and library supports it, would be to use the <a href="http://en.cppreference.com/w/cpp/numeric/random/uniform_int_distribution" rel="nofollow noreferrer">C++11 <code>std::uniform_int_distribution</code></a>.  

The current code includes this object:

MID

struct WRandmomPolciy
{
    static int getMove(DataBaseType::iterator s)
    {
        const int sum = std::accumulate( s -&gt; second.weight, s -&gt; second.weight + 9, 0 );
        if( sum == 0 )
            return std::find( gameField, gameField + 9, ' ' ) - gameField;

        std::vector &lt; int &gt; coords;
        for( int i = 0; i &lt; 9; ++i )
            std::fill_n( std::back_inserter( coords ), precCoeff * s -&gt;second.weight[ i ] / sum, i );
        return coords[ rand() %  coords.size()];
    }
};


The ultimate effect of this is to create a potentially <em>huge</em> vector just to select one entry and throw the rest away.  This is a very inefficient way to do things, in addition to the problem with the random number mentioned earlier.  The goal, as I understand it, is to select a move with a probability proportional to its weight.  There's a very direct and efficient way to do that in C++11 using <a href="http://en.cppreference.com/w/cpp/numeric/random/discrete_distribution" rel="nofollow noreferrer"><code>std::discrete_distribution</code></a>

class SmartPolicy
{
public:
    int getMove(DataBaseType::iterator s)
    {
        const auto &amp;w = s-&gt;second.weight;
        std::discrete_distribution&lt;&gt; dist(w.begin(), w.end());
        return dist(gen);
    }
private:
    std::mt19937 gen;
}


POST

Note that in my version, <code>TWeight</code> is now a <a href="http://en.cppreference.com/w/cpp/container/array" rel="nofollow noreferrer"><code>std::array&lt;int, 9&gt;</code></a>.

The code declares and uses several global variables.  Global variables obfuscate the actual dependencies within code and make maintainance and understanding of the code that much more difficult.  It also makes the code harder to reuse.  For all of these reasons, it's generally far preferable to eliminate global variables and to instead pass pointers to them.  That way the linkage is explicit and may be altered more easily if needed.   The constants are not so bad, but <code>gameField</code> really should be inside of <code>main</code> rather than global.  

The <code>gameField</code> has both data and logic associated with it.  This strongly suggests an object.  I'd propose something like this:

SUBMITTED

Office').strip()==dataframe.get_value(j,'Back Office').strip()
                and Correction.get_value(i,'BO System Code').strip()==dataframe.get_value(j,'BO System').strip()):
                #print('level 1 success')
                # dataframe.set_value(j,'Modified',1)
                if (((Correction.get_value(i,'Emetteur Trade Id').strip()==dataframe.get_value(j,'Emetteur Trade Id').strip()) and Correction.get_value(i,'Emetteur Trade Id').strip()!='#') or
                        (Correction.get_value(i,'Emetteur Trade Id').strip()=='#' and Correction.get_value(i,'BO Trade Id').strip()==dataframe.get_value(j,'Trade Id').strip())):
                    print ('level 2 success')
                    # dataframe.set_value(j, 'Modified', 2)
                    if (int(Correction.get_value(i,'UE'))==int(dataframe.get_value(j,'Entity')) and Correction.get_value(i,'Id Ricos').strip()==dataframe.get_value(j,'Siris Id').strip()):
                        print ('level 4 success')
                        # dataframe.set_value(j, 'Modified', 3)
                        if Correction.get_value(i,'Status').strip()=='Modified X':
                            # dataframe.set_value(j, 'Modified', 4)
                            print ('level 5 success')
                            if Correction.get_value(i,'Maturity Date').strip()==dataframe.get_value(j,'Maturity Date').strip() and Correction.get_value(i,'Start Date').strip()==dataframe.get_value(j,'Start Date').strip():
                                print('identification success')
                                print('Doing

PRE

interaction going on that your code should explicitly model, rather than using copy-n-paste string constants.

On a separate topic, I'm looking at this:

MID

            if (((Correction.get_value(i,'Emetteur Trade Id').strip()==dataframe.get_value(j,'Emetteur Trade Id').strip()) and Correction.get_value(i,'Emetteur Trade Id').strip()!='#') or
                    (Correction.get_value(i,'Emetteur Trade Id').strip()=='#' and Correction.get_value(i,'BO Trade Id').strip()==dataframe.get_value(j,'Trade Id').strip())):
                print ('level 2 success')
                # dataframe.set_value(j, 'Modified', 2)
                if (int(Correction.get_value(i,'UE'))==int(dataframe.get_value(j,'Entity')) and Correction.get_value(i,'Id Ricos').strip()==dataframe.get_value(j,'Siris Id').strip()):
                    print ('level 4 success')


POST

Is level 3 like Fight Club? We just don't talk about it?

The code you posted may "work" in the sense that it produces useful output, but it does not appear to be ready for a code review. You clearly have some ideas about how to usefully refactor it. I invite you to apply some of those ideas and to repost. We will still be here, ready to review!

SUBMITTED

function delete

PRE

MID

delete

POST

SUBMITTED

namespace App

PRE

MID

App

POST

SUBMITTED

gt;exec_query_array

PRE

MID

exec_query_array()

POST

SUBMITTED

a siren

PRE

MID

siren()

siren()

POST

SUBMITTED

try:
            choice

PRE

MID

choice

POST

SUBMITTED

var animInfo

PRE

MID

animInfo

POST

SUBMITTED

Rational::simplify

PRE

You can add optionally add <code>requires std::is_integral&lt;T&gt;::value</code> if you're using Concepts (if you don't, a violation will be reported from the <code>Rational</code> constructor, so it doesn't add significant value).

We have an asymmetry because we can add <code>Rational + int</code> but not <code>int + Rational</code>.  We need a non-member <code>operator+</code> to get our first argument converted for us.

If you provide <code>operator&lt;</code> and <code>operator==</code>, you can get all the others by <code>using namespace rel_ops;</code> where you want them.

When we move to C++20, we can use the new &quot;spaceship&quot; operator <code>&lt;=&gt;</code> instead; that simplifies our work even further.

MID

simplify()

Most places where <code>simplify</code> is called are of the form:

simplify();
return *this;


By allowing <code>simplify()</code> to return that reference, we can reduce all those to

return simplify();


POST

I've made nearly all the changes above (including the changes to the class definition that were out of scope for you) and I'm assuming C++17 with concepts.  My compilation command is

SUBMITTED

int a,b,x,y,c=0;
        cin&gt;&gt;a&gt;&gt;b&gt;&gt;x&gt;&gt;y;
        for(int i=a;i&lt;=b

PRE

You obviously don't need the old value preserved by the postfix increment operations.

<strong>Performance of formatted text extraction</strong>

The values of of n,q,a,x,y,b are ranging from 1 to 40000. so it gets the timeout therefore it needs to further optimised

As for your performance concerns:

Formatted text extraction in c++ is costly. You may get a performance improvement just using <code>scanf()</code> in this case.

While

MID

cin&gt;&gt;a&gt;&gt;b&gt;&gt;x&gt;&gt;y;


applies four function calls

scanf("%d %d %d %d",a,b,x,y);


POST

would be only one call. Also the internal implementation of the formatted text extraction syntax boils down to some <code>scanf()</code> like functions for most of the c++ compilers anyways.

SUBMITTED

std::size_t
        if (!((std::istringstream) argv[1] &gt;&gt; limit)) {
            std::cerr &lt;&lt; "Invalid

PRE

Will compile just as expected. Yet the test inside the function will never catch that -1.

MID

if (!((std::istringstream) argv[1] &gt;&gt; limit)) {


POST

Yes I can see what you are doing. But will everybody!

Casting a <code>char const*</code> to a stream (not correctly by the way). Then reading the value from the stream into limit and checking that the read worked in one statement.

Unfortunately you got it wrong. But it's still a valid statement.

What is happening here is you are taking the pointer and shifting the bits of the pointer right by limit (currently undefined). The resulting pointer is then cast to a string stream (creating a stringstream object). This is tested with the <code>operator!</code> and since you have not read from it will always return true.

This is a good point to advertize that you should increase your warning level well beyond normal. All warnings are logical errors in your thinking. Your compiled code should not generate any warnings.

I think the minimum warning flags should be:

SUBMITTED

gt; [/ &lt;modifier&gt

PRE

MID

List&lt;&gt;

POST

SUBMITTED

public int

PRE

MID

int

int

POST

What you really want to pass down from mother class to subclass, is functionalities, not necessarily implementations. Interfaces do that perfectly well, as they inherit each other without bringing an annoying implementation with them:

SUBMITTED

List&lt;TimePeriod&gt; GetTimesAvail(String person

PRE

MID

IEnumerable&lt;TimePeriod&gt;

List&lt;TimePeriod&gt;

POST

SUBMITTED

reveal(const

PRE

MID

const

POST

The <code>Cell::show()</code> routine doesn't alter the underlying <code>Cell</code> object, and so it should be declared <code>const</code>.

SUBMITTED

compareAreasOffigures(Shape* a, Shape* b){
    if (a-&gt;area() == b-&gt;area()) {
        std::cout

PRE

Don't use equality comparison for floating point types like

MID

if (a-&gt;area() == b-&gt;area())


POST

it's unlikely these will be exactly equal.

Rather test against <a href="http://en.cppreference.com/w/cpp/types/numeric_limits/epsilon" rel="nofollow noreferrer"><code>std::numeric_limits::epsilon</code></a>, there's a comprehensive example in the linked documentation.

SUBMITTED

defining possible lists
lists = ['cars','favorite

PRE

MID

# defining possible lists


POST

Don't write comments that describe <em>what the code does</em>; we can see the code, we know what it's doing. If you ever need comments, it's where it's otherwise unclear <em>why the code's doing it</em>.

SUBMITTED

DBUtil dbConnection

PRE

MID

dbConnection

POST

SUBMITTED

class USS

PRE

MID

USS

POST

SUBMITTED

requests.get

PRE

MID

get

POST

SUBMITTED

return 2 * (length + with);
    }

    public String toString() {
       return &quot;&lt;&quot; + this.with + this.with + this.area() + this.perimeter() + &quot;&gt;&quot;;
    }

    public static Rectangle[] selectRectangle(Region[] region) {
        int

PRE

In my point of view you cannot implement
<code>area()</code> and <code>perimeter()</code> any clearer or simpler.

In the <code>toString()</code> method I would somehow separate the values and also not print  <code>with</code> two times and <code>length</code> not at all.
Here is my suggestion:

MID

 public String toString() {
       return "&lt;" + with + " x "+ length + ", area:" + this.area() + " perimeter: "+ perimeter() + "&gt;";
    }


POST

In <code>Rectangle[] selectRectangle(Region[] region)</code> I would use an ArrayList to avoid the loop to count the number of Rectangles.

SUBMITTED

U. SR

PRE

MID

SR.

POST

SUBMITTED

while (solver.findNextSatisfyingAssignment()) {
            System.out.println(toAssignmentString(variableArray));
        }


        solver.findNextSatisfyingAssignment

PRE

Overall it looks great. I like how you implemented <code>comparable</code> to make use of the implicit sorting in a <code>TreeSet</code>.

I see you also corrected the formula to really be in CNF now.

I also like that you added a helper method to print the assignment:

MID

System.out.println(toAssignmentString(variableArray));


POST

A small suggestion here is to change that helper function to directly print it. So your call looks like:

SUBMITTED

inserted!!'
            raise Exception()

        return self.root.contains(element) if self.root else RET_NO

    def size(self):
        return self.root.size

PRE

In the method <code>Tree.contains</code>, you already checked if <code>self.root is None</code>, so this

MID

return self.root.contains(element) if self.root else RET_NO


can be simplified to this

return self.root.contains(element)


Instead of <code>contains</code> you can define the <a href="https://docs.python.org/3/reference/datamodel.html#object.__contains__" rel="noreferrer"><code>__contains__</code></a> method. Then you can use the <code>in</code> keyword:

return element in self.root


POST

Although in this particular case it's less readable, so it's probably better to just stick with <code>contains</code>.

Method <code>Tree.bulk_insert</code> is just wrong. There's no point in having an empty list for a default argument. In the <code>for</code> loop you <em>modify the list</em> while iterating over it, and on each iteration you call the <code>len</code> function. Why? Even the C-style

SUBMITTED

class Execute:

    def __init__

PRE

Don't use <code>self.__init__</code>. I'm somewhat surprised your code isn't doing anything dodgy because of it. Instead just make another function that is independent from Python internals.

MID

Execute.__init__

POST

Use variables rather than indexes of lists. Some of your code is really hard to read due to this. Take:

SUBMITTED

for item in to_dict['behavior']['summary']['file_written']:
    pid6 = to_dict['behavior']['summary']['file_written']
#
for item in to_dict['behavior']['summary']['file_exists']:
    pid7 = to_dict['behavior']['summary']['file_exists']

for item in to_dict['behavior']['processes']:
    pid8 = to_dict['behavior']['processes']

write_in_file = open('resultFile.txt','w')
pprint.pprint(pid1,write_in_file)
pprint.pprint(pid2,write_in_file)
pprint.pprint(pid3,write_in_file)
pprint.pprint(pid4,write_in_file)
pprint.pprint(pid5,write_in_file)
pprint.pprint(pid6,write_in_file)
pprint.pprint(pid7,write_in_file)
pprint.pprint(pid8,write_in_file)
#pprint.pprint(pid9,write_in_file)
#pprint.pprint(pid10,write_in_file)
write_in_file.close()   

################################################### Code to Reduce the Noise ##########################################
with open('resultFile.txt', 'r') as file :
    filedata

PRE

Consequently, you may use <code>pids</code> directory for looping - instead of your current

MID

write_in_file = open('resultFile.txt','w')
pprint.pprint(pid1,write_in_file)
pprint.pprint(pid2,write_in_file)
pprint.pprint(pid3,write_in_file)
pprint.pprint(pid4,write_in_file)
pprint.pprint(pid5,write_in_file)
pprint.pprint(pid6,write_in_file)
pprint.pprint(pid7,write_in_file)
pprint.pprint(pid8,write_in_file)
#pprint.pprint(pid9,write_in_file)
#pprint.pprint(pid10,write_in_file)
write_in_file.close()  


you may then write

with open('resultFile.txt','w') as write_in_file:
    for action in actions:
        pprint.pprint(pids[action], write_in_file)


POST

SUBMITTED

a.length;j++)
            {
                if(i==0||i==a.length-1)
                {
                    System.out.print(a

PRE

It's unclear why you chose this.  

MID

                    System.out.print(a[i][j-1]);


This could be 

                    System.out.print(a[i][j]);


POST

Then it prints the output correctly.  

You iterate over each element in the entire square and print different things based on an <code>if</code>/<code>else</code> structure.  But you don't actually have to do that.  Consider 

SUBMITTED

url, true

PRE

MID

true

POST

SUBMITTED

amp; isInternal

PRE

MID

isInternal

isInternal

POST

SUBMITTED

static determineStateOfPackage

PRE

MID

determineStateOfPackage

POST

SUBMITTED

lt;thread&gt;
#include &lt;vector&gt;

std::vector&lt;std::thread&gt; asyncCalls

PRE

MID

std::vector&lt;std::thread&gt; asyncCalls;


This creates a global variable (so, you know, <em>don't do that</em>) — and it creates the global variable in every .cpp file that imports this header file. So unless you only have one .cpp file in your project, you're going to get linker errors when you try to link your project.

What you wanted to do was put this variable definition in a .cpp file and put a <em>declaration</em> of it (using <code>extern</code>) in your .hpp file.

Alternatively, as of C++17, you could have made it an <code>inline</code> variable:

inline std::vector&lt;std::thread&gt; asyncCalls;


However, global variables are terrible; don't do anything like this. Maybe what you want is some notion of "thread pool":

class ThreadPool {
    std::vector&lt;std::thread&gt; asyncCalls;
    // ...
};


POST

SUBMITTED

gt;
    /// Generates a uniformly distributed 32-bit signed integer between the range [min, max].
    /// &lt;/summary&gt;
    public int GetInt32(int x, int y) {
        var min = Math.Min(x, y);
        var max = Math.Max(x, y);
        var range = (max + 1L - min);

        if (uint.MaxValue &gt; range) {
            return ((int)(GetUInt32((uint)range) + min));
        }
        else {
            return GetInt32();
        }
    }
    /// &lt;summary&gt;
    /// Generates a uniformly distributed 32-bit unsigned integer between the range of uint.MaxValue

PRE

Performance shouldn't be an issue while creating the object then I'm explicitly asking for a checked conversion.

In <code>GetUInt32(int, int)</code> you need to cast range to <code>uint</code> just because you're using <code>+ 1UL</code>, just change <code>+ 1UL</code> to <code>+ 1</code>.) Also <code>else</code> after a <code>return</code> is usually redundant. For unsigned numbers overflow should do the job. Let's also see the similar <code>GetInt32()</code>:

MID

public int GetInt32(int x, int y) {
    var min = Math.Min(x, y);
    var max = Math.Max(x, y);
    var range = max + 1 - min;

    if (uint.MaxValue != range) 
        return (int)(GetUInt32((uint)range) + min);

    return GetInt32();
}


If you're <em>really</em> looking for performance then you should avoid those calls to <code>Math.Min()</code> and <code>Math.Max()</code>. You may be surprised about branchless code JIT compiler may generate (when <code>CMOV</code> &amp; <em>friends</em> are supported):

int min = x, max = y;
if (min &gt; max) {
    min = y;
    max = x;
}


Or maybe even:

int min = x &lt; y ? x : y;
int max = x &lt; y ? y : x;


Unfortunately benchmarking this can be tricky because generated code might be different for different CPUs. Just try all of them and pick the easier one to read...What about <code>Math.Abs()</code>? Given that:

$$
|a-b| = \max(a,b) - \min(a,b)
$$

And that compiler is pretty good to avoid branches we may also want to try performance of this (pseudo-code without casts and only for full range):

public int GetInt32(int x, int y) {
    return GetUInt32(Math.Abs(x - y + 1)) + Math.Min(x, y);
}


POST

You may also try to replace <code>Math.Min()</code> with the <em>usual</em> <code>(x &lt; y ? x : y)</code>.

SUBMITTED

F1} ");
        }
    }

    public class MedianList
    {
        private int

PRE

Where is the <code>e</code>? Don't you like it? You should not use abbreviations unless they are well known like <em>html</em> or <em>xml</em> etc.

MID

public class MedianList


POST

Nested classes should not be public. Then this class is not a list and should be called like that. <em>MedialCalculator</em> sounds much better. Shouldn't the <code>InsertForMedian</code> API be named <em>CalcMedian</em>?

SUBMITTED

rush dc

PRE

MID

dc - 6

POST

SUBMITTED

import time, random

def quicksort_benchmark(n=2**24):
    def quicksort(array, low, high):
        if low &lt; high:
            p = partition(array, low, high)
            quicksort(array, low, p)
            quicksort(array, p+1, high)

    def partition(array, low, high):
        pivot_index = random.randint(low, high)
        pivot = array[pivot_index]
        i = low - 1
        j = high + 1

        while True:
            while True: # do while
                i += 1
                if array[i] &gt;= pivot:
                    break

            while True:
                j -= 1
                if array[j] &lt;= pivot:
                    break

            if i &gt;= j:
                return j

            temp = array[i]
            array[i] = array[j]
            array[j] = temp

    start = time.time()

    # initialize array
    array = [random.randint(0, n) for i in range(0,n)]
    quicksort(array, 0, len(array)-1)

    end = time.time()
    elapsed = end - start
    return(elapsed

PRE

As can be seen the quicksort was improved quite a bit with even relatively small changes in your code, but better implementations does exist. For the mergesort I didn't look for alternative implementations, but the changes I made it ran in half the time, resulting in a faster time compared to your implementation of quicksort.

Do also note that the timings varied slightly between runs, but the relation between the order was usually kept as given in the listing. As seen by the timing on <code>sorted</code>, we've not reinvented the wheel in any of these implementations, and for practical purposes we're better of using the default sort methods which runs in 1/10th of the time!

MID

def hquicksort(array, low, high):
  if low &lt; high:
    p = hpartition(array, low, high)
    hquicksort(array, low, p)
    hquicksort(array, p+1, high)


def hpartition(array, low, high):
  pivot_index = random.randint(low, high)

  pivot = array[pivot_index]

  while True:
    while array[low] &lt; pivot:
      low += 1

    while array[high] &gt; pivot:
      high -= 1

    if low &gt;= high:
      return high

    array[low], array[high] = array[high], array[low]

    low += 1
    high -= 1


POST

I could possibly also get rid of the remaining <code>While True:</code>, but the revision does show my point. Note that to get it to work exactly like your code, I also had to add the two last lines to move the index pointers forward.

SUBMITTED

var ajaxCall = function(_url, _type, _data, _successCallback, _errorCallback, isAsync, _completeCallback){          

    // Handling _url
    if(!_url.trim()) throw new Error('Sucess callback

PRE

Central ajax function in jquery

No. Just, no. It's tempting to handle how all AJAX operations are called in your app, but this is usually just for a handful of use cases. I've seen code time and again do this only to actually call <code>$.ajax</code> directly elsewhere because the "global" one just doesn't serve its needs.

MID

var ajaxCall = function(_url, _type, _data, _successCallback, _errorCallback, isAsync, _completeCallback){ 


POST

jQuery AJAX methods return a promise-like object. Use the standard promise interface to assign callbacks instead of using the old callback method. That means, <a href="https://api.jquery.com/deferred.then/" rel="nofollow noreferrer">use the <code>then</code> method</a>. Using this also makes your code easily portable to standard APIs like <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch" rel="nofollow noreferrer"><code>fetch</code></a>. 

Additionally, there's no sense adding <code>_</code> before variable names. It only adds noise. If you mean to avoid collisions, just use different variable names. Don't make it more complicated than it already is.

SUBMITTED

Transport

PRE

MID

Transport

Transport

POST

<strong>Inheritance</strong>

Is it correct to use Transport constructor and inherit from it or I
  must used switch(type of transport) - case (message + )? What way is
  easy to extend?

Inheritance is an extensible approach. However, it requires some overhead and you need to declare some kind of factory function - here: <code>getTrip</code>. This function features a switch statement. In JavaScript, it is often advised to replace switch statements with maps, usually object literals.

Also, your <code>Transport</code> objects currently don't have any methods. They even don't hold any meaningful data apart from one <code>message</code> attribute. Once the constructor function returns an instance, you just use it to retrieve the <code>message</code>.

Additionally, by pushing subclass functionality which is shared by some but not all subclasses - e.g. initialization of <code>gate</code> and <code>baggage</code> - upwards to the parent <code>Transport</code> constructor, you attempt to reduce code repetition at the cost of clear semantics and maintainable code:

SUBMITTED

static void tryEating(Bear

PRE

MID

Bear.tryEating

POST

SUBMITTED

getCurrentVal

PRE

MID

getCurrentVal

POST

SUBMITTED

Cage

PRE

MID

Cage

POST

SUBMITTED

include &lt;cstdint&gt;
#include &lt;cstring&gt;

namespace{

template&lt;size_t SIZE&gt;
int memcmp_fixed_(const unsigned char *s1, const unsigned char *s2){
    for(size_t i = 0; i &lt; SIZE; ++i)
        if (s1[i] != s2[i])
            return s1[i] - s2[i];

    return 0;
}

template&lt;&gt;
int memcmp_fixed_&lt;1&gt;(const unsigned char *s1, const unsigned char *s2){
    return *s1 - *s2;
}

template&lt;size_t SIZE&gt;
int memcmp_fixed_(const void *a1, const void *a2){
    const unsigned char *s1 = (const unsigned char *) a1;
    const unsigned char *s2 = (const unsigned char *) a2;

    return memcmp_fixed_&lt;SIZE&gt;(s1, s2);
}

}

inline int fast_memcmp(const void *a1, const void *a2, size_t const size){
    switch(size){
        case  0: return 0;

        case  1: return memcmp_fixed_&lt; 1&gt;(a1, a2);
        case

PRE

Since we're using the C++ wrappers around standard C functions (which is good - I like it!), we need namespace qualification of <code>std::size_t</code> and <code>std::memcmp</code>).  Although your implementation evidently takes advantage of the license to also include the unqualified names, it's not portable to rely on that.

Instead of repeating the type when casting <code>a1</code> to <code>s1</code> and <code>a2</code> to <code>s2</code>, we can just use <code>auto</code> (and let's be clear about the cast - prefer <code>reinterpret_cast</code> to a catch-all C-style cast).

I managed to simplify <code>memcmp_fixed_</code> by using a recursive template.  For me (with <code>g++ -03</code>), this gave roughly the same execution speed (I guess that loop unrolling makes the resultant binary very similar).  I got rid of the separate <code>void*</code> and <code>unsigned char*</code> overloads - that's just a compile-time overhead and makes no different to runtime speed, which gives 9 lines, compared to your 14 (counting physical lines that contain alphanumerics).

MID

template&lt;std::size_t SIZE&gt;
int memcmp_fixed_(const void *a1, const void *a2)
{
    auto const s1 = reinterpret_cast&lt;const unsigned char*&gt;(a1);
    auto const s2 = reinterpret_cast&lt;const unsigned char*&gt;(a2);
    auto const diff = *s1 - *s2;
    return diff ? diff : memcmp_fixed_&lt;SIZE-1&gt;(s1+1, s2+1);
}

template&lt;&gt;
int memcmp_fixed_&lt;0&gt;(const void*, const void*)
{
    return 0;
}


I slightly simplified the test program to make it a single-character change to build the baseline test (and to send error messages where they belong), and massively reducing the repeated code:

#if 1
#define test_memcmp fast_memcmp
#else
#define test_memcmp std::memcmp
#endif

int main(int argc, char **argv)
{
    if (argc != 3) {
        std::fprintf(stderr, "Usage:\n\t%s [string1] [string2]\n", argv[0]);
        return 1;
    }

    const char *s1 = argv[1];
    const char *s2 = argv[2];
    auto const size  = std::min(strlen(s1), strlen(s2));

    volatile int x = 0;
    for (volatile std::size_t i = 0;  i &lt; MAX;  ++i)
        x += test_memcmp(s1, s2, size);

    std::printf("%d %d\n", test_memcmp(s1, s2, size), x);
}


POST

SUBMITTED

sentence
    df

PRE

MID

df

POST

SUBMITTED

int subdivisionInterval

PRE

MID

subdivisionInterval

POST

SUBMITTED

private Scene

PRE

MID

Scene

POST

SUBMITTED

for (; mask; mask &gt;&gt;= 1)
    {
        r = add(r, r);
        if (mask &amp; n)
            r = add(r, p);
    }
    return r

PRE

Why loop down? If you loop up then you get the platform-independence for free, and also you loop fewer times when <code>n</code> is small. Obviously the loop invariant would change, but it would be closer to school long multiplication and so might also be more maintainable.

MID

    for (; n; n &gt;&gt;= 1)
    {
        if (n &amp; 1)
            r = add(r, p);
        p = add(p, p);
    }


POST

SUBMITTED

s

PRE

The Bash script in <code>-exec</code> doesn't do anything Bash specific, so you could replace <code>bash</code> with <code>sh</code>.

MID

"%s"

POST

SUBMITTED

Comentario'] = d
                extracted_info.append(mydic.copy())    

    # Parse CSV
    #
    # If URL isn't empty
    if attachment_final_url != "" :
        with open(runbookname) as csvfile:
            spamreader = csv.reader(csvfile, delimiter='\t')
            a= 0
            for row in spamreader:
                for i in row :
                    d = i.decode('iso-8859-1').encode('utf8')
                    a = a + 1
                    mappingThoseValues(d,a)
                    if a == 7 :
                        a = 0
        csvfile.close()
    else :
        status_compara_rn_jira = error_format_tab + 'ERROR: No attachments in : ' + myTicket

PRE

Then you can read your csv row values and fill in the dictionary in one simple loop. 

MID

extracted_info = []
with open(runbookname) as csvfile:
    spamreader = csv.reader(csvfile, delimiter='\t')
    for row in spamreader:
        d =  {}
        for key, value in zip(key_names, row):
            d[key] = value.decode('iso-8859-1').encode('utf8')
        extracted_info.append(d)


POST

The important thing here is to understand the function <code>zip</code> and how we can use it in loops. There is plenty of educational material you can find online (<a href="https://stackoverflow.com/questions/13704860/zip-lists-in-python">example</a>). A few other things to notice in the new code:

SUBMITTED

public IHost

PRE

MID

IHost

POST

SUBMITTED

array&lt;uint64_t, 2&gt; array{};
};

}

#endif

PRE

Similarly, the preprocessor could also be used to generate the logic/logic-assignment operators.

MID

    std::array&lt;uint64_t, 2&gt; array{};


POST

The use of <code>std::array&lt;&gt;</code> feels like unnecessary obfuscation.  I'd recommend using two variables with descriptive names (like <code>lo</code> and <code>hi</code>).

SUBMITTED

compareStringLength -eq

PRE

MID

-eq

POST

SUBMITTED

q.push

PRE

MID

push

POST

SUBMITTED

int divisorSum

PRE

MID

int

POST

(See also my review of your <a href="https://codereview.stackexchange.com/a/164847/12390">related question</a>.)

Use a faster sorting algorithm, for example quicksort or merge sort.
And when you, avoid mistakes like <code>if(( divisorSum( array[ i ]) &gt; divisorSum( array[ j ])) || (( divisorSum( array[ i ] ) == divisorSum( array[ j ])) &amp;&amp; ( array[ i ] &gt; array[ j ])))</code>, which recomputes the sum of divisors twice for <code>array[i]</code> and <code>array[j]</code>.
You could store the results of expensive operations in a variable,
and then you can use that variable multiple times in conditions.

SUBMITTED

string = $_POST['query'];
$search = htmlspecialchars($string, ENT_QUOTES, 'UTF-8');
$stmt = $con

PRE

Searches are customarily done using <a href="https://stackoverflow.com/q/504947/1157100">HTTP GET requests rather than POST requests</a>, since they do not modify information on the server.

You are not applying escaping correctly.

Why are you performing HTML escaping here?

MID

$search = htmlspecialchars($string, ENT_QUOTES, 'UTF-8');


POST

The data in the <code>cat_name</code> column should not be HTML-escaped, so it would be inappropriate to HTML-escape the search term.

You are neglecting to perform HTML escaping on <code>$row['cat_name']</code>.  When you are embedding text in HTML, you need to escape it using <code>htmlspecialchars()</code>.  Otherwise, if the <code>cat_name</code> happens to contain a string that looks like an HTML tag, the page could break.

Furthermore, I wouldn't bother constructing <code>$output</code>.  It would be simpler to <code>echo</code> each line of output as it comes.  That gets rid of two lines of clutter: <code>$output = ''</code> and <code>echo $output</code>.  (There might be a slight difference in performance, but I wouldn't worry about it.)

SUBMITTED

Func&lt;ulong, ulong&gt; mod

PRE

I started writing this as a comment, but as I was exploring things got worse and worse.

Your benchmarks (in the comments) do not at all line up with my experience. In fact, they're just the opposite.

I ran your benchmark code, and a few modifications to it, to test <em>truly</em> whether your optimization, specifically for <code>Mersenne5</code>, was faster than the built-in.

Now, I'm not knocking your idea, but if you <em>claim</em> to have a faster production than something, you should have <strong>scientifically reproducible results</strong>. I should be able to copy/paste your code (which I did) and build my own benchmark (which I did) matching your benchmark (which it did) and get a reproducible result that confirms your theory (which it did not really do). What it <em>did</em> confirm is that the <code>_mod</code> vs. <code>_mer</code> methods differed as you indicated, it did <em>not</em> confirm your version is faster.

What it <em>did</em> confirm, is that when compiled to x64 and using the RyuJIT, your version <em>appears</em> to perform faster. (I put 'appears' because of the fact that this is the only time your <em>algorithm</em> is faster, though your version is significantly slower when using the dispatch approach, which is it's intended usage so I don't even know if that claim can be made.)

And I had this nice long answer written out at work, but of course the draft didn't save when I closed my browser and I'm really not in the mood to go through all the work I did again, so I'm just going to tell you why your benchmarks are wrong and leave it to you to investigate.

First: you benchmarked on <em>only</em> x64 build. I know this because when I ran my benchmarks on x64 they came up with the same general idea as yours: ~4us for your <code>Mersenne5(i)</code>, about 8us for <code>ModuloOperator(i, 5)</code> and a little less than 8us for <code>i % 5</code>. However, when I changed this to x86 build, the <code>i % 5</code> performed over <em>twice</em> as fast as your version.

Second: you did not benchmark your 'dispatcher', which adds <strong>a metric tonne</strong> of overhead. When I benchmarked it I saw ~21us on x86, and ~17us on x64. So not only is your x86 algorithm slower, it's also <em>extremely</em> slow when using your dispatcher.

Third: you only benchmarked for the value of <code>5</code>, but what about other key values? You ignored them.

Personally, with the result of the benchmarks I already did (which I may add back in later when I have more time), your code is <em>significantly</em> slower than the built-in, which means this 'optimization' is pointless, as it doesn't optimize at all! What I would recommend, is finding out why RyuJIT is so different (in fact, creating an opposite result) from the 32-bit LegacyJIT.

So I lied, I'm going to go into all the detail I had in my original answer, because I'm already at <a href="https://xkcd.com/386/" rel="noreferrer">this point</a> and I may as well finish up. My stress level is already maxed, so I can't give up now!

<strong>Prior rambling aside</strong>, it's time to talk about what exactly is wrong with your benchmarks.

I'm going to analyze this in a scientific manner. First, we have to ask a question, then do some research, create a hypothesis, formulate an experiment, analyze the results, construct a conclusion, and publish a result. You did some of this, but not all of it. Especially in the experiment.

<strong>Question</strong>: can the built-in modulo be made any faster?<br />
<strong>Research</strong>: utilizing the mersenne prime identities, it is theoretically possible.<br />
<strong>Hypothesis</strong>: Mersenne prime factorization will be faster than the built-in modulo.<br />

Now we have the <strong>experiment</strong>, this is the <em>really, really hard part</em>. <a href="https://codereview.stackexchange.com/a/125587/73844">Benchmarking is hard, Eric Lippert taught me that.</a> Though he didn't just teach me that, he taught me a lot more with such a simple response. He taught me what it takes to create a <em>good</em> benchmark, or at least a <em>good <strong>enough</em></strong> benchmark.

Now a good experiment has a control, and <em>at least one</em> independent variable, only one of which is modified at a time. We need to identify our independent variables, and that's somewhat difficult. You identified one of them: the algorithm, but there are 4 easily identifiable independent variables:

MID

Func&lt;&gt;

POST

SUBMITTED

var Home

PRE

MID

Home

POST

SUBMITTED

def all_rds_instances(config):
    """
    Gets all the RDS instances in a generator (lazy iterator) so you can implement it as:
    `for instance in all_rds_instances(config):`
    """
    marker = ""
    client = boto3.client('rds', region_name=config["region"])
    pool = []

    # min 20, max 100
    page_size = 20
    while True:
        if len(pool) &lt; 1:
            if marker is None:
                break
            # populate a local pool of instances
            result = client.describe_db_instances(MaxRecords=page_size, Marker=marker)
            marker = result.get("Marker")
            pool = result.get("DBInstances")

        if len(pool) &gt; 0:
            this_instance = pool.pop()
            yield this_instance

PRE

Your code is a little hard to read, mostly due to you moving what should be an inner for loop, to be two ifs in an infinite while loop.
If you were to instead for loop over <code>pool</code>, then you could make the code easier to understand.

I'd also make <code>page_size</code> be a keyword argument, so the user can change the page size if they wish. And I'd change <code>config</code> to region, as it makes little sense to me, why you're passing a dictionary to extract a single key.

MID

def all_rds_instances(region, page_size=20):
    """
    Gets all the RDS instances in a generator (lazy iterator) so you can implement it as:
    `for instance in all_rds_instances(region):`

    page_size [explain what this does] should be bound between 20 and 100.
    """
    client = boto3.client('rds', region_name=region)
    marker = ""
    pool = []
    while True:
        for instance in pool:
            yield instance

        if marker is None:
            break
        result = client.describe_db_instances(MaxRecords=page_size, Marker=marker)
        marker = result.get("Marker")
        pool = result.get("DBInstances")


POST

This makes reading the code easier, you know that it will exhaust the <code>pool</code> straight away when reading it, and it makes understanding how you infinitely loop a little easier too.

SUBMITTED

class ItemFactory

PRE

MID

ItemFactory

POST

SUBMITTED

Dim WDTH As Integer = 1000
Dim HGHT As Integer = 1000
Dim Array1(WDTH, HGHT) As Integer
Dim Done As Boolean
Dim Temp1 As Integer = 0
Dim Temp2 As Integer = 0
Dim BGW As New System.ComponentModel.BackgroundWorker

Private Sub Button1_Click

PRE

Not setting <code>Option Strict</code> to <code>On</code> can lead to problems because it enables you to code without strictly typing. See: <a href="https://docs.microsoft.com/en-us/dotnet/visual-basic/language-reference/statements/option-strict-statement" rel="nofollow noreferrer">https://docs.microsoft.com/en-us/dotnet/visual-basic/language-reference/statements/option-strict-statement</a>

It can e.g lead to loss in precision or to a runtime exception.  

MID

Dim Array1(WDTH, HGHT) As Integer
Dim Done As Boolean
Dim Temp1 As Integer = 0
Dim Temp2 As Integer = 0


POST

These variables should be declared inside the <code>BGW_DoWork()</code> method. As a rule of thumb, one should declare variables as near to their usage as possible and should be scoped as thightly as possible.  

While we are at the variables let's talk about naming.<br>
Neither methods, nor parameters, variables, fields should be named using abbreviations. It makes your code harder to read if you first need to figure out in your head what e.g <code>HGHT</code> means. Writing code should be done in a way that enables the reader to grasp at first glance what the code is doing.

Based on the <a href="https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/naming-guidelines" rel="nofollow noreferrer">.NET Naming Guidelines</a> variables/fields should be named using <code>camelCase</code> casing. Although VB isn't case sensitive you will do yourself a favour if you stick to the naming guidelines for each language you learn.

If a variable isn't meant to be changed by code you should make it a <code>const</code>, e.g your <code>WDTH</code> and <code>HGHT</code>.  

By declaring <code>Array1</code> inside <code>BGW_DoWork()</code> you won't need to set the array items to <code>0</code>.

Instead of <code>SetPixel()</code> you could use <code>Bitmap.LockBits()</code> like shown <a href="https://msdn.microsoft.com/en-us/library/5ey6h79d.aspx?cs-save-lang=1&amp;cs-lang=vb#code-snippet-1" rel="nofollow noreferrer">here</a> but this will only save 1 second for a 1000x1000 bitmap. 

The calculation of the values when <code>Array1(x, y) &gt;= 4</code> can be simplified by using integer division like so 

SUBMITTED

element{
            if element%divisor

PRE

Additional remarks:

MID

element % divisor

POST

SUBMITTED

range(2):
            a_card = deck.pop()
            self.player_card.append(a_card)
            self.valuep += values[a_card.split()[0]]
        print '\nYour Initial Cards are : '
        print self.player_card
        print self.valuep

    def player_hand_hit(self):

        if(ip[0] == 0):
            if( self.player_card[0] == 'A of spades' or self.player_card[0] == 'A of hearts' or
                self.player_card[0] == 'A of diamonds' or self.player_card[0] == 'A of clubs' or 
                self.player_card[1] == 'A of spades' or self.player_card[1] == 'A of hearts' or
                self.player_card[1] == 'A of diamonds' or self.player_card[1] == 'A of clubs'):
                values['A']=1
                ip[0] = 1
                self.valuep = self.valuep - 10
        a_card = deck.pop()
        self.player_card.append(a_card)
        self.valuep += values[a_card.split()[0]]
        clear_output()
        print '\nDealers Card are :'
        print"[' * ', '{a}']".format(a=self

PRE

After a quick glance I see there are a few blocks that are repeated. They can be put into functions instead to reduce repetition and make it more readable. The sections are:

1)

MID

if(ip[0] == 0):
    if( self.player_card[0] == 'A of spades' or self.player_card[0] == 'A of hearts' or
            self.player_card[0] == 'A of diamonds' or self.player_card[0] == 'A of clubs' or 
            self.player_card[1] == 'A of spades' or self.player_card[1] == 'A of hearts' or
            self.player_card[1] == 'A of diamonds' or self.player_card[1] == 'A of clubs'):
            values['A']=1
            ip[0] = 1


POST

2)

SUBMITTED

str(x))) - 1:
                for a in working:
                    if is_prime

PRE

MID

for a in working

POST

SUBMITTED

b.n
                          ).Contains("_parent")
                  select c

                ).ToList&lt;I&gt;();

            while (xi.Count &gt; 0)
            {
                foreach (I iobj in xi)
                {
                    String nameId = iobj.T.ToList()
                        .Where(zxc =&gt; zxc.n.Equals("_display_name"))
                        .First().Value;

                    String parentId = iobj.T.ToList()
                       .Where(zxc =&gt; zxc.n.Equals("_parent"))
                       .First().Value;

                    uint elNameUint = Convert.ToUInt32(nameId, 16);
                    String elName = translations[elNameUint

PRE

E.g.

MID

                    String nameId = iobj.T.ToList()
                        .Where(zxc =&gt; zxc.n.Equals("_display_name"))
                        .First().Value;

                    String parentId = iobj.T.ToList()
                       .Where(zxc =&gt; zxc.n.Equals("_parent"))
                       .First().Value;


POST

Even rewriting that to ditch to <code>ToList()</code> and use <code>First(...)</code>, it's doing multiple linear searches through the same array. I would want to investigate whether I could refactor to replace <code>IT[] T</code> with <code>IDictionary&lt;string, string&gt; T</code>.

If I can't, I would strongly consider introducing a local struct or class to wrap <code>iobj</code>, <code>nameId</code>, and <code>parentId</code> so that the search can be done once.

Then in this main loop, <code>xi</code> has elements at random positions selected for removal. In that case it should under no means be a <code>List&lt;&gt;</code>. <code>ISet</code> is far more appropriate for random removals.

<code>FindNode</code> isn't supplied, but I suspect that it also does a linear search. There's nothing stopping you from introducing an <code>IDictionary&lt;string, TreeNode&gt;</code> to find the parents quickly.

(Or: a lot of the preceding was because they're important lessons, but I'm now going to recommend throwing most of the code away and rewriting from scratch).

Why is it necessary to first find the roots and then build parents? And why is it necessary to break out of the inner loop in the second half when you've found a node whose parent is already in the tree? [NB That's a rhetorical question: I know that you're doing it to avoid a concurrent modification exception, but there are standard workarounds for that which are less inefficient].

In particular, is there any reason not to structure things like this?

SUBMITTED

SP

PRE

MID

SP

POST

SUBMITTED

G"
        Case "SSI NUMBER"
            searchColumn = "H"
        Case "PART DESCRIPTION"
            searchColumn = "I"
        Case ""
            MsgBox "Please select a value for what you are searching by."
    End

PRE

What? Give this some context - right now it just looks meaningless.

On this one

MID

Case ""
        MsgBox "Please select a value for what you are searching by."


POST

Just use <code>Case Else</code>.

Consider giving your controls meaningful names. If <code>CommandButton4</code> is the <em>print button</em> go ahead and rename it as such.

SUBMITTED

gt;rank * player-&gt;rank + 250 * player-&gt;rank;
        printf("\n");
        printf("---------\n");
        printf("-RANK UP-\n");
        printf("---------\n");
    }
}

void reward(struct Player* player, int multiplier)
{
    int experience_reward = (player-&gt;intelligence * (1 + 0.1 * player-&gt;rank)) * multiplier;
    int rank_points_reward

PRE

I like to avoid FP math when only <code>int</code> math is needed.  Converting a <code>double</code> to an <code>int</code> results in truncation and not always the expect result once code uses values that are not converted exactly.  (0.1 rarely forms an exact <code>double</code>)

MID

// int experience_reward = (player-&gt;intelligence * (1 + 0.1 * player-&gt;rank)) * multiplier;
int experience_reward = 
  (player-&gt;intelligence * (10 + player-&gt;rank)) * multiplier / 10;


Highest level is not correct ;-)

// strcpy(player-&gt;ranks[9], "Mathematician");
strcpy(player-&gt;ranks[9], "Programmer");


POST

SUBMITTED

the package
    bool handlePackageData(uint32_t lastAck, uint32_t seqNumber, RecvBuffer buffer);

    /// Clears critical messages that were acknowledged by the

PRE

In general, you should avoid passing by value, except build-in types (int, bool, etc). Better pass by reference.
That comes to my mind when I saw lines like:

MID

bool MessageManager::handlePackageData(uint32_t lastAck, uint32_t seqNumber, RecvBuffer buffer)


POST

<em>Buffer</em> is the key that triggered my when reading the parameter name <em>RecvBuffer</em>. You possibly do a lot of copying there.

You seam to grant access to some internal data i.e. on

SUBMITTED

std::memory_order_acquire)){
            std::this_thread::yield();
        }

        // wait for readers to exit
        while (readers_count != 0 ){
            std::this_thread::yield();
        }
    }
    void unlock() {
        write_now.store(false, std::memory_order_release

PRE

This comment should say <code>lock have priority</code>, or simply <code>writers have priority</code>.

C++ nitpick: Consider marking all of these member functions <code>noexcept</code>.

Functionality suggestion: Consider providing a way for a writer to atomically demote itself to a reader, without releasing the lock (i.e., without allowing some other writer B to sneak in and change the value that A just wrote). This should be possible, I think; and it's definitely not possible for anyone <em>but</em> you, the author of the mutex, to provide this functionality.

I think it's as simple as this:

MID

void unlock_and_lock_shared() {
    readers_count.fetch_add(1, std::memory_order_acquire);
    write_now.store(false, std::memory_order_release);
}


POST

The naming convention comes from <a href="http://www.boost.org/doc/libs/1_50_0/doc/html/thread/synchronization.html#thread.synchronization.mutex_concepts.upgrade_lockable.unlock_and_lock_shared" rel="nofollow noreferrer">Boost</a>.

SUBMITTED

fbind('text',
                                                     self._update_text,
                                                     instance)

    def _update_text(self, button,
                     instance, value):
        button.text = value

    # The functions below update

PRE

Why write like this:

MID

def _update_text(self, button,
                 instance, value):
    button.text = value


When you can write more naturally as:

def _update_text(self, button, instance, value):
    button.text = value


POST

SUBMITTED

Date)
        txtEndDate.Text = endDate
    End Property

    Private Sub UserForm_Initialize()

        '/ Determine system date format and update userform display
        Select Case Application.International(xlDateOrder)

            Case 0
                '/ Month-Day-Year
                pDateFormat = "MM/DD/YYYY"

            Case 1
                '/ Day-Month-Year
                pDateFormat = "DD/MM/YYYY"

            Case 2
                '/ Year-Month-Day
                pDateFormat = "YYYY/MM/DD"

        End Select

        lbStartDateFormat.Caption = pDateFormat
        lbEndDateFormat.Caption = pDateFormat

        '/ Set exit check
        pValidExit = False

    End Sub

    Private

PRE

And then this:

MID

Select Case Application.International(xlDateOrder)

    Case 0
        '/ Month-Day-Year
        pDateFormat = "MM/DD/YYYY"

    Case 1
        '/ Day-Month-Year
        pDateFormat = "DD/MM/YYYY"

    Case 2
        '/ Year-Month-Day
        pDateFormat = "YYYY/MM/DD"

End Select


Becomes:

Select Case Application.International(xlDateOrder)

    Case MonthDayYear
        pDateFormat = "MM/DD/YYYY"

    Case DayMonthYear
        pDateFormat = "DD/MM/YYYY"

    Case YearMonthDay
        pDateFormat = "YYYY/MM/DD"

End Select


POST

Nitpick, I'd probably rename <code>AskDateRange</code> to <code>PromptDateRange</code>, and <code>ufAskDateRange</code> would be <code>DateRangePromptDialog</code> - not a fan of the Hungarian <code>uf</code> for <code>UserForm</code> here.

UX nitpick - I'm not a fan of popping <code>MsgBox</code> for something like input validation; it feels a bit clunky IMO. A <em>better</em> way would be to have <kbd>Ok</kbd> and <kbd>Cancel</kbd> buttons, and only enable <kbd>Ok</kbd> when the form is in a valid state, and perhaps have a label that's only visible in a non-empty and invalid state, to replace the <code>MsgBox</code> message. Something like this:

<img src="https://i.stack.imgur.com/NMI5j.png" alt="better UX">

And now the review.

SUBMITTED

for title

PRE

MID

title

POST

SUBMITTED

get(i));
               }
           }
      } catch (Exception e) {
           throw e;
      }

      return listOfSplitMaps

PRE

That gets rid of the typo <code>TreepMap</code>.  

It saves specifying the types twice.  You don't need to do that unless you are building against an old version of Java.  

Specifying the interface rather than the implementation makes it easier to change implementations in the future.  You could also use <code>NavigableMap</code>, but it's not necessary for these operations.  

I prefer descriptive names like <code>splittable</code> and <code>original</code> to type names.  Of course, your coding standards could be different.  

MID

      } catch (Exception e) {
           throw e;
      }


POST

If you're just going to throw the same exception, there's no reason to <code>catch</code> it.  If you want to catch it, then handle it.  If you want it to percolate up to the caller, then just let it go without catching it.  As is, the <code>try</code>/<code>catch</code> doesn't do anything.  You could simplify the code by taking it out.  

I'm not convinced that this does enough to be worthwhile.  It's probably going to be less efficient than the more manual solution.  And it's not less code.  Consider 

SUBMITTED

gt;= myArray.length) ? numToInsert : myArray[index

PRE

The increment of <em>index</em> could be moved up to the array assignment:

MID

myArray[index++] = numToInsert;


Alternatively, the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Increment_()" rel="nofollow noreferrer">prefix</a> increment operator could be used on the recursive call:

doInsertion(++index,temp);    


POST

SUBMITTED

public class RegularExpressionSolution5 {
    static private boolean charMatch(char c, char p){
        return c == p || p == '.';
    }

    static private boolean nextStar(String p, int pIdx){
        if(pIdx + 1 &gt;= p.length()){
            return false;
        }
        return p.charAt(pIdx+1) == '*';
    }


    // matchMatrix[x][y] --&gt; if s.substr(x, s.length) matches p.substr(y, p.length)
    // note that p.substr(y, p.length) may not be a valid regular expression (starts with '*'),
    // in which case the matrix is filled with false
    static public void fillMatchMatrix(String s, String p, boolean[][] matchMatrix){
        for(int sIdx = s.length(); sIdx &gt;= 0; sIdx--){
            for(int pIdx = p.length(); pIdx &gt;= 0; pIdx--){
                //an empty pattern only matches empty string
                if(pIdx == p.length()){
                    matchMatrix[sIdx][pIdx] = (sIdx == s.length());
                    continue;
                }

                //pattern starts with 'x*', check if we can simply skip it and still match
                if(nextStar(p, pIdx) &amp;&amp; matchMatrix[sIdx][pIdx+2] == true){
                    matchMatrix[sIdx][pIdx] = true;
                    continue;
                }

                //empty string, but cannot match the pattern by skipping the 'x*' pattern, so match fails
                if(sIdx == s.length()) {
                    matchMatrix[sIdx][pIdx] = false;
                    continue;
                }

                //match first character and see if next matches
                if(nextStar(p, pIdx)){
                    matchMatrix[sIdx][pIdx] = charMatch(s.charAt(sIdx), p.charAt(pIdx)) &amp;&amp; matchMatrix[sIdx+1][pIdx];
                }else{
                    matchMatrix[sIdx][pIdx] = charMatch(s.charAt(sIdx), p.charAt(pIdx)) &amp;&amp; matchMatrix[sIdx+1][pIdx+1];
                }
            }
        }
    }

    static public boolean isMatch(String s, String p) {
        boolean[][] matchMatrix = new boolean[s.length()+1][p.length()+1];
        fillMatchMatrix(s, p, matchMatrix);
        return matchMatrix

PRE

Similar to the above, I renamed some variables. Notice that each of the previous two code snippets does one thing: the first loop fills the whole table, row by row. The function it calls fills a single row, column by column. The function it calls fills a single cell, checking each possible condition to decide how to fill the cell.

MID

private void fillCell(sIdx, pIdx) {
    //an empty pattern only matches empty string
    if(pIdx == p.length()){
        matchMatrix[sIdx][pIdx] = (sIdx == s.length());
        continue;
    }

    //pattern starts with 'x*', check if we can simply skip it and still match
    if(nextStar(p, pIdx) &amp;&amp; matchMatrix[sIdx][pIdx+2] == true){ // NOTE: == true is always redundant. Can you see why?
        matchMatrix[sIdx][pIdx] = true;
        continue;
    }

    //empty string, but cannot match the pattern by skipping the 'x*' pattern, so match fails
    if(sIdx == s.length()) {
        matchMatrix[sIdx][pIdx] = false;
        continue;
    }

    //match first character and see if next matches
    if(nextStar(p, pIdx)){
        matchMatrix[sIdx][pIdx] = charMatch(s.charAt(sIdx), p.charAt(pIdx)) &amp;&amp; matchMatrix[sIdx+1][pIdx];
    }else{
        matchMatrix[sIdx][pIdx] = charMatch(s.charAt(sIdx), p.charAt(pIdx)) &amp;&amp; matchMatrix[sIdx+1][pIdx+1];
    }
}


POST

Hope this is clear, and gives you some intuition. "Each function should do one thing" is a good rule of thumb, even for convoluted code like in DP. Please note: I did not run the above code, so it's possible (even probable, perhaps), that I made an error in refactoring. If you're gonna use it for something, test it!

SUBMITTED

Base * a );

    void render( void );

    void toString( void );

};


#endif

PRE

Then we have <code>std::list&lt;&gt;</code>.

MID

void render( void );
void toString( void );


In C++ an empty parameter list and a <code>void</code> parameter list is the same thing there is no difference. It is more idiomatic to specify this as:

void render();
void toString();


POST

SUBMITTED

id     | domainIP

PRE

MID

id

POST

SUBMITTED

manager.isValidMove

PRE

MID

isValidMove

POST

SUBMITTED

gateway_ip, gateway_mac, target_ip, target_mac)
    print("[*] Attack finished")


def main():
    try:
        interface = sys.argv[0]
        target_ip = sys.argv[1]
        gateway_ip = sys.argv[2]
    except:
        print ("""
Arp-poisening tool by @Ludisposed
Works on both Python2 and Python3
This tool is made for Unix(Kali) OS

Usage:
arper.py interface target_ip gateway_ip

Example:
python arper.py wlan0 192.168.1.70 192.168.1.1
""").strip()
        sys.exit(1)

    packet_count = 1000

    # Sets the ipv4 to enable port_forwarding
    os.system("echo 1 &gt; /proc/sys/net/ipv4/ip_forward")
    conf.verb = 0

    print("[*] setting up %s" % interface)

    gateway_mac = get_mac(gateway_ip)
    if gateway_mac is None:
        print ("[!] Failed to get gateway")
        sys.exit(1)
    print("[*] Gateway %s is at %s" % (gateway_ip, gateway_mac))

    target_mac = get_mac(target_ip)
    if target_mac is None:
        print("[!] Failed

PRE

MID

"""
Arp-poisening tool by @Ludisposed
Works on both Python2 and Python3
This tool is made for Unix(Kali) OS

Usage:
arper.py interface target_ip gateway_ip

Example:
python arper.py wlan0 192.168.1.70 192.168.1.1
"""


from scapy.all import *
import os

…

def main():
    try:
        interface = sys.argv[0]
        target_ip = sys.argv[1]
        gateway_ip = sys.argv[2]
    except:
        print(__doc__).strip()
        sys.exit(1)
    …


You could also improve your arguments parsing using existing tools: <a href="https://docs.python.org/3/library/argparse.html" rel="nofollow noreferrer"><code>argparse</code></a> in the standard library or <a href="http://click.pocoo.org/5/" rel="nofollow noreferrer"><code>click</code></a> or <a href="https://github.com/docopt/docopt" rel="nofollow noreferrer"><code>docopt</code></a> to name a few. Using argparse, your code could become:

"""
Arp-poisening tool by @Ludisposed
Works on both Python2 and Python3
This tool is made for Unix(Kali) OS
"""


import os
import sys
import signal
import argparse
import ipaddress
import threading

from scapy.all import *

…


def main(interface, target_ip, gateway_ip):
    packet_count = 1000

    # Sets the ipv4 to enable port_forwarding
    os.system("echo 1 &gt; /proc/sys/net/ipv4/ip_forward")
    conf.verb = 0
    …


def parse_command_line():
    parser = argparse.ArgumentParser(
            description=__doc__,
            epilog='Example: python arper.py wlan0 192.168.1.70 192.168.1.1')
    parser.add_argument('interface', help='&lt;some helpful description&gt;')
    parser.add_argument('target_ip', type=ipaddress.ip_address, help='…')
    parser.add_argument('gateway_ip', type=ipaddress.ip_address, help='…')
    return parser.parse_args()


if __name__ == '__main__':
    args = parse_command_line()
    main(args.interface, args.target_ip, args.gateway_ip)


POST

However, usage of the <a href="https://docs.python.org/3.6/library/ipaddress.html" rel="nofollow noreferrer"><code>ipaddress</code></a> module makes it require Python 3.3 at least. You could stick with strings but would get less checks done on the input.

SUBMITTED

GroupBy(x =&gt; new { x.DataTime.Date, x.RateId })
                                .OrderBy(x =&gt; x.Key.RateId).Select(cl =&gt; new StackChartData(
                                                              cl.Key.RateId,
                                                              cl.Key.Date.Day.ToString(CultureInfo.CurrentCulture),
                                                              cl.Sum(c =&gt; Convert.ToDecimal(c.YData)),
                                                              chartSetting.GetColorCode(cl.Key.RateId))).ToList();
}
}

 public class YearlyStack : IStackChartData
 {
     public IReadOnlyCollection&lt;StackChartData&gt; GetDetails(StackChartSetting chartSetting)
{
    return chartSetting.StackChartDataPoints.GroupBy(x =&gt; new { x.DataTime.Month, x.RateId })
                                    .OrderBy(x =&gt; x.Key.RateId).Select(cl =&gt; new StackChartData(
                                                                              cl.Key.RateId,
                                                                              cl.Key.Month.ToString(CultureInfo.CurrentCulture),
                                                                              cl.Sum(c =&gt; Convert.ToDecimal(c.YData)),
                                                                              chartSetting.GetColorCode(cl.Key.RateId))).ToList

PRE

You can do this with generics and an abstract class which implements your details.  To make it generic you need to get rid of the anonymous class and use something like a Tuple.  This code wasn't tested but should give you an idea.

MID

public abstract class BaseStack : IStackChartData
{

    public abstract IReadOnlyCollection&lt;StackChartData&gt; GetDetails(StackChartSetting chartSetting);

    protected IReadOnlyCollection&lt;StackChartData&gt; InternalGetDetails&lt;TGroup&gt;(StackChartSetting chartSetting,
        Func&lt;DateTime, TGroup&gt; groupBy, Func&lt;TGroup, string&gt; keyFunc)
    {
        return chartSetting.StackChartDataPoints
            .GroupBy(g =&gt; Tuple.Create(groupBy(g.DataTime), g.RateId))
            .OrderBy(x =&gt; x.Key.Item2)
            .Select(x =&gt; new StackChartData(x.Key.Item2,
                keyFunc(x.Key.Item1),
                x.Sum(c =&gt; Convert.ToDecimal(c.YData)),
                chartSetting.GetColorCode(x.Key.Item2)))
            .ToList().AsReadOnly();
    }

}


You will need to pass in a func of how you want to group by your DateTime and then another func of how you want the string version of that group.   Since the Date one also needed a different way to convert it to a string.   With this you can now base your other class on this base one

public class DailyStack : BaseStack
{
    public override IReadOnlyCollection&lt;StackChartData&gt; GetDetails(StackChartSetting chartSetting)
    {
        return InternalGetDetails(chartSetting, dt =&gt; dt.Hour, h =&gt; h.ToString(CultureInfo.CurrentCulture));
    }
}

public class MonthlyStack : BaseStack
{
    public override IReadOnlyCollection&lt;StackChartData&gt; GetDetails(StackChartSetting chartSetting)
    {
        return InternalGetDetails(chartSetting, dt =&gt; dt.Date, d =&gt; d.Day.ToString(CultureInfo.CurrentCulture));
    }
}

public class YearlyStack : BaseStack
{
    public override IReadOnlyCollection&lt;StackChartData&gt; GetDetails(StackChartSetting chartSetting)
    {
        return InternalGetDetails(chartSetting, dt =&gt; dt.Month, m =&gt; m.ToString(CultureInfo.CurrentCulture));
    }
}


POST

Using a Tuple does make the code less readable so you will need to see if that is a deal breaker for you or not.  Also to me your class names seem a bit off to me.  If I was joining your project and saw a class called dailystack I wouldn't expect it group by hours and so on.  

SUBMITTED

pointer data

PRE

MID

data()

POST

SUBMITTED

package quarantine;

import java.util.ArrayList;
import java.util.LinkedHashMap;

public class TreatmentAspirin implements ITreatment{


    @Override
    public void treat(LinkedHashMap&lt;PatientType, Integer&gt; patientInfoMap, ArrayList&lt;Medicines&gt; appliedTreatementList) {

        if(appliedTreatementList.contains(Medicines.ASPIRIN)){
            LinkedHashMap&lt;PatientType, Integer&gt; map = patientInfoMap;

            if(appliedTreatementList.contains(Medicines.PARACETOL)){
                Quarantine.isInsulineInjected = true; //Because They are Dead
                map.put(PatientType.DEAD, map.get(PatientType.DEAD) + map.get(PatientType.FEVER) + map.get(PatientType.HEALTHY) + map.get(PatientType.DIABATIC) + map.get(PatientType.TUBERCLOSIS));
                map.put(PatientType.HEALTHY, 0);
                map.put(PatientType.DIABATIC, 0);
                map.put(PatientType.TUBERCLOSIS, 0);
            }else{
                Quarantine.isInsulineInjected = false;
                map.put(PatientType.HEALTHY, map.get(PatientType.HEALTHY) + map.get(PatientType.FEVER));
                map.put(PatientType.FEVER

PRE

"If the treatments include aspirin and paracetol, then insuline was injected, because they are dead." I feel like I'm missing something crucial to understand this.

MID

@Override
public void treat(LinkedHashMap&lt;PatientType, Integer&gt; patientInfoMap, ArrayList&lt;Medicines&gt; appliedTreatementList) {

    if(appliedTreatementList.contains(Medicines.ASPIRIN)){
        LinkedHashMap&lt;PatientType, Integer&gt; map = patientInfoMap;

        if(appliedTreatementList.contains(Medicines.PARACETOL)){
            Quarantine.isInsulineInjected = true; //Because They are Dead
            map.put(PatientType.DEAD, map.get(PatientType.DEAD) + map.get(PatientType.FEVER) + map.get(PatientType.HEALTHY) + map.get(PatientType.DIABATIC) + map.get(PatientType.TUBERCLOSIS));
            map.put(PatientType.HEALTHY, 0);
            map.put(PatientType.DIABATIC, 0);
            map.put(PatientType.TUBERCLOSIS, 0);
        }else{
            Quarantine.isInsulineInjected = false;
            map.put(PatientType.HEALTHY, map.get(PatientType.HEALTHY) + map.get(PatientType.FEVER));
            map.put(PatientType.FEVER, 0);
        }
    }
}


POST

SUBMITTED

token read_operator();

        bool is_operator(char c) const noexcept;
    };

    using tokenizer_iterator = tokenizer::tokenizer_iterator;
}

#endif

PRE

Be clear about what the application of <code>noexcept</code> does in C++.  In particular, let's look at this:

MID

bool tokenizer::is_operator(char c) const noexcept
{
    return c == '+' || c == '-' || c == '=';
}


POST

It's pretty trivial for the compiler to figure out that this function does not throw.  It's not at all clear to me what advantage you expect to see by marking this particular function as <code>noexcept</code>.  

For a longer discussion of this see <a href="https://akrzemi1.wordpress.com/2011/06/10/using-noexcept/" rel="nofollow noreferrer">Andrzej Krzemieński's helpful blog post</a> on that topic.  It's long and technical but well worth a read.

The <code>tokenizer</code> class currently includes this member function:

SUBMITTED

return null

PRE

MID

null

POST

SUBMITTED

int x

PRE

MID

x

POST

SUBMITTED

if I am overriding these correctly (hashCode(),equals())

@Override
public int hashCode() {
    return xPos * yPos * symbol.hashCode() * value.hashCode() * 29 + 6;
}

@Override

PRE

No need to waste time if we're talking about the same object, not just two potentially equivalent objects.  

Now we won't have any exceptions because someone tried to check equality of a <code>Board</code> with a <code>Cell</code>.  

Example source:  <a href="https://stackoverflow.com/q/8180430/6660678">How to override equals method in java</a>

Note that that source offers some more complex examples.  For example, it handles the case where you might have some other class extend <code>Board</code>.  I didn't do that here, as your current example doesn't need it.  

MID

public int hashCode() {
    return xPos * yPos * symbol.hashCode() * value.hashCode() * 29 + 6;
}


So if you're using Java 7 or newer, you can say 

public int hashCode() {
    return Objects.hash(yPos, xPos, isMine, value);
}


Now it will be consistent with your <code>equals</code> implementation (which has the same issues as the one for <code>Board</code>, which I won't repeat).  

If compiling against an older Java, you could do a custom implementation like 

public int hashCode() {
    int result = 6;

    result = 29 * result + yPos;
    result = 29 * result + xPos;
    result = 29 * result + (isMine ? 0 : 1);
    result = 29 * result + ((value == null) ? 0 : value.hashCode());

    return result;
}


POST

Again, note that this uses the same fields as the <code>equals</code> method.  

SUBMITTED

for (int

PRE

MID

for

POST

SUBMITTED

def shortestPath

PRE

MID

shortestPath()

POST

use multi-line strings for your SQL queries - <code>core</code> can be defined as:

SUBMITTED

Dictionary&lt

PRE

MID

&lt;

POST

SUBMITTED

import wx 
import os
import shutil
import time

class Window(wx.Frame):
    def __init__(self, parent, id): 
        self.Desktop = "C:/Users/Name/Desktop/" and "C:/Users/Public/Desktop/"
        self.Dfiles = "C:/ Desktop_Files/"                
        no_caption = wx.DEFAULT_FRAME_STYLE | wx.STAY_ON_TOP 
        wx.Frame.__init__(self, parent, id, title="no_caption", size=(300,97), style=no_caption)            
        self.panel=wx.Panel(self)
        self.Butt_Clear = wx.Button(self.panel, -1, label="Clear Desktop", pos=(0,0), size=(100,70))
        self.Butt_Clear.Bind(wx.EVT_BUTTON, self.ClearDesk, self.Butt_Clear)
        self.Butt_Undo = wx.Button(self.panel, -1, label="Undo Clear", pos=(185,0), size=(100,70))
        self.Butt_Undo.Bind(wx.EVT_BUTTON, self.UndoClear, self.Butt_Undo)                      
    def ClearDesk(self, e):        
        MainDesktop = os.listdir(self.Desktop)       
        MainDesktop.remove('desktop.ini')

        for Desktop_Path_Names in MainDesktop:  
            Desktop_Path = os.path.join(self.Desktop, Desktop_Path_Names)           
            shutil

PRE

Please do not create widgets within your class initializer. Delegate that task, again, for a separate function:

MID

def create_widgets(self):
    wx.Frame.__init__(self, parent, id, title="no_caption", size=(300,97), style=no_caption)            
    self.panel=wx.Panel(self)
    self.Butt_Clear = wx.Button(self.panel, -1, label="Clear Desktop", pos=(0,0), size=(100,70))
    self.Butt_Clear.Bind(wx.EVT_BUTTON, self.ClearDesk, self.Butt_Clear)
    self.Butt_Undo = wx.Button(self.panel, -1, label="Undo Clear", pos=(185,0), size=(100,70))
    self.Butt_Undo.Bind(wx.EVT_BUTTON, self.UndoClear, self.Butt_Undo)      


POST

In Python, we don't like camelCase and CamelCase naming conventions that you probably used in Java, JavaScript or elsewhere. Please follow the <a href="https://www.python.org/dev/peps/pep-0008/#naming-conventions" rel="noreferrer">naming conventions</a> as described in PEP8.

SUBMITTED

function(){
    CommsMatrix.genCMDStatuses();
    CommsMatrix.genProtocolList();
    var loadData = CommsMatrix.getLoadData();
    var

PRE

Native JS also has <code>Promise.all</code> which is also inspired by jQuery deferreds. It's like <code>$.when</code> except it accepts an array of promises instead of an args list of deferred objects. The resolved value of the promise returned by <code>Promise.all</code> is also an array of values resolved from the promises, in the order they were provided in the input array.

MID

$(function(){
CommsMatrix.genCMDStatuses();
CommsMatrix.genProtocolList();


POST

Instead of storing their deferred objects in an <code>loadData</code>, why not return their deferred objects, then feed them to <code>$.when</code>? Is there really a need to put it inside <code>loadData</code>? In fact, <code>statuses</code> and <code>protocols</code> are also the same thing. 

Unless it's a cache of some sort, this intermediary array isn't necessary. Also, I'd leverage HTTP cache if you <em>are</em> doing caching. It's transparent to the code, so you don't do anything special (except for maybe ensuring headers are correct for caching and your request isn't busting the cache).

SUBMITTED

if (fin) {
            fin.close

PRE

You're actually one foot off the finish.

You could store a pointer to the <code>istream</code> (note that <code>std::ifstream</code> is its child class, so <code>new std::ifstream(file)</code> will automatically be converted to <code>istream*</code>), then store a bool flag if it is owning or not.

There is yet greater issue here, and it is ownership semantics. When ownership semantics are weird design starts becoming fragile. I'd recommend letting the caller to take ownership of the stream, so that <code>Parser</code> wouldn't mess with it and keep rule of zero. Callers will have much more power that way. Otherwise <code>Parser</code> would also require implementing either of rule of 0/3/5. 

MID

fin.close();


POST

is redundant in the destructor. Invoking it explicitly opens possibilities for exceptions, thus making your <code>fin</code> leak. Just <code>delete</code> it, destructor will take care of closing.

Code never checks if the file is opened. Code could start on non-opened stream, which is, I believe undefined behavior.

SUBMITTED

node* right_operand_):
            tk(tk_),
            left_operand(left_operand_),
            right_operand(right_operand_)
    {}

    syntax_tree::syntax_tree(syntax_tree&amp;&amp; other) noexcept:
            root(other.root)
    {
        other.root = nullptr;
        std::swap(operator_precedence, other.operator_precedence

PRE

Looks good, good job! Here are a few points:

My opinion is you could be a bit more defensive, like using <code>final</code> and <code>noexcept</code> everywhere.

Commenting code like this <code>//prev_nodes.pop();</code> is not that good. Maybe you can add a comment explaining why you didn't remove the statement or just remove it completely.

It makes little sense to be why you would delete the move assignment operator but keep the move constructor. It's also a bit counter intuitive. Consider adding it?

<code>operator_precedence</code> is the same in every instance, why not make it <code>static</code> and <code>const</code>?

You can simplify your move constructor:

MID

syntax_tree::syntax_tree(syntax_tree&amp;&amp; other) noexcept:
        root(std::exchange(other.root, nullptr))
{}


POST

Even if you didn't include it, writing the name again is not very pretty <code>token::token_type::NAME</code> in my opinion. Why not use <code>token::type::NAME</code>?

Even though you manually allocate memory using <code>new</code> without any problems, you should still consider using <code>std::unique_ptr</code> to avoid any possible problem in the future (just to be on the safe side) and remove <code>recursive_destruct</code>.

You don't actually need the constructor of <code>node</code> (you do if you use <code>std::make_unique</code>) if you always use aggregate initialization.

Just because you need to modify <code>tokens</code> (in <code>parse</code>) and want to avoid a copy doesn't mean you need to use a lvalue reference, as it is pretty limiting (see constructor of <code>syntax_tree</code>).

Instead, pass by value. If you don't want to pay the cost of copying an lvalue, you can introduce some additional overloads:

SUBMITTED

import { Injectable } from '@angular/core';

import { Subject } from 'rxjs/subject';
import { Observable } from 'rxjs/observable';

declare let $: any;

@Injectable()
export class WindowService {

  private _subscriptions: Array&lt;Subscription&gt; = [];

  constructor() {
    $(window).bind('click', this._onWindowClick.bind(this));
  }

  ngOnDestroy() {
    $(window).unbind('click');
  }

  // Handle any click event on the document
  private _onWindowClick(event): void {
    let $target = $(event.target);
    // Check every subscription you to see if the $target element
    // that was clicked is contained inside the selector they subscribed with
    this._subscriptions.forEach((sub: Subscription) =&gt; {
      // IF you do find that selector continue - the click was inside this subscribers
      // element ELSE fire off the subject to let the subscriber know a click away from them occurred
      if ($target.closest(sub.selector).length == 0)
        sub.subject.next(event);
    });
  }

  // Sign up for clickAway event - called by components
  public clickAway(selector: string): Observable&lt;Event&gt; {
    let subject = new Subject();
    this._subscriptions.push(new Subscription(selector, subject));
    return subject.asObservable();
  }

}

class Subscription {
  constructor(
    public selector: string,
    public subject: Subject&lt;Event&gt

PRE

You can spot the previous points with the <code>ng lint</code> command.

Lifecycle hooks only work in components.

You can drop the JS convention of prefixing private members with <code>_</code>.

Members of the <code>Subscription</code> class can be marked as <code>readonly</code>. Moreover, Angular is a rxjs-everywhere-framework so <code>Subscription</code> is a confusing name since it's a common type of <code>rxjs</code>.

<code>JQuery</code> is a dependency of your service, maybe it can be treated like every other dependencies, with injection. You can also type the jQuery objects if you install the <code>@types/jquery</code> package.

MID

import { Inject, Injectable, InjectionToken, ValueProvider } from '@angular/core';
import { Subject } from 'rxjs/Subject';
import { Observable } from 'rxjs/Observable';

import * as $ from 'jquery';

export const DOM_HELPER: InjectionToken&lt;JQueryStatic&gt; = new InjectionToken&lt;JQueryStatic&gt;('DomHelper');
// use the provider in your app.module
export const domHelperProvider: ValueProvider = {provide: DOM_HELPER, useValue: $};

class Subscription {
  constructor(public readonly selector: JQuery.Selector,
              public readonly subject: Subject&lt;JQuery.Event&gt;) {
  }
}

@Injectable()
export class WindowService {
  private subscriptions: Array&lt;Subscription&gt; = [];

  constructor(@Inject(DOM_HELPER) private $: JQueryStatic) {
    this.$(window).click((event: JQuery.Event): void =&gt; this.onWindowClick(event));
  }

  public clickAway(selector: JQuery.Selector): Observable&lt;JQuery.Event&gt; {
    const subject = new Subject();
    this.subscriptions.push(new Subscription(selector, subject));
    return subject.asObservable();
  }

  private onWindowClick(event: JQuery.Event): void {
    const $target = this.$(event.target);
    this.subscriptions.forEach((sub: Subscription): void =&gt; {
      if ($target.closest(sub.selector).length === 0) {
        sub.subject.next(event);
      }
    });
  }
}


Your code works but it's buggy. The <code>subscriptions</code> array will never stop growing and may cause performance issue. You can add an "unsubscribing" method in your service, components will call it in their <code>ngOnDestroy</code> method; but I think it's a bad design, consumers of your service will forget to call the method for sure because they will assume that they only have to unsubscribe from the observable you provide.

You have to get rid of this array. I suggest creating an Observable directly from the click events and then filtering it in <code>clickAway</code>:

import { Inject, Injectable, InjectionToken, ValueProvider } from '@angular/core';
import { Observable } from 'rxjs/Observable';
import 'rxjs/add/observable/fromEvent';
import 'rxjs/add/operator/filter';

import * as $ from 'jquery';

export const DOM_HELPER: InjectionToken&lt;JQueryStatic&gt; = new InjectionToken&lt;JQueryStatic&gt;('DomHelper');
export const domHelperProvider: ValueProvider = {provide: DOM_HELPER, useValue: $};

@Injectable()
export class WindowService {
  private observable: Observable&lt;Event&gt;;

  constructor(@Inject(DOM_HELPER) private $: JQueryStatic) {
    this.observable = Observable.fromEvent(window, 'click');
  }

  public clickAway(selector: JQuery.Selector): Observable&lt;Event&gt; {
    return this.observable
      .filter((event: Event): boolean =&gt; this.$(event.target).closest(selector).length === 0);
  }
}


Finally you don't need jQuery to achieve the functionality and you can use Angular and native types in your API:

import { ElementRef, Injectable } from '@angular/core';
import { Observable } from 'rxjs/Observable';
import 'rxjs/add/observable/fromEvent';
import 'rxjs/add/operator/filter';

@Injectable()
export class WindowService {
  private observable: Observable&lt;Event&gt;;

  constructor() {
    this.observable = Observable.fromEvent(window, 'click');
  }

  public clickAway(el: ElementRef): Observable&lt;Event&gt; {
    return this.observable.filter((event: Event): boolean =&gt; !el.nativeElement.contains(event.target));
  }
}


Example of a component using the service:

import { Component, ElementRef, OnDestroy, OnInit, ViewChild } from '@angular/core';
import { WindowService } from '../window.service';
import { Subscription } from 'rxjs/Subscription';

@Component({
  selector: 'app-closable',
  templateUrl: './closable.component.html',
  styleUrls: ['./closable.component.css']
})
export class ClosableComponent implements OnInit, OnDestroy {

  @ViewChild('outside')
  private outside: ElementRef;

  private subscription: Subscription;

  constructor(private window: WindowService) {
  }

  ngOnInit() {
    this.subscription = this.window.clickAway(this.outside).subscribe(() =&gt; console.log('clicked away!'));
  }

  ngOnDestroy() {
    this.subscription.unsubscribe();
  }
}


POST

and its template:

SUBMITTED

int n){
      numDays=n;
  }
      void setNumClient(int n){
          numClient=n;
      }    



}

class Ship implements Additional{

private int enrollment,year;
static double slovak;//in meters

Ship(int enrollment,int year,double slovak)
{
    this.enrollment=enrollment;
    this.year=year;
    this.slovak=slovak;//ship length

}

public String ShowData(){
  //Rental t=new Rental(); t.getPosition() implies null as output..
  return enrollment+" "+year+" "+slovak+" "+Rental.getName()+" 
"+Rental.getNumClient()+" "+Rental.getPosition()+" 
"+Rental.getNumDays();
}

public  double RentCost(){

  return Rental.getNumDays();
}

}

class Sailing extends Ship {
private int numMast;

Sailing(int enrollment,int year,double slovak,int numMast){
    super(enrollment,year,slovak);
            this.numMast=numMast;
}

public String ShowData(){
   return super

PRE

The Ship class should be abstract because you don't know what would be the daily cost (and the RentCost method should be kept abstract, BTW, method names usually start with a lowercase letter).

The field slovak (???) should be protected instead of private (not static!!!) so that it can be used in subclasses. You could also have added a getter.

The ship cannot access the fields of a Rental (which Rental BTW).

MID

abstract class Ship implements Additional {
    private int enrollment, year;
    protected double slovak;//in meters

    Ship(int enrollment, int year, double slovak) {
        this.enrollment = enrollment;
        this.year = year;
        this.slovak = slovak;//ship length

    }

    @Override
    public String showData() {
        //Rental t=new Rental(); t.getPosition() implies null as output..
        return enrollment + " " + year + " " + slovak;
    }
}


BTW, I still don't get the Additional interface.

For the Sailing boat, you just need to add the number of masts, and implement the abstract methods:

class Sailing extends Ship {
    private int numMast;

    Sailing(int enrollment, int year, double slovak, int numMast) {
        super(enrollment, year, slovak);
        this.numMast = numMast;
    }

    @Override
    public String showData() {
        return super.ShowData() + " " + numMast;
    }

    @Override
    public double rentCost() {
        return 15 * numMast;
    }
}


Now, as you have noted, the two other types of boat need an engine power. You have two ways to avoid declaring the field in each class: declare it in Ship, or introduce a new abstract class, say MotorShip:

abstract class MotorShip extends Ship {
    protected double enginePower;

    MotorShip (int enrollment, int year, double slovak, double enginePower) {
        super(enrollment, year, slovak);
        this.enginePower= enginePower;
    }

    @Override
    public String showData() {
        return super.ShowData() + " " + enginePower;
    }
}


Note that the field enginePower is protected, not private, because you will need it in the subclasses (you could also have added a getter).

Here are your two last concrete classes:

class SportBoat extends MotorShip {

    SportBoat(int enrollment, int year, double slovak, double enginePower) {
        super(enrollment, year, slovak, enginePower);
    }

    @Override
    public double rentCost() {
        return 35 * slovak;
    }
}


class LuxuryYacht extends MotorShip {

    private int numCabins;

    LuxuryYacht(int enrollment, int year, double slovak, double enginePower, int numCabins) {
        super(enrollment, year, slovak, enginePower);
        this.numCabins = numCabins;
    }

    @Override
    public String showData() {
        return super.ShowData() + " " + numCabins;
    }

    @Override
    public double rentCost() {
        return numCabins * 17;
    }
}


POST

SUBMITTED

xls')
            r_value

PRE

MID

r_value

POST

SUBMITTED

auto_now=True)

    @property
    def imageName(self

PRE

The models look about right.

MID

def imageName(self):


POST

Well, ok, <a href="https://www.python.org/dev/peps/pep-0008/" rel="nofollow noreferrer">PEP-8</a> asks that you spell this <code>image_name</code>, but,
whatever, I'm sure you had other constraints you were working within.

In <code>STORE_CATEGORIES</code> I don't understand why <code>Foods</code> is special.
It otherwise has <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" rel="nofollow noreferrer">DRY</a> issues that could be addressed
by applying <code>.upper()</code> or <code>.title()</code> to a single copy of the list.

Looks good to me. Ship it!

SUBMITTED

public static setTimestampRadioButton(radioControl: RadioButton, dataModelObject: IDataModel): void {
    let timestampProperty;
    if (radioControl.value() === 1) {
      timestampProperty = { format: "foo" };
    } else if(radioControl.value() === 2) {
      timestampProperty = { format: "bar" };
    }

    dataModelObject.timestamp = timestampProperty

PRE

I would instead recommend creating a method to get the expected format. 

MID

public static getTimestampFormat(radioControl: RadioButton): IFormat {
    if (radioControl.value() === 1) {
      return { format: "foo" };
    } else if(radioControl.value() === 2) {
      return { format: "bar" };
    }
    return { format: 
}


This simplifies your <code>generateDataModel</code> method even more. 

public generateDataModel(): IDataModel {
  return {
    name: this._name.value(),
    type: this._type.value(),
    timestamp: Helpers.getTimestampFormat(this._radioControl)
  };
}


POST

Instead of a static helper method, you might also consider adding the method as an instance method of the <code>RadioButton</code> class, or creating a child of the <code>RadioButton</code> class with a <code>TimestampRadioButton</code> class. 

A couple other general things: 

SUBMITTED

int right = tt[1];

        int occ = tt[1] - ceil((double(tt[1])-double(tt[0]))/2);

        vector&lt;int&gt; l_stall

PRE

Seems a rather long-winded way to initialise a queue with a single item.

MID

        int occ = tt[1] - ceil((double(tt[1])-double(tt[0]))/2);


Why use <code>tt[1]</code> and <code>tt[0]</code> after pulling them out into variables with intelligible names? And why convert to doubles? Just rewrite as

    int occ = left + (right - left) / 2;


POST

Finally, note that the test data's explanation included an observation:

In Case #4, every stall is occupied at the end, no matter what the stall choices are.

So given input

SUBMITTED

parseInt(
          this.state.questionsAnswer[this.state.currentIndex]['answer']
        );
    
   if ( answer === correctAnswer ) {
       this.setState( {correct: this.state.correct + 1} );
   } else {
       this.setState( {incorrect: this.state.incorrect + 1} );
   } 
    
   this.setState( {currentIndex: this.state.currentIndex + 1} );
  }
  
  render() {
    var options = [];
    
    if (this.state.activeGame) {
      for (let i = 0; i &lt; this.state
                              .questionsAnswer[0]
                              .options
                              .length; i++) {
        options.push( &lt;Option optionValue={
                this
                  .state
                  .questionsAnswer[this.state.currentIndex]
                  .options[i] }
              triggerProcess = { this.processGuess } 
              activeGame = { this.state.activeGame } /&gt; );
      }
    }
    
    return (  &lt;div&gt;
                &lt;div className

PRE

The <code>GameBoard</code> constructor can call <code>this.resetGame()</code> to avoid duplicating the setup logic.

This:

MID

var options = [];

if (this.state.activeGame) {
  for (let i = 0; i &lt; this.state
                          .questionsAnswer[0]
                          .options
                          .length; i++) {
    options.push( &lt;Option optionValue={
            this
              .state
              .questionsAnswer[this.state.currentIndex]
              .options[i] }
          triggerProcess = { this.processGuess } 
          activeGame = { this.state.activeGame } /&gt; );
  }
}


can use <code>map</code>:

let options = [];

if (this.state.activeGame) {
    options = this.state.questionsAnswer[this.state.currentIndex].options.map(option =&gt; (
      &lt;Option optionValue={ option }
              triggerProcess={ this.processGuess }
              activeGame={ this.state.activeGame } /&gt;
    ))
}


POST

SUBMITTED

union entry_t

PRE

MID

entry_t

POST

SUBMITTED

settings)
    {
        assert(glfwInit());

        static

PRE

So instead of 

MID

assert(glfwInit());


You should write:

auto init_success = glfwInit()
assert(init_success);


POST

<code>if(id == 131169 || id == 131185 || id == 131218 || id == 131204)</code> This is pretty dodgy. At the very least add a comment listing what each of these are. 

I don't like your implicit cast operations from your wrapper types to the native GL handles. If you are going to use wrappers, commit. There will always be a few edge cases where some functionality needs the native handle, but that's what <code>friend</code> is for.

regarding <code>glDebugOutput()</code>. Libraries shouldn't just write to <code>cout</code>. You would be better served to build a string and invoke a callback that is application-defined.

I would make the calls to <code>glNamedBufferData()</code> in the VertexBuffer constructors.

regarding <code>Texture(const char*)</code>. You do not want your GL thread to be ever waiting on I/O. It's better to receive a buffer, and delegate the file loading to someone else.

Use the GL* types (instead of <code>unsigned</code>) They are there for a reason.

SUBMITTED

main() {
  std::random_device seed;
  Random rnd(seed());

  Model adv("Daniele", 30, 3, 7, 0);
  Model goblin("Goblin", 4, 2, 0, 0);
  Model crocodile("Crocodile", 9, 4, 7, 0);
  Model boss("BigBoss", 25, 8, 11, 15);

  int advType;
  int spaCounter = 5;
  std::cout &lt;&lt; "THE FIGHT BEAGIN!" &lt;&lt; '\n';
  while (!isDead(adv)) {
    do {
      std::cout &lt;&lt; '\n'
                &lt;&lt; "1 Normal Attack - 2 Special Attack(" &lt;&lt; spaCounter
                &lt;&lt; ") : ";
      std::cin &gt;&gt; advType;
    } while (advType &lt; 1 || advType &gt; 2);

    if

PRE

<strong>Item 5.</strong>
Declare variables in the smallest scope possible as close to the usage as possible
For example <code>advType</code> variable should be declared inside <code>while</code> loop

MID

while (!isDead(adv)) {
    int advType;
    do {
        std::cout &lt;&lt; '\n'
                  &lt;&lt; "1 Normal Attack - 2 Special Attack(" &lt;&lt; spaCounter
                  &lt;&lt; ") : ";
        std::cin &gt;&gt; advType;
    } while (advType &lt; 1 || advType &gt; 2);


POST

<strong>Item 6.</strong>
your fight function does 2 similar things enemy attack and player attack.
 So it looks like you have to write function <code>attacked</code> which will calculate the health of the object as a result of the attack from other object

<code>fight</code> function will look like (it should not be friend - since it will use only public members of the <code>Model</code>)

SUBMITTED

path_array[@]}"
do
    addToPath $element false NEW_PATH
done
export

PRE

You should double-quote variables that may contain spaces when used as command arguments. For example here:

MID

addToPath $element false NEW_PATH


POST

You will get strange results if <code>$element</code> contains spaces. Double-quote it, and also in the conditional inside the function:

SUBMITTED

storageArray.length) {
        this.expand();
    }

    var storageArrayIndex = this.keyHashCode(key) &amp; (this.storageArray.length - 1);
    var currentNode = this.storageArray[storageArrayIndex

PRE

This is worse than incorrect,
because it dangerously misleads into believing that <code>i</code> is only visible inside the loop, which is not the case.

If possible, it would be better to use <code>let</code> instead of <code>var</code> (requires adding <code>"use strict"</code>).
If that's not possible,
then move <code>var i</code> to the beginning of the function.

MID

var storageArrayIndex = this.keyHashCode(key) &amp; (this.storageArray.length - 1);


POST

This calculation of the storage index is a bit fragile,
because it relies on <code>this.storageArray.length</code> being a power of 2.
This crucial detail should be documented.

SUBMITTED

import csv
import scrapy

outfile = open("various_pro.csv", "w", newline='')
writer = csv.writer(outfile)

class ToscrapeSpider(scrapy.Spider):

    name = "toscrapesp"
    start_urls = ["http://books.toscrape.com/"]

    def parse(self, response):
        for link in response.css('.nav-list a::attr(href)').extract():
            yield scrapy.Request(url=response.urljoin(link), callback=self.collect_data)

    def collect_data(self, response):
        global writer                                  
        for item in response.css('.product_pod'):
            product = item.css('h3 a::text').extract_first()
            value = item.css('.price_color::text').extract_first()
            yield {'Name': product, 'Price': value}  
            writer.writerow([product,value

PRE

I don't think you should reinvent the wheel and provide your own CSV export. The following works for me as is (note the addition of <code>.strip()</code> calls - though I don't think they are necessary at all):

MID

import scrapy


class ToscrapeSpider(scrapy.Spider):
    name = "toscrapesp"
    start_urls = ["http://books.toscrape.com/"]

    def parse(self, response):
        for link in response.css('.nav-list a::attr(href)').extract():
            yield scrapy.Request(url=response.urljoin(link), callback=self.collect_data)

    def collect_data(self, response):
        for item in response.css('.product_pod'):
            product = item.css('h3 a::text').extract_first().strip()
            value = item.css('.price_color::text').extract_first().strip()
            yield {'Name': product, 'Price': value}  


POST

Running it with <code>scrapy runspider spider.py -o output.csv -t csv</code> produces a CSV file with no blank lines:

SUBMITTED

import random
print('let\'s play hangman')
#set words
first = ['t','e','s','t']
second = ['t', 'e', 's', 't', 'e', 'd']
third = ['t', 'e', 's', 't', 'i', 'n', 'g']
fourth = ['r', 'a', 'n', 'd', 'o', 'm']
fifth = ['g',  'e',  'n',  'e',  'r',  'a',  't',  'e']
#set list of possible answers
alphabet = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 
'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']
#set a couple of varibles
answer = []
end = 0
right = 0
wrong = 0
endCheck = 0
alreadyGuessed = 0
#randomly pick a word
random=random.randint(1, 5)
if random == 1: words = first
if random == 2: words = second
if random == 3: words = third
if random == 4: words = fourth
if random == 5: words = fifth
#set varible length to the number of letters in the word
length = len(words)
#figure out what number must be reached in order to declare winner
for loop in range(length):
    end = end + loop
#set answer to as many asterisks as there are letters in the word
for marker

PRE

Now for the code. I'm not going to do a complete review because ... it makes my eyes burn. Instead, I'm going to assume that:

So let's look at your coding <em>style</em>:

MID

import random
print('let\'s play hangman')
#set words
first = ['t','e','s','t']
second = ['t', 'e', 's', 't', 'e', 'd']
third = ['t', 'e', 's', 't', 'i', 'n', 'g']
fourth = ['r', 'a', 'n', 'd', 'o', 'm']
fifth = ['g',  'e',  'n',  'e',  'r',  'a',  't',  'e']
#set list of possible answers
alphabet = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 
'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']
#set a couple of varibles


POST

<strong>Use vertical space to separate unrelated things</strong>

You didn't separate things using vertical space. This is perhaps the greatest sin in programming. Always, <strong>always</strong> use vertical space (blank lines, paragraphs, etc.) to separate parts of your code. If you switch from doing one thing to another, insert a blank line. If you end a paragraph and start a new paragraph, insert a blank line. If you come to the end of a function or a loop, insert a blank line. 

Even if you are the most secretive hacker ever, and you never intend to share your code with a single other living human being, at some point you will have to go back and read stuff that you, yourself wrote six months earlier! Make it easy on yourself, or on whatever other humans have to read your code: try to make it easy to read! Use vertical space to separate unrelated things.

<strong>Keep related things together</strong>

Next, consider the line:

SUBMITTED

number;

            let

PRE

You create the const <code>baseOriginal</code> and assign it the value of <code>base</code> yet at no point do you modify <code>base</code> before you use <code>baseOriginal</code> making it redundant. This just adds complexity where it is not needed making code harder to read and modify.

MID

let

POST

SUBMITTED

Option

PRE

MID

Option

POST

SUBMITTED

bitten by a snake and is now on square", snake_squares[num])
        num = snake_squares[num]
    elif num in ladder_squares:
        print("Player climbed a ladder and is now on square", ladder_squares[num])
        num = ladder_squares[num]
    else:
        print("",end = "")
    return num

def Setup_Players():
    players=6
    while True:
        try:
            print("How many players are in the game?")
            players = int(input())
            if players &gt; 4 or players &lt; 2:
                print("Must be less than 5 and greater than 1")
            else:
                return players
        except:
            print("Must be a number")



def Player_Names(NumP):
    Names = []
    for i in range(1,NumP+1):
        Names.append(input("What is the name of Player"+str(i)+"?"))
    Names.append("")
    return Names


Num_Players=Setup_Players()
P_Names = Player_Names(Num_Players)
P1N = 0
P2N = 0
P3N = 0
P4N = 0
for i in P_Names:
    if P1N == 0:
        P1N = i
        if Num_Players == 1:
            P2N, P3N, P4N = "", "", ""
            break
    elif P2N == 0:
        P2N = i
        if Num_Players == 2:
            P3N, P4N = "", ""
            break
    elif P3N == 0:
        P3N = i
        if Num_Players == 3:
            P4N = ""
            break
    elif P4N == 0:
        P4N = i
    else:
        break

PRE

I kinda rewrote all you had for a more readable structure,

First of all, why 2 different functions for the setup of the game? In my opinion this would be better suited in 1 function:

MID

def setup_game():
    players=6
    while True:
        try:
            print("How many players are in the game?")
            players = int(input())
            if players &gt; 4 or players &lt; 2:
                print("Must be less than 5 and greater than 1")
            else:
                break
        except ValueError:
            print("Must be a number")

    names = {}
    for i in range(1,players+1):
        while True:
            name = input("What is the name of Player {}? ".format(i))
            if not name in names:
                names[name] = 0
                break
            else:
                print('Cannot have duplicate names')
    return names


POST

Here I return the players as a dictionary where the KEY is the players name and value the current_position; the only drawback is that there cannot be any duplicate names.

<strong>Now for the juicy part!</strong>

SUBMITTED

functions -
        - FuncSlot

PRE

MID

FuncSlot

POST

SUBMITTED

using reference = value_type&amp;;
    using pointer = value_type*;
    using pointerconst = value_type const

PRE

A naming thing. Iterators should not have a type <code>pointer</code>. Pointer may be a type of iterator but it is not an iterators type.

MID

using iterator       = value_type*;
using const_iterator = value_type const*;


POST

Given this I would expect the following iterators:

SUBMITTED

Created helper methods to merge 3 strings into 1 and reverse
* This is a helper to group 3 messages in a single string.
*
**/

struct MultipartSplitMerge {
   #define PADDING 8
   static std::string merge(std::string *s1, std::string *s2, std::string *s3) {
       std::string size_1 = std::to_string((*s1).size()); std::string size_2 = std::to_string((*s2).size()); 
       std::string padded_size_1 = std::string(PADDING - size_1.length(), '0') + size_1;
       std::string padded_size_2 = std::string(PADDING - size_2.length(), '0') + size_2;
       std::string ret_str(padded_size_1 + padded_size_2 + *s1 + *s2 + *s3);
       return ret_str; // Add the size of each piece
   }

   static void split(std::string *s, std::string *o1, std::string *o2, std::string *o3) {
       unsigned int size_1 = std::stoi((*s).substr (0, PADDING));
       unsigned int size_2 = std::stoi((*s).substr (PADDING, PADDING));
       *o1 = (*s).substr(2 * PADDING, size_1); 
       *o2 = (*s).substr(2 * PADDING + size_1, size_2); 
       *o3 = (*s).substr(2 * PADDING + size_1 + size_2

PRE

You never change <code>s1</code>, <code>s2</code> and <code>s3</code>, yet you didn't use <code>const</code>. We could have changed their values accidentally. A <code>const</code> will prevent this:

MID

inline std::string merge(const std::string&amp; s1, const std::string&amp; s2, const std::string&amp; s3) {
    const std::string size_1 = std::to_string(s1.size()); 
    const std::string size_2 = std::to_string(s2.size()); 
    const std::string padded_size_1 = std::string(PADDING - size_1.length(), '0') + size_1;
    const std::string padded_size_2 = std::string(PADDING - size_2.length(), '0') + size_2;
    const std::string ret_str(padded_size_1 + padded_size_2 + s1 + s2 + s3);
    return ret_str; // Add the size of each piece
}

inline void split(const std::string&amp; s, std::string &amp;o1, std::string &amp;o2, std::string &amp;o3) {
    const unsigned int size_1 = std::stoi(s.substr(0, PADDING));
    const unsigned int size_2 = std::stoi(s.substr(PADDING, PADDING));
    o1 = s.substr(2 * PADDING, size_1); 
    o2 = s.substr(2 * PADDING + size_1, size_2); 
    o3 = s.substr(2 * PADDING + size_1 + size_2);
}


Note that all this <code>inline</code> annotations are only necessary if your functions will be in a header.

You pad your string, but it's a) hard to get and b) repetitive. Write a function to get rid of the duplicate logic:

inline std::string pad(size_t size, char padding, const std::string&amp; original) {
    assert(size &gt;= original.size());
    return std::string(size - original.size(), padding) + original;
}

inline std::string pad_size(const std::string&amp; original) {
    return pad(PADDING, '0', std::to_string(original.size()));
}


If you find an optimization for <code>pad</code> or <code>pad_size</code>, <code>merge</code> gets optimized for free. And it gets a lot shorter:

inline std::string merge(const std::string&amp; s1, const std::string&amp; s2, const std::string&amp; s3) {        
    return pad_size(s1) + pad_size(s2) + s1 + s2 + s3;
}


Now let us inspect the reviewed and somewhat rewritten code:

namespace MultipartSplitMerge {
static constexpr size_t FIXED_FIELD_LENGTH = 8;

// Optional `detail' namespace; shows a user that `pad' and `pad_size'
// are implementation details. Only important in a header-only
// library
namespace detail {
inline std::string pad(size_t size, char padding, const std::string &amp;original) {
    assert(size &gt;= original.size());
    return std::string(size - original.size(), padding) + original;
}

inline std::string pad_size(const std::string &amp; original) {
    return pad(FIXED_FIELD_LENGTH, '0', std::to_string(original.size()));
}
} // namespace detail

inline std::string merge(const std::string&amp; s1, const std::string&amp; s2, const std::string&amp; s3) {        
    return detail::pad_size(s1) + detail::pad_size(s2) + s1 + s2 + s3;
}

inline void split(const std::string&amp; s, std::string&amp; o1, std::string&amp; o2, std::string&amp; o3) {
    const unsigned int size_1 = std::stoi(s.substr(0, FIXED_FIELD_LENGTH));
    const unsigned int size_2 = std::stoi(s.substr(FIXED_FIELD_LENGTH, FIXED_FIELD_LENGTH));
    o1 = s.substr(2 * FIXED_FIELD_LENGTH, size_1); 
    o2 = s.substr(2 * FIXED_FIELD_LENGTH + size_1, size_2); 
    o3 = s.substr(2 * FIXED_FIELD_LENGTH + size_1 + size_2);
}
} // namespace MultipartSplitMerge 


POST

At this point I wouldn't change the code anymore, unless I see via profiling that <code>split</code> or <code>merge</code> is a bottle-neck.

If you really notice that <code>merge</code> is a bottle-neck, you can use <code>sprintf</code>, but I <em>guess</em> that the compiler should optimize above code.

SUBMITTED

c,
        'dot1': lambda x, y, r: c.create_oval(x, y, x + r, y + r, fill='black'),
        'dot2': lambda x, y, r: c.create_oval(x + 16, y, (x + 16) + r, y + r, fill

PRE

Magic number elimination:
make offsets 8, 16 of something constant in places like this:

MID

'dot2': lambda x, y, r: c.create_oval(x + 16, y, (x + 16) + r, y + r, fill='black'),


you probably should make one function inside <code>draw_dice</code> instead of lambdas and use <code>partial</code> for partial application

def make_dot(x,y,r, color='black'):
    # actual code here
    pass


and then

'dot': partial(make_dot, x, y, x+8, y+8, r)


POST

SUBMITTED

filter(
      (item

PRE

MID

item

POST

Here's a complete example (haven't tested it!):

SUBMITTED

x Nothing   = extend partialSolution x &gt;&gt;= fullExtend n

nQueens :: Int -&gt; Maybe Solution
nQueens n = fullExtend n

PRE

We can do the same for <code>nQueens</code> and get rid of <code>extend</code> completely:

MID

nQueens :: Int -&gt; Maybe Solution
nQueens n = listToMaybe (nQueens' n)


But you need to be lazy enough for that.

In <code>fullExtend</code>, you'll check whether you already reached the correct length:

fullExtend :: Int -&gt; Solution -&gt; Maybe Solution
fullExtend n partialSolution
  | length partialSolution == n     = Just partialSolution             -- here
  ...


POST

However, that's again \$\mathcal O(n)\$. But we know the length of our current solution; almost. It's the number of recursive calls:

SUBMITTED

NULL;
    this-&gt;_renderer = NULL;
    this

PRE

MID

this-&gt;_renderer

this-&gt;getRenderer()

this-&gt;

POST

SUBMITTED

Interval mergedRunTail = null;

        // While both the left and right runs have intervals to offer, do:
        while (headInterval1 != null &amp;&amp; headInterval2 != null) {
            T head1

PRE

Typo: stably

MID

    // While both the left and right runs have intervals to offer, do:


POST

Thank you for this helpful comment.

SUBMITTED

bool Equals

PRE

MID

Equals

POST

SUBMITTED

res) {
    fetchActors

PRE

MID

fetchActors()

POST

SUBMITTED

amp; arr

PRE

Seems to me if your second <code>If</code> isn't true, maybe you need to go to the next <code>For</code>? Or does it need to re-perform the entire process again?

Maybe I'm having trouble understanding it. I have no idea what <code>lInd</code> is.

<em><strong>Give your variables meaningful names</strong></em>. This makes following the code easier and it also makes future you happy that you can take a look and know what is happening without tracing the entire procedure.

MID

arr

POST

SUBMITTED

i = 1; i &lt; sb.length(); i++) {
            if (i != mp &amp;&amp; i != mp - 1 &amp;&amp; i != mp + 1 &amp;&amp; i != ((mp + dp) - 1) &amp;&amp; i &lt; (dp + mp)) {
                sb.setCharAt(i

PRE

It's two consecutive ranges that you want to get replaced with <code>*</code>. So, I'd do two loops like:

MID

    for (int i = 1; i &lt; mp-1; i++) {
        sb.setCharAt(i, '*');
    }
    for (int i = mp+2; i &lt; mp+dp-1; i++) {
        sb.setCharAt(i, '*');
    }


POST

And add some sanity checks that the <code>@</code> and <code>.</code> characters are present.

SUBMITTED

bool Changed

PRE

MID

Changed

POST

SUBMITTED

Otherwise insert

PRE

MID

insert

POST

SUBMITTED

double));
    if (!elem)
    {
        fprintf(stderr, OUT_OF_MEMORY);
        exit(EXIT_FAILURE);
    }
    for (size_t j = 0; j &lt; matrix-&gt;cols; j++)
    {
        *(elem + j) = mx_get(matrix, i, j);
    }
    return elem;
}
double *mx_get_col(const matrix_t *matrix, const size_t j)
{
    double *elem = malloc(matrix-&gt;rows  *sizeof

PRE

I do not expect math library functions to decide when program must be terminated, I'd then avoid to call <code>exit()</code> (or even printing output to <code>stderr</code>) instead of the caller.

If you do not really need the error code then you may simply return <code>NULL</code> instead:

MID

double *mx_get_col(const matrix_t *matrix, const size_t j)
{
    double *column = malloc(matrix-&gt;rows  *sizeof(double));
    if (!column)
        return NULL;

    // ...
}


The other way is to use a return code:

error_t mx_get_col(const matrix_t *matrix, const size_t j, double **column)
{
    *column = malloc(matrix-&gt;rows  *sizeof(double));
    if (!*column)
        return ENOMEM;

    // ...
}


This lets me introduce another problem: you're not validating your inputs. Yes, it comes with a performance penalty but you should be ready to pay for it (in very performance critical scenarios at least when compiling debug builds).

error_t mx_get_col(const matrix_t *matrix, const size_t j, double **column)
{
    if (matrix == NULL)
        return EFAULT;

    if (j &gt;= matrix-&gt;cols)
        return EINVAL;

    // ...
}


POST

Note that there more preconditions you  might want to check, even just in debug:

SUBMITTED

lt;T&gt;&amp; lhs, const BufferIterator&lt;T&gt;&amp; rhs);

template&lt;typename T&gt;
void std::swap(BufferIterator&lt;T&gt

PRE

MID

std::swap(BufferIterator&lt;T&gt;&amp;, BufferIterator&lt;T&gt;&amp;)

POST

SUBMITTED

def print_list

PRE

MID

print_list

POST

SUBMITTED

lt; digits; i += 1) {
    positiveIntegers = sort(positiveIntegers, i);
    negativeIntegers

PRE

The following from your code requires 3 copies of the array to exist at the same time.

MID

positiveIntegers = sort(positiveIntegers, i);


POST

You have created a whole pile of functions, it's a real mess. Put the related functions together inside the main function.

Use closure to reduce the number of arguments you are moving about.

Don't create variable you use on once in the next line.

Deep in the sort you test for empty array, that should be the first test in the radix sort not deep inside.

This is an example of the same functionality as your code, and by far not the definitive solution. It matches the native sort in speed by eliminating a lot of the overhead you had. It uses 20 bucket so that the positive and negative values don't need to be split

SUBMITTED

at_index

PRE

MID

at_index

POST

SUBMITTED

filters """
        __location__ = os.path.realpath(
            os.path.join(os.getcwd(), os.path.dirname(__file__)))
        with io.open(os.path.join(__location__, self.file_path), "r",
                     encoding='utf

PRE

I don't understand why you didn't write <code>def __init__(self, lines=[], file_path='data/data_ts.utf8', entries_count=None)</code>

MID

        __location__ = os.path.realpath(
        os.path.join(os.getcwd(), os.path.dirname(__file__)))


POST

Better to just name it <code>location</code>. Also, cwd can change between calls to your class, so this code seems "too tricky". Better to have <strong>init</strong>() nail down a fully qualified pathname once, and store it.

SUBMITTED

Long, y

PRE

MID

y

POST

SUBMITTED

isIncreasingSequence(1,255,53,0)); //false

PRE

MID

false

POST

SUBMITTED

s = "'bhhd',12 'kjubk',2 'bjki',98 'khjbjj',4"
res = re.findall(r"(',)(\d+)", s)
all = []
for r in res:
   all.append(r[1])

print(",".join(sorted(all, key=int

PRE

<a href="https://docs.python.org/3/library/re.html#re.findall" rel="noreferrer"><code>re.findall()</code></a> behaves differently depending on whether the regex contains capturing parentheses.  If it doesn't contain capturing parentheses, then it just returns the matching text as a flat list.

So, how can you avoid capturing?  Just rewrite your regex to use a <strong>positive lookbehind assertion</strong>.

MID

s = "'bhhd',12 'kjubk',2 'bjki',98 'khjbjj',4"
all = re.findall(r"(?&lt;=',)\d+", s)
print(",".join(sorted(all, key=int)))


POST

SUBMITTED

has only to be attached if one value is really higher. No attachment when equal.
                    document.getElementById(key + 0)
                            .classList.add('higher-value');
                } else if (parseFloat(json[1][key]) &gt; parseFloat(json[0][key])) {
                    document.getElementById(key + 1)
                            .classList.add('higher-value');
                }

            }
        });
    }   

    document
        .getElementById('compare')
        .addEventListener('click', () =&gt; {
            removeHigherValueClass();
            runGen

PRE

And the condition for adding the <code>higher-value</code> class can be simplified to:

MID

if (parseFloat(json[i%2][key]) &gt; parseFloat(json[(i+1)%2][key])) { // ... then compare the current spec. Class has only to be attached if one value is really higher. No attachment when equal.
    dataCell.classList.add('higher-value');
} 


POST

The <code>else</code> block can be removed as well.

I haven't heard much on this front lately but typically to get the value of the selected option in a select list, one would need to use the <code>selectedIndex</code> property, like this:

SUBMITTED

Palidrime = true;

    if (PossiblePalindrome.size() &lt; 3)
    {
        Palidrime = false;
    }
    else
    {
        std::string::iterator leftSide = PossiblePalindrome

PRE

Prefer early return over putting your whole code inside an if-else construct. To my mind, at least, 

MID

if (PossiblePalindrome.size() &lt; 3)
{
    Palidrime = false;
}
else //...


should rather be

if (PossiblePalindrome.size() &lt; 3)
{
    return false;
} //no else


This helps eliminate redundant layers of indentation and makes the code more readable.

Since you don't write anything to the argument string, you should use <code>std::string::const_iterator</code> to iterate it (in addition to making the parameter <code>const</code>, see point 1).

Please, don't use <code>std::endl</code>. It's horrible. Why? Because it does not do what its name advises and is pretty much redundant. <code>std::endl</code> <em>does</em> write an end-of-line character, but it also flushes the underlying buffer, which is seldom what you want (and if you really need that functionality, you should use <code>std::flush</code>).

As you remarked yourself, your current code is not very much C++-like, but we're going to change that by making good use of the standard library. As you know, checking whether a string is a palindrome is equal to checking the to halves of the string for equality, only that the latter half is traversed in reverse order. Luckily for us, checking ranges of elements for equality is one of the things that are needed quite frequently by a lot of people, so C++ offers the very useful <code>std::equal</code>. 

<code>std::equal</code>, in its most basic form, takes three iterators: one to the beginning of a range of elements, one to its end, and another one that points to the beginning of the range the elements should be compared with. The only problem here is that we actually need our second range to be iterated in reverse. Again, the STL comes to our rescue. There is <code>std::reverse_iterator</code>, which, who would have guessed, allows iterating in reverse order, and also <code>rbegin</code>, which is a member function of <code>std::string</code> that returns a reverse iterator from the end of the string.

Combining these, we get

bool is_palindrome(std::string const&amp; s) {

    if (s.size() &lt; 3) {
        return false;
    }

    return std::equal(s.begin(), s.end(), s.rbegin());
}


POST

However, as you might have already noticed, we're wasting something here. In particular, we iterate through the whole string although we actually only need to check up to the middle. Thus, we adapt our code accordingly:

SUBMITTED

RIGHT };

void

PRE

MID

void

POST

SUBMITTED

board = [None

PRE

MID

None

return None

POST

SUBMITTED

for b in y]

sum_x_square = sum(x_square)
sum_y_square = sum(y_square)

sum_x_square_sum_y_square = sum_x_square*sum_y_square
sqrt_sum_x_square_sum_y_square = math.sqrt(sum_x_square_sum_y_square)

r = sum_xy/sqrt_sum_x_square_sum_y_square

print(r

PRE

If you read this, do you know what it means without reading the code next to it? Is it a sum of sums? A product of sums? Or a completely different thing altogether? When trying to find a good variable names, think about "what is this"? The answer might be e. g. "the product of sums of squared numbers". <code>product_of_sums_of_squared_numbers</code> is long, but it tells you what it is.

<strong>Implementing Formulas</strong>

Judge for yourself. What is more readible?

1.

MID

sum_x_square = sum(x_square)
sum_y_square = sum(y_square)

sum_x_square_sum_y_square = sum_x_square*sum_y_square
sqrt_sum_x_square_sum_y_square = math.sqrt(sum_x_square_sum_y_square)


or 2.

result = math.sqrt(sum(x_square) * sum(y_square))


POST

The second one is actually how you write formulas in maths. So when implementing a function to represent that formula, go the same way. (Hint: Maybe this code should be a function.)

<strong>Using Functions</strong>

SUBMITTED

return word;
}
int main(){
    std::vector&lt;std::string&gt; v;
    std::string str

PRE

Sure. Sounds reasonable. But need to understand the expected behavior/

You have a string. Which you are converting into a sequence of words and storing in <code>v</code>.

MID

    std::vector&lt;std::string&gt; v;


POST

But the only thing you do with <code>v</code> is loop over it and get each word to call <code>translate()</code> with. Why not remove the middle man and not use the container at all.

Here You are creaging a loop as long as the string. But each iteration you are taking a word from the string.

SUBMITTED

merge sort
    merge_sort(left)  # O(log n)
    merge_sort(right)  # O

PRE

You seem to assume that at the end of <code>merge</code> loop the <code>items1</code> list is always empty. It is not necessarily so.

The most important feature of merge sort is stability: items compared equal retain their order. In other words, if the items compare equal you want to merge the <code>left_item</code> first. The <code>left_item &lt; right_item</code> loses it.

A comment in

MID

    merge_sort(left)  # O(log n)


POST

is misleading. This step takes <code>O(n log n)</code>.

SUBMITTED

public static IEnumerable&lt;T&gt; Loop&lt;T&gt;(this IEnumerable&lt;T&gt; values, int startAt = 0)
{
    if (values == null)
    {
        throw new ArgumentNullException(nameof(values));
    }

    var moves = 0;

    // ReSharper disable once PossibleMultipleEnumeration
    var enumerator = values.GetEnumerator();

    try
    {
        while (true)
        {
            if (TryMoveNext(enumerator, out enumerator))
            {
                moves++;

                if (startAt &gt; 0 &amp;&amp; moves &lt;= startAt)
                {
                    continue;
                }

                yield return enumerator.Current;
            }
            else
            {
                yield break;
            }
        }
    }
    finally
    {
        enumerator.Dispose();
    }

    bool TryMoveNext(IEnumerator&lt;T&gt; currentEnumerator, out IEnumerator&lt;T&gt; newEnumerator)
    {
        if (currentEnumerator.MoveNext())
        {
            newEnumerator = currentEnumerator

PRE

You added the <code>if</code> for "boolean breaking", but at the same time you've subverted the inherent "boolean breaking" that a <code>while</code> loop provides.

Since you are looking to repeat the same collection multiple times, this collection is <strong>cyclic</strong> in nature. Whenever I think about cyclic data, the <strong>modulo</strong> operator always comes to mind. It's by far the most common use case for the modulo operator.

<a href="https://stackoverflow.com/questions/454916/performance-of-arrays-vs-lists">According to this SO answer</a>, though there may be a minor difference, the performance difference between enumeration and indexed arrays is reasonably negligible.<br>
Keeping that in mind, I would advocate using a modulo operator simply because it keeps the code cleaner.

<em>Note: The linked answer does not address re-enumeration, which is relevant for your code. But tbh, I'm not sure if re-enumeration is cached (thus not costing any meaningful overhead) or not. I'm going to continue my assumption that the performance differences are too small to be considered relevant for your current use case.</em>

MID

public static IEnumerable&lt;T&gt; Loop&lt;T&gt;(this IEnumerable&lt;T&gt; values, int startPosition = 0)
{
    if (values == null)
    {
        throw new ArgumentNullException(nameof(values));
    }

    T[] array = values.ToArray();
    int count = values.Count();

    while (true)
    {
        yield return array[startPosition++ % count];
    }
}


I kept the example terse (e.g. by inlining <code>startPosition++</code>), but I hope it highlights the reduced complexity of the code in general.

A slight improvement would be to not let <code>startPosition</code> grow beyond the array's size:

    while (true)
    {
        startPosition = (++startPosition) % count;
        yield return array[startPosition];
    }


Though I think this is only really useful if you expect to enumerate up to a point of integer overflow, which I doubt is the case here.

I'm torn about the <code>startPosition</code> variable name. Once we start using it as a counter, its name is no longer correct (it's the <strong>current</strong> position). However, I do think it fits as a parameter name.<br>
We can assign the value to a variable with a better name; but I'm not sure if it's really that necessary for such a terse piece of code.

I can see arguments for either case. I'm unable to make a conclusive decision on whether it's necessary. I'm open to feedback on this. 

If you do want to make the name more appropriate, I would suggest the following:

public static IEnumerable&lt;T&gt; Loop&lt;T&gt;(this IEnumerable&lt;T&gt; values, int? startPosition = null)
{
     //...

     int counter = startPosition ?? 0;

     //...
}


POST

SUBMITTED

basepath, true);
        /* --------------------------------------------------------------*/
    }

    private static void BuildCsFiles(IEnumerable&lt;string&gt; generatedCsFiles)
    {
        foreach (var generatedPath in generatedCsFiles)
        {
            var firstLine

PRE

According to <a href="https://msdn.microsoft.com/en-us/library/system.io.filesysteminfo.extension%28v=vs.110%29.aspx?f=255&amp;MSPPError=-2147217396" rel="nofollow noreferrer">MSDN</a>

The Extension property returns the FileSystemInfo extension, including the period (.). For example, for a file c:\NewFile.txt, this property returns ".txt".

MID

private static void BuildCsFiles(IEnumerable&lt;string&gt; generatedCsFiles)


POST

The parameter name should be <code>generatedCsFileNames</code>. I couldn't figure out at first what's going on here and why you are passing generated-cs-files to a method doing virtually the same thing.

SUBMITTED

requests

PRE

As pointed out by Alex Hall, there are many places the above code could be improved:    

MID

requests

POST

SUBMITTED

_content = content

    @property
    def name(self):
        # type: () -&gt; AnyStr
        return self._name

    @property
    def content(self):
        # type: () -&gt; List
        return self._content

    def get_name(self):
        # type: () -&gt; AnyStr
        return self.name

    def get_content(self):
        # type: () -&gt; List
        return self.content

PRE

I'd highly recommend you use <a href="https://docs.python.org/3/library/collections.html#collections.namedtuple" rel="nofollow noreferrer"><code>collections.namedtuple</code></a>. Or since you're using <code>typing</code>, <a href="https://docs.python.org/3/library/typing.html#typing.NamedTuple" rel="nofollow noreferrer"><code>typing.NamedTuple</code></a>. If we change <code>TioFile</code> to use this, then we'll get:

MID

_TioFile = NamedTuple(
    '_TioFile',
    [
        ('name', AnyStr),
        ('content', bytes)
    ]
)


class TioFile(_TioFile):
    def get_name(self):
        # type: () -&gt; AnyStr
        return self.name

    def get_content(self):
        # type: () -&gt; bytes
        return self.content


POST

From this, we know that <code>get_name</code> and <code>get_content</code> are actual not needed, and promote WET. Write it once for the property, once again for the method. And goes against <a href="https://www.python.org/dev/peps/pep-0020/" rel="nofollow noreferrer">PEP 20</a>:

There should be one-- and preferably only one --obvious way to do it.

And so I'd also change the following classes to use <code>NamedTuple</code>.

SUBMITTED

lt;&lt; "\n";
        }
    }

    void display_contact(std::string first, std::string last)
    {
        bool found;

        node *curr = head

PRE

Each function should have one action:

MID

    void display_contact(std::string first, std::string last)


This function has two distinct actions. 1) Find a Node 2) display a node. You can separate these out into there individual parts so they can be re-used more easily.

    void display_contact(std::ostream const&amp; ooutStream, std::string const&amp; first, std::string const&amp; last) {
        auto data = list.find(first, last);
        if (data !=list.end()) {
            outStream &lt;&lt; data;
        }
        else {
            std::cout &lt;&lt; "No person found called: " &lt;&lt; last &lt;&lt; " " &lt;&lt; first &lt;&lt; "\n";
        }


POST

O look here: We have found a re-use case for print out a <code>Node</code>.

SUBMITTED

t1, 'g

PRE

MID

"g"

POST

SUBMITTED

directory"""
    f

PRE

MID

f

POST

SUBMITTED

int barWidth

PRE

MID

barWidth

POST

SUBMITTED

value = this.value;

        $("table").find("tr

PRE

Even with abstracting that code into a function, it would still be performing a query on the DOM.

MID

$("table").find("tr")


That can be stored in a variable (or constant if ES-6's <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const" rel="nofollow noreferrer">const</a> is used):

var rows = $("table").find("tr");


To be on the safe side, that assignment can be placed inside a DOM-loaded callback (e.g. a function wrapped to the <a href="http://api.jquery.com/jQuery/#jQuery3" rel="nofollow noreferrer">jQuery callback wrapper: <code>$()</code></a>):

$(function() {  //DOM is ready
    var rows = $("table").find("tr");
    //Define  toggleRowsWithKeyword(), add click handlers, etc.
}); 


POST

Then the function can utilize <code>rows</code> instead of querying for the rows:

SUBMITTED

h1&gt;TODO!&lt;/h1&gt;
            &lt;ul&gt;{zipped.map( (z) =&gt;
                    &lt;li key={z[0].toString()}&gt;
                        {z[1].text}
                        &lt;button onClick={() =&gt; onDelete(z[0])}&gt;delete&lt;/button&gt;
                    &lt;/li&gt;
                )}
                &lt;li&gt;
                    &lt;input type="text" value={inputText} onChange={onInputChange}/&gt;
                    &lt;button onClick

PRE

You can shorten your <code>Array#map</code> callback to this without those two lines:

MID

{
  todos.map(({ text }, index) =&gt;
    &lt;li key={index}&gt;
      {text}
      &lt;button onClick={() =&gt; onDelete(index)}&gt;delete&lt;/button&gt;
    &lt;/li&gt;
  )
}


POST

<strong>General</strong>

<strong>Organization</strong> - Separate your Redux reducers, actions, etc. into different files for organization. I'm not sure if your project is currently in one file or not, but this is general advice. This app may be a minor one, but it's good practice for larger apps to keep things organized. For example, a directory structure I would use in this case looks like this:

SUBMITTED

incmp)
    | hasNoSwaps

PRE

MID

hasNoSwaps

POST

SUBMITTED

import React from 'react';
import { connect } from 'react-redux';

let DetailView = (props) =&gt; {
  console.log(props);
  var currentPost = props.posts.find(post =&gt; post.id === props.match.params.id);

  return (
    &lt;div&gt;
      &lt;h1&gt;{currentPost.topic}&lt;/h1&gt;
      &lt;p&gt;{currentPost.text}&lt;/p&gt;
    &lt;/div&gt;
  )
}

const mapStateToProps = (state) =&gt; {
  return state;
};

DetailView = connect(mapStateToProps)(DetailView);

export default DetailView

PRE

The <a href="https://react-redux.js.org/api/hooks" rel="nofollow noreferrer">official docs for react-redux</a> recommend using hooks instead of the <code>connect</code> API. Changing your included code to use hooks would leave use with the following:

MID

import React from 'react';
import { useSelector } from 'react-redux';

const DetailView = ({ match }) =&gt; {
  const posts = useSelector(state =&gt; state.posts);
  const post = posts.find(post =&gt; post.id === match.params.id);

  return (
    &lt;div&gt;
      &lt;h1&gt;{post.topic}&lt;/h1&gt;
      &lt;p&gt;{post.text}&lt;/p&gt;
    &lt;/div&gt;
  )
}

export default DetailView;


I see you are expecting a <code>match</code> prop in your component. You can avoid that prop if you take advantage of the <code>useParams</code> hook that <code>react-router-dom</code> provides:

import React from 'react';
import { useSelector } from 'react-redux';
import { useParams } from 'react-router-dom';

const DetailView = () =&gt; {
  const posts = useSelector(state =&gt; state.posts);
  const { id } = useParams();
  const post = posts.find(post =&gt; post.id === id);

  return (
    &lt;div&gt;
      &lt;h1&gt;{post.topic}&lt;/h1&gt;
      &lt;p&gt;{post.text}&lt;/p&gt;
    &lt;/div&gt;
  )
}

export default DetailView;
<span class="math-container">```</span>


POST

SUBMITTED

var x = 0
var sum = 0
func myFibonacci(of n: Int, a: Int, b:Int) -&gt; Int {
  x+=1
  if (x == n) {
    return sum
  } else {
    sum = a+b
    return myFibonacci(of: n, a: b, b: sum)
  }
}

let finalAns = myFibonacci(of: 9, a: 0, b: 1)
print("The nth number in Fibonacci sequence is \(finalAns

PRE

Global variables are often problematic, and
here they can be easily avoided, making the code not only safer,
but also simpler.

First, the global <code>sum</code> variable is elimitated by making
it local:

MID

var x = 0
func myFibonacci(of n: Int, a: Int, b: Int) -&gt; Int {
    x += 1
    if (x == n) {
        return b
    } else {
        let sum = a + b
        return myFibonacci(of: n, a: b, b: sum)
    }
}


or eliminate it completely:

var x = 0
func myFibonacci(of n: Int, a: Int, b: Int) -&gt; Int {
    x += 1
    if (x == n) {
        return b
    } else {
        return myFibonacci(of: n, a: b, b: a + b)
    }
}


Now get rid of the global variable <code>x</code> by decrementing <code>n</code> instead
in the recursive call:

func myFibonacci(of n: Int, a: Int, b: Int) -&gt; Int {
    if n == 1 { 
        return b // Recursion terminates here
    }
    return myFibonacci(of: n - 1, a: b, b: a + b)
}


With a slight modification it works for <code>n = 0</code> as well.
Negative arguments should be caught instead of recursing 
repeatedly until an integer overflow occurs:

func myFibonacci(of n: Int, a: Int, b: Int) -&gt; Int {
    precondition(n &gt;= 0, "`n` must be non-negative")
    if n == 0 {
        return a // Recursion terminates here
    }
    return myFibonacci(of: n - 1, a: b, b: a + b)
}


This is what I would expect as a recursive implementation in a coding interview (of course you can also implement it iteratively,
or use a <a href="https://en.wikipedia.org/wiki/Fibonacci_number#Closed-form_expression" rel="noreferrer">closed-form expression</a> such as Binet's formula).

As a bonus, you can implement it for negative arguments as well,
compare <a href="https://en.wikipedia.org/wiki/Generalizations_of_Fibonacci_numbers" rel="noreferrer">Generalizations of Fibonacci numbers</a>:

func myFibonacci(of n: Int, a: Int, b: Int) -&gt; Int {
    if n == 0 {
        return a // Recursion terminates here
    } else if n &gt; 0 {
        return myFibonacci(of: n - 1, a: b, b: a + b)
    } else {
        return myFibonacci(of: n + 1, a: b - a, b: a)
    }
}


POST

SUBMITTED

class TextAnalyzer:
    def __init__(self, txtFile):
        self.txtContent = open(txtFile)
        self.txtStream = self.txtContent.read()

    def __repr__(self):
        return self.txtStream

    def countChars(self):
        characters = {}
        for char in self.txtStream:
            if char != ' ' and char != '\n':
                if char.lower

PRE

This preserves the behavior of your original code,
and fixes the off-by-1 error,
because just like the <code>split</code> function of strings,
it ignores whitespace at the end of the content.

The splitting technique has an important drawback though:
it consumes more memory,
because it creates a list of words from the content,
effectively doubling the memory use.
Your solution is harder to implement correctly and to read,
but it's more memory-efficient.

There are several issues here:

MID

def __init__(self, txtFile):
    self.txtContent = open(txtFile)
    self.txtStream = self.txtContent.read()

def __repr__(self):
    return self.txtStream


The biggest issue is that a filehandle is not properly closed.
When you open something, remember to close it!

Since it's so easy to forget closing filehandles,
Python has a syntax to do this automatically for you:

with open(txtFile) as fh:
    self.content = fh.read()


POST

In the <code>with</code> example in the previous section,
I renamed <code>self.txtContent</code> to <code>fh</code>,
for two reasons:

It's a more appropriate name: <code>txtContent</code> implies some text content, which is not true and misleading. Likewise, I renamed <code>txtStream</code> to <code>content</code>, because that's what it really is. A "stream" is usually something that doesn't occupy much memory, doesn't contain the full content, but a data structure from which you can <em>stream</em> the content gradually without consuming much memory.

Even more importantly, <code>self.txtContent</code> is not used anywhere outside the <code>__init__</code> function,
so there's no need to make it an attribute of the class, it can be a local variable.

In this code, <code>char.lower()</code> is performed 3 times:

SUBMITTED

roll();
    inline

PRE

I see some things that may help you improve your code and offer some suggestions regarding your main question.

The main question you've asked here is about class design.  It often does make sense to separate the logic from the presentation of the data.  Reasons for doing so include:

On the other hand:

I could argue it either way for this one, but I would offer this suggestion: if you leave it as a single class, at least separate the operation from the presentation.  That is, <code>roll</code> could return the appropriate <code>int</code> but I'd suggest deriving <code>Dice</code> from <code>sf::Drawable</code> and implementing a separate <code>draw()</code> function.  Generally, I'd lean in the direction of having separate classes for the logic and presentation, even with such a small class.  I find that it often helps with maintenance.

The existing class reseeds the random number generator each time <code>roll</code> is called.  Not only does that reduce the randomness, but the seed is not particularly random, either.  Better might be to use <code>std::random_device</code> if your compiler (and hardware) supports it.

The class is called <code>Dice</code> but "dice" is the plural of "die" and this class actually appears to implement a single die.  I'm not going to strongly recommend changing it to <code>Die</code> (because that's also a verb which might confuse someone) but it's worth thinking about.

MID

inline

POST

The <code>inline</code> keyword is often misconstrued as something that will enhance the performance of the compiled code.  Typically, it won't.  If you're using it because you want to define the functions in the header, I'd suggest that you are probably better off splitting the implementation and the interface into <code>.cpp</code> and <code>.h</code> files instead.  See <a href="https://stackoverflow.com/a/1759575/3191481">this answer</a> for details.

Right now, the code doesn't check for errors when attempting to load resource files.  It should, and should provide some reasonable behavior if anything fails.

SUBMITTED

CreateIssue(string

PRE

MID

string

<em>In short: do not confuse the name of a property with its type. The type of <code>string Foobar { get; set; }</code> is <code>string</code>, not <code>Foobar</code>.</em>

You can fix this by letting <code>Fields.GetType(string field)</code> return <code>GetProperty(field)?.PropertyType</code>. You'll also need to remove that special customfield name handling, and there's no need for uppercasing names anymore. You can also skip step 3, because step 2 already tells you what target type you're dealing with.

List&lt;string&gt;

POST

SUBMITTED

namespace logic

PRE

MID

logic

logic::Dice

POST

SUBMITTED

class Convertor

PRE

Note few changes:

MID

Convertor

POST

SUBMITTED

utf-8 -*-
import

PRE

Some preliminary style guide pointers:

MID

import

POST

SUBMITTED

class ViterbiModel

PRE

If you updated your repo to contain a make/ant/maven/graven build file, I would be able to easily change and run your code. Without being able to reproduce your build environment, I can make some general comments.

Consider using Google's <a href="https://github.com/google/CallBuilder" rel="nofollow noreferrer">CallBuilder</a> library to save a lot of boilerplate code. The library makes it easy to make a builder simply by annotating your constructor. You may have to implement a custom "style" class to duplicate the exact behavior you have in your custom builder; however, I think it's worthwhile. Using code generation to make builders saves you from a lot of repetitive, error-prone code, and helps enforce consistent builder interfaces across your project.

In fact, writing CallBuilder style classes for all of the Gauva data structures would be an extremely cool and useful project. But that is beyond the scope of this algorithm.

MID

ViterbiModel

POST

Something like:

SUBMITTED

copiedFile = makeCopy

PRE

MID

makeCopy

POST

SUBMITTED

char **argv) {
  char *search = *(argv + 2);
  char

PRE

This makes the program play nicely with others.

Check arguments

MID

  char *search = *(argv + 2);


That's normally written

  char *search = argv[2];


POST

But in either case, this gives you undefined behaviour if the user doesn't supply two or more arguments.  You should check <code>argc</code>, and exit early with a usage message if <code>argc &lt; 3</code>.

Check return values of library functions - for example, we call <code>realpath()</code> with a user-supplied filename.  There are several ways this can fail (as seen in the man page), and <code>baseDir</code> will then have undefined contents.

<strong>Footnote</strong>:  It's perfectly fine to use <code>strlen()</code> on any null-terminated string, regardless of location. Perhaps you're thinking of warnings about using <code>sizeof</code> on string variables - that's when you need to really understand what's a pointer and what's an array.  Here's what an array type looks like:

SUBMITTED

float _width

PRE

MID

_width

POST

SUBMITTED

if lat == 0 and lon

PRE

MID

if lat == 0 and lon == 0

POST

SUBMITTED

__init__(self):
        self.head

PRE

MID

self.head

POST

SUBMITTED

const db = request.result;
            resolve({
                async add(storeName: string, value: {}): Promise&lt;string | {}&gt; {
                    return new Promise((res, rej) =&gt; {
                        const request = db.transaction([storeName], 'readwrite')
                            .objectStore(`${storeName}`)
                            .add(value);
                        request.onsuccess = (evt) =&gt; {
                            res(request.result);
                        };
                        request.onerror = () =&gt; {
                            rej(request.result);
                        };
                    });
                },
                async put(storeName: string, value: {}): Promise&lt;string | {}&gt; {
                    return new Promise((res, rej) =&gt; {
                        const request = db.transaction([storeName], 'readwrite')
                            .objectStore(storeName)
                            .put(value);
                        request.onsuccess = () =&gt; {
                            res(request.result);
                        };
                        request.onerror

PRE

I consider myself no expert in the field, but I think I can give you some small tips :). Here you go:

Writing a function as <code>async</code> makes it return a <code>Promise</code>. As you already wrote the return type <code>Promise&lt;IDBUtility&gt;</code>, declaring the function as async makes it redundant. In Typescript, an async function can include await expressions to simplify the Promise behaviour. <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function" rel="nofollow noreferrer">MDN</a>

I recommend you looking up some NPM packages to simplify your tasks. There is no need to reinvent the wheel. I believe these might be helpful for you: 
<a href="https://www.npmjs.com/package/idb" rel="nofollow noreferrer">https://www.npmjs.com/package/idb</a><br>
<a href="https://www.npmjs.com/package/idb-keyval" rel="nofollow noreferrer">https://www.npmjs.com/package/idb-keyval</a>

The union types are very useful in Typescript, but doesn't add any information to the type when you join something with <code>any</code>, as the joint type is already covered by <code>any</code>. Therefore, in <code>evt: ErrorEvent | any</code>, <code>evt</code> can be an <code>ErrorEvent</code> or anything else. This makes it not type safe, as you will have to type-cast it anyway. If you need to cover more kind of events than just <code>ErrorEvent</code>, you could maybe use the class it extends (<code>evt: Event</code>) or make your own custom events by extending <code>Event</code>.

MID

function add(storeName: string, value: {}): Promise&lt;string | {}&gt; {
    return new Promise((res, rej) =&gt; {
        const request = db.transaction([storeName], 'readwrite')
            .objectStore(`${storeName}`)
            .add(value);
        request.onsuccess = (evt) =&gt; {
            res(request.result);
        };
        request.onerror = () =&gt; {
            rej(request.result);
        };
    });
}


you could rewrite it to something like this:

async function add(storeName: string, value: any): Promise&lt;any&gt; {
    const request = await db.transaction([storeName], 'readwrite')
        .objectStore(storeName).add(value);

    if (request.isValid()) {
        return Promise.resolve(request.result);
    }

    return Promise.reject(`Add transaction failed: ${request.error}`);
}


POST

It's 3 LoC shorter and easier to understand what's going on (although, keep in mind that I made it up!). There are three significant instructions that can be caught in just a glimpse:

You will probably want to add some catching to make your database connection tolerant to errors. With the approach I'm trying to explain, shouldn't be hard to extend your code and still leave it readable and maintainable. 

I suggest you to study how to create clean, readable and easy-to-maintain code. The function you provided has way too many indentation levels for a function with that complexity (which shouldn't have either!). 

A function should do one thing, and do it well.

A 100-line function might be <em>easy</em> to write, but it's hard to understand for a person who hasn't been following your code development (or even yourself after certain amount of time). I strongly suggest <em>Clean Code</em> by <em>Robert C. Martin</em>. <a href="https://softwareengineering.stackexchange.com/questions/133404/what-is-the-ideal-length-of-a-method-for-you">Related question</a>. 

Good luck! :)

SUBMITTED

algo]
    total_tt

PRE

MID

total_tt

POST

SUBMITTED

let multiplesSum = n =&gt

PRE

MID

multiplesSum(n)

POST

Your algorithm is simple and easy to understand, but comes with a linear runtime complexity of <code>O(n)</code>.

An algorithm with constant runtime complexity <code>O(1)</code> exists. Here are some pointers in case you are stuck:

SUBMITTED

finally

PRE

MID

finally

POST

However, you forget to protect the code from NPE (<code>NullPointerException</code>):
at the beginning inside the try block, both handlers contain <code>null</code>.  You first open <code>print</code> the output handler, and then <code>goThrough</code>.  However, in the <code>finally</code> clause, the order is reversed. So, if an exception is thrown while opening <code>print</code>, <code>goThrough</code> is never initialized and you might encounter NPE in the <code>finally</code> clause. it is absolutely essential to ask separately about each file handler before closing it:           

SUBMITTED

NameError
    except

PRE

MID

except

POST

And so I'd change your code to (untested):

SUBMITTED

sum{0};
    double sq_sum{0};

    #pragma omp for
    for(auto j=0;j&lt;rows;j++)
        for

PRE

With this clause, each thread gets its own copy of the variables <code>sum</code> and <code>sq_sum</code>, and at the end of the loop these local variables are added together into the function's copy of these variables.

The algorithm you are using here to compute the variance is fast, but it's unstable. If the mean is large w.r.t. the variance, you'll get nonsensical results. See <a href="https://codereview.stackexchange.com/q/185450/151754">this recent post on Code Review</a> for some discussions regarding this issue. There are links there to resources about Welford's Algorithm, which is a stable one-pass algorithm to compute mean and variance.

Lastly, I honestly don't see the advantage of declaring a function <code>auto</code>. Writing <code>double</code> there only requires 2 more keystrokes. In exchange, your function's interface is explicit, which makes using it so much easier. The same is true for the <code>auto</code> in the input arguments.*  I don't know what integer type OpenCV uses for row and column sizes, but if it's not an <code>int</code>, then your code here

MID

for(auto j=0;j&lt;rows;j++)


POST

probably doesn't do what you want, because <code>j</code> will be declared <code>int</code>, not the type of <code>rows</code> (<code>0</code> is an <code>int</code>).

<strong>EDIT:</strong>

*: Reading more about <code>auto</code> parameters in a function declaration, I learned that it is a Concepts TS thing, and is a shortcut for a template specification. That means that it is not standard C++ yet. It also means that this function is a function template. I don't like the idea of a template that is not obviously so, and don't like the idea of a template that will only ever be used with one type. It prevents the C++ type system to do its thing, and it could mean you end up compiling more versions of your function than necessary. Type is an important part of C++, I am not in favor of hiding it away from the reader of the code, and especially not from the user of your functions. I would prefer explicit types in the function declaration. 

SUBMITTED

def insert

PRE

MID

insert()

POST

SUBMITTED

Service
public class StudentServiceImpl implements StudentService {

    private Logger logger = LoggerFactory.getLogger(this.getClass());

    @Autowired
    QuestionRepository questionRepository;

    @Autowired
    UserRepository userRepository;

    @Autowired
    Transformer transformer;

    @Override
    @Transactional
    public void correctAnswer(List&lt;StudentAnswersDTO&gt; questionAnswers) {
        logger.info("****** start correct answers ********");
        Long grade = 0L;
        List&lt;QuestionRightAnswerDTO&gt; rightAnswerDTOS = questionRepository.getRightAnswers();
        for (StudentAnswersDTO questionAnswer : questionAnswers) {
            if (questionAnswer.getType().toLowerCase().equals(AppConstants.MULTI_CHOICE)) {
                if (isCorrectAnswer(questionAnswer.getId(), questionAnswer.getAnswerId(), rightAnswerDTOS))
                    grade++;
            }
        }

        User currentStudent = userRepository.findByMobileNumber(SecurityHelper.getCurrentUser());
        ((Student) currentStudent).setGrade(grade);
        ((Student) currentStudent).setStudentAnswers(transformer.transform(questionAnswers, AnswerSelected.class));

        logger.info("****** end correct answers ********");
    }


    private boolean isCorrectAnswer(Long id, Long answerId, final List&lt;QuestionRightAnswerDTO&gt; rightAnswerDTOS) {
        for (QuestionRightAnswerDTO rightAnswer : rightAnswerDTOS) {
            if (id.equals(rightAnswer.getQuestionId()) &amp;&amp; answerId.equals(rightAnswer.getAnswerId()))
                return true;
        }
        return false

PRE

Fist of all I will recommend you to use Constructor based dependency injection. Then I can not see the relation between the <code>Question, QuestionAnswer, and QuestionRightAnswer</code> entities... currently you are selecting all the right answers from the DB which you should NOT do! You have to get all the correct answers for this question only. Use the <code>question.id</code> from <code>QuestionAnswer</code> just to match the <code>QuestionRightAnswer.questionId</code> <code>FK</code>. Also you do take care of the <code>MULTI_CHOICE</code> questions only, but why?

Consider an implementation such as:

MID

@Service
public class StudentServiceImpl implements StudentService {

    private Logger logger = LoggerFactory.getLogger(this.getClass());

    QuestionRepository questionRepository;
    UserRepository userRepository;
    Transformer transformer;

    @Autowired
    public NotificationService(QuestionRepository questionRepository,
                               UserRepository userRepository,
                               Transformer transformer) {
        this.questionRepository = questionRepository;
        this.userRepository = userRepository;
        this.transformer = transformer;
    }

    @Override
    @Transactional
    public void correctAnswer(List&lt;StudentAnswersDTO&gt; questionAnswers) {
        logger.info("****** start correct answers ********");
        Long grade = questionAnswers
            .stream()
            .filter(questionAnswer -&gt; questionAnswer.getType().toLowerCase().equals(AppConstants.MULTI_CHOICE))
            .filter(questionAnswer -&gt; questionRepository
                .getRightAnswersByQuestionId(questionAnswer.getId())
                .stream()
                .anyMatch(rightAnswer -&gt; questionAnswer.getAnswerId().equals(rightAnswer.getAnswerId())))
            .count();

        User currentStudent = userRepository.findByMobileNumber(SecurityHelper.getCurrentUser());
        ((Student) currentStudent).setGrade(grade);
        ((Student) currentStudent).setStudentAnswers(transformer.transform(questionAnswers, AnswerSelected.class));
    }
}


POST

SUBMITTED

void    queuePeek

PRE

There is a big assumption in this that expects the data pointer to be able to be big enough to take the amount of data available, and as JS1 pointed out you for <code>queuePeek()</code> the caller doesn't know how much data was copied. I don't know about the environment that you are using this in, but as you are deallocating the <code>data</code> pointer in the node, you might save that allocation at this point and just return it. This makes it the responsibility of the caller to release it but it might save you an allocation for the one that is passed into pop.

MID

queuePeek()

POST

As written, no check for going out of bounds on the data that is written to. As above no response on how much data was available.

Your tests only allow for a 'visual' check, ideally you should be able to test your queue through unit tests with specific assumptions and checks against these assumptions. <code>assert</code> works very well for that. 

The <code>queue.size</code> and <code>data.size</code> fields while having the same name indicate different kinds of sizes, one is a count, the other is an amount of memory ... 

<code>myque_t</code>has a typo in it, also is not really an ideal structure name, <code>fixed_capacity_queue</code> or something else might be more helpful and give you a little bit of reusability.

The <code>node</code> structure should probably be private in the implementation there is no need to put it in the include file

<code>queueClear()</code> could be written without updating size, just check on <code>head != NULL</code>

<code>queueGetSize()</code> is not really very useful, you do have access to the structure or ? 

You are trying to optimize the storage size, at the cost of allocations, i am assuming you have looked at the amounts that you have/need and decided that this is a necessary step. By itself the this looks fine, you'll have to be the judge of whether it actually does what you <em>think</em> it should accomplish.

You could introduce a buffer structure just to carry the <code>data</code> and <code>size</code> pairs, this might make <code>peek</code> and <code>pop</code> more clear, but there probably would always be a difference between the allocated amount from the pointer passed in and the actual written amount. Unless the amount of reserved memory is fixed.

You could implement this as a circular buffer on a fixed amount of memory. This might have some advantages depending on your needs. If you are low on memory you might want to save on allocations as well. 

SUBMITTED

connectionString))
    using (var cmd = conn.CreateCommand())
    {
        try
        {
            conn.Open();
        }
        catch (MySqlException ex)
        {
            return ex;
        }
        cmd.CommandText

PRE

As you suspected, this code is pretty bad. You are returning three different types of data here. Just, don't.

MID

try
{
    conn.Open();
}
catch (MySqlException ex)
{
    return ex;
}


Don't return the exception, re-throw it and catch it in the caller.

try
{
    conn.Open();
}
catch (MySqlException ex)
{
    throw;
}


In this block, you are catching the exception, then returning the exception to the user as a piece of data. A better way to do this would be to just not catch the exception and let the caller catch it:

try
{
    return mysqlWrapper.RunSelectCommand(C, collection);
}
catch (Exception ex)
{
    return ex;
}


POST

However, now you are exposing your call stack to the user, which you don't want to do. This information could provide hints to someone trying to break into your system, and is not allowed under some security protocols (SOC 2, for example). Instead of returning the whole exception, build a new piece of data and return just the relevant bits (or if they just need one piece, then just return that piece).

Don't return <code>false</code>. Either return an empty object (if the caller doesn't care if there were no results), or throw an exception. Alternately, you could use a <code>ValueTuple</code> and return <code>(bool success, Dictionary&lt;string, string&gt; data)</code> from the method. The first successful path would return <code>(true, {data})</code> and the second would return <code>(false, null)</code>.

You might have a SQL Injection attack going on here. Check out what happens if the client sends a request with the text parameter "test' or 1 = 1 --". It looks like the resulting query might be <code>SELECT * FROM api WHERE apikey = 'test' or 1 = 1 --'</code>, but I don't know this well enough to be sure.

SUBMITTED

new_cap);
  }

  public:
  Vector() : Vector

PRE

MID

Vector() : Vector(10) {}

POST

SUBMITTED

necessary.

int main()
{
    int

PRE

Alternatively, as:

MID

int main()
{


POST

SUBMITTED

function getDestinations(origin, destinationEnd) {
  let destinations = payloads.filter(payload =&gt; payload.origin === origin);
  destinations = destinations.map(destination =&gt; {
    const destinationsRecursive = getDestinations(destination.destination, destinationEnd);
    if (destinationsRecursive.length) {
      return Object.assign({}, destination, {
        next: destinationsRecursive
      });
    } else if (destination.destination === destinationEnd){
      return Object.assign({}, destination, {
        end: true
      });
    }
  })
  destinations = destinations.filter(destination =&gt; destination !== undefined)
  return destinations

PRE

So now links as created using <code>Links(&quot;ab,bc,ac&quot;);</code> which is easier to deal with.

This problem is not as simple as it first appears.

All path finding algorithms need to be aware of the paths that lead in circles.

Your problem <code>&quot;ab,ac,bc,bd,dc,de&quot;</code> and the solutions for this are <code>&quot;abc&quot;</code>, <code>&quot;abdc&quot;</code>, and <code>&quot;ac</code>&quot;. but if we change the last link to <code>&quot;da&quot;</code> we create a circular link. Your code will follow <code>&quot;abdabdabdab....&quot;</code> and so on until the call stack overflows.

In most recursive problems where you encounter a cyclic reference you can easily avoid the endless recursion by simply tracking the objects you have already referenced. Ending the recursion when you find a link that has already been traveled.

But your problem requires ALL paths  which complicates the problem (Actualy impossible as cyclic links create infinite paths).

Consider the links <code>&quot;ab,ac,bc,bd,dc,da&quot;</code>

It has the following solutions

If we marked all traveled then 3 would mark link <code>ac</code> as traveled and thus block solution 4.

Note: that the solutions include as many links as possible  without repeating.

The following is not a valid solution as <code>&quot;ad&quot;</code> is repeated

Currently your function crashed when presented with cyclic links.

Now lets inprove your code. The code is too complex and very hard to read.

MID

function getDestinations(origin, destinationEnd) {
  let destinations = payloads.filter(payload =&gt; payload.origin === origin);
  destinations = destinations.map(destination =&gt; {
    const destinationsRecursive = getDestinations(destination.destination, destinationEnd);
    if (destinationsRecursive.length) {
      return Object.assign({}, destination, {
        next: destinationsRecursive
      });
    } else if (destination.destination === destinationEnd){
      return Object.assign({}, destination, {
        end: true
      });
    }
  })
  destinations = destinations.filter(destination =&gt; destination !== undefined)
  return destinations;
}


Refactoring.

<code>payload</code> becomes <code>links</code> and you use destination to mean a link, we can abbreviate destinationEnd as <code>dest</code> and <code>getDestinations</code> makes more sense as <code>getPaths</code> with <code>destinationsRecursive</code> better called <code>paths</code>

Links filter, map, filter can be chained.

Also <code>Object.assign</code> is a bit noisy you can use <code>{...obj}</code> to do the same.

So now the function looks like

function getPaths(origin, dest) {
    return links
       .filter(link =&gt; link.origin === origin)
       .map(link =&gt; {
           const paths = getPaths(link.dest, dest);
           if (paths.length) {
               return {...link, more: paths};
           } else if (link.dest === dest){
               return {...link, end: true};
           }
      })
      .filter(link =&gt; link !== undefined);
}


POST

Which is a lot more readable.

Now the problem of performance. <code>map</code>, and <code>filter</code> are both slow and use more memory than is needed. Each recursive call does not release memory until you exit, which happens at the end of the searches.  Plus all the paths that are not part of the solution that you filter out each iteration

A quicker solution using a simple loop and changing when you create the new path  so you don't need to hold paths that go no where.

SUBMITTED

print("Here is the filepath:"+ filepath) 
    except FileNotFoundError:
        print("The filepath doesn't exist or there are some missing directories , please check and try again")
    else:
        print("Great! the file path is correct. Now, you can carry on!")
        break
# ------------ Let us Open our data file -------------------------
columns = defaultdict(list) # each value in each column is appended to a list

file_handle=open('{}'.format(filepath

PRE

Good job making sure to only catch the exception you care about.

MID

        print("The filepath doesn't exist or there are some missing directories , please check and try again")
    else:
        print("Great! the file path is correct. Now, you can carry on!")
        break


POST

Why do you have an <code>else</code> block in this <code>try:</code>/<code>except ...:</code>? Do you know the purpose of an <code>else:</code> block and when it is executed? This code probably belongs outside the <code>try:</code>/<code>except:</code> block.

SUBMITTED

package net.coderodde.fun;

import java.awt.geom.Point2D;
import java.util.Arrays;
import java.util.Objects;
import java.util.Random;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

/**
 * This class computes an approximate value of Pi. 
 * 
 * @author Rodion "rodde" Efremov
 * @version 1.6 (Feb 23, 2018)
 */
public class MonteCarloPiComputer {

    /**
     * The default radius of the simulated circle.
     */
    private static final double DEFAULT_RADIUS = 0.5;

    /**
     * The random number generator.
     */
    private final Random random;

    public MonteCarloPiComputer(Random random) {
        this.random = 
                Objects.requireNonNull(
                        random, 
                        "The input random number generator is null.");
    }

    public MonteCarloPiComputer() {
        this(new Random());
    }

    /**
     * Computes an approximate value of Pi via a Monte Carlo method. The method
     * creates {@code samples} random points, computes the percentage of all 
     * points within the radius from the center of the simulated square and 
     * multiplies it by {@code 4.0}.
     * 
     * @param samples the number of points to create.
     * @param radius  the radius of the simulated circle.
     * @return an approximate value of Pi.
     */
    public double computeApproximateValueOfPi(int samples, double radius) {
        Point2D.Double center = new Point2D.Double(radius, radius);
        double squareSideLength = 2.0 * radius;
        long numberOfPointsWithinCircle = 
            IntStream.range(0, samples)
                     .mapToObj(
                             (i) -&gt; { 
                                 return new Point2D.Double(
                                         squareSideLength * random.nextDouble(),
                                         squareSideLength * random.nextDouble()); 
                             })
                     .filter((point) -&gt; { 
                         return point.distance(center) &lt; radius; 
                     }).count();

        return (4.0 * numberOfPointsWithinCircle) / samples;
    }

    /**
     * Computes an approximate value of Pi via a Monte Carlo method with default
     * radius.
     * 
     * @param samples the number of points to create.
     * @return an approximate value of Pi.
     */
    public double computeApproximateValueOfPi(int samples) {
        return computeApproximateValueOfPi(samples, DEFAULT_RADIUS);
    }

    public static void main(String[] args) {
        MonteCarloPiComputer computer = new MonteCarloPiComputer();

        for (int samples = 100_000; samples &lt;= 1_000_000; samples += 100_000) {
            double approximation = 
                    computer.computeApproximateValueOfPi(samples);
            double percentage = approximation / Math.PI;
            System.out.print(String.format("%7d: ", samples));
            System.out.print(String.format("%10f", approximation));
            System.out.println(
                    String.format(
                            ", percentage from exact Pi: %10f", 
                            (100.0 * percentage

PRE

You have some superfluous <code>import</code>s.  I also think that you can rename <code>computeApproximateValueOfPi()</code> to <code>approximatePi()</code> without losing any clarity.

The simulation is complicated by the fact that the circle is centered at an adjustable point <code>(radius, radius)</code>.  You could just as easily use a unit circle centered at the origin, and generate points in a square with <em>x</em> in the range [0, 1) and <em>y</em> in the range [0, 1).  The computation is mathematically equivalent, with less shifting and scaling.

Furthermore, there is no need to instantiate a <code>Point2D</code> for each generated point.  You can use <a href="https://docs.oracle.com/javase/8/docs/api/java/awt/geom/Point2D.html#distance-double-double-" rel="nofollow noreferrer"><code>.distance(<em>x</em>, <em>y</em>)</code></a>.  Better yet, avoid computing the square root by using <a href="https://docs.oracle.com/javase/8/docs/api/java/awt/geom/Point2D.html#distanceSq-double-double-" rel="nofollow noreferrer"><code>.distanceSq(<em>x</em>, <em>y</em>)</code></a>.

The output routine in <code>main()</code> could be improved.  Your <code>percentage</code> variable doesn't actually store a percentage as its name suggests; the 100× happens in the formatting instead.  Splitting up the formatting into several <code>System.out.print()</code> calls defeats the purpose of <code>String.format()</code>.  I'd combine them all into one <code>System.out.format()</code> call.  Finally, the "percentage from" wording implies that you are calculating the difference; the calculation that you actually performed is what I would call "percentage of".

MID

import java.awt.geom.Point2D;
import java.util.Objects;
import java.util.Random;
import java.util.stream.IntStream;

public class MonteCarloPiComputer {
    /**
     * The random number generator.
     */
    private final Random random;

    public MonteCarloPiComputer(Random random) {
        this.random = Objects.requireNonNull(
            random, 
            "The input random number generator is null."
        );
    }

    public MonteCarloPiComputer() {
        this(new Random());
    }

    /**
     * Computes an approximate value of Pi via a Monte Carlo method. The method
     * creates {@code samples} random points in the upper-right quadrant,
     * computes the fraction of all points within the radius from the origin
     * and multiplies it by {@code 4.0}.
     * 
     * @param samples the number of points to create.
     * @return an approximate value of Pi.
     */
    public double approximatePi(int samples) {
        Random r = this.random;
        Point2D.Double origin = new Point2D.Double();
        long pointsWithinUnitArc = IntStream.range(0, samples)
             .filter(i -&gt; origin.distanceSq(r.nextDouble(), r.nextDouble()) &lt; 1)
             .count();
        return (4.0 * pointsWithinUnitArc) / samples;
    }


    public static void main(String[] args) {
        MonteCarloPiComputer computer = new MonteCarloPiComputer();

        for (int samples = 100_000; samples &lt;= 1_000_000; samples += 100_000) {
            double approximation = computer.approximatePi(samples);
            double pctDiff = 100 * (approximation - Math.PI) / Math.PI;
            System.out.format("%7d: %10f, deviation from exact Pi: %+10f%%%n",
                samples,
                approximation,
                pctDiff
            );
        }
    }
}


POST

SUBMITTED

template &lt;class... Args&gt;
struct signal {

    signal() = default;
    signal(signal&amp;&amp;) = default;

    // Copied signal doesnt have connected slots from original
    signal(const signal&amp;) : 
        slots(std::map&lt;slot_id_t, slot&lt;Args...&gt;&gt;()) { }  

    void emit(Args... args) {
        for (auto &amp;s : slots)
            s.second(args...);
    }

    template&lt;class T&gt; // for classes and class function member
    slot_id_t connect(T&amp; t, void(T::*fp)(Args...)) {
        return add_slot(slot&lt;Args...&gt;(t, fp));
    }

    template&lt;class T&gt; // for functors
    slot_id_t connect(T&amp; t) {
        // TODO: in C++17 is_invocable can be used
        static_assert(is_callable&lt;T&gt;::value, "Parameter not invokable. 
                      Pass method you want to use as slot"); 
                      return add_slot(slot&lt;Args...&gt;(t));
    }

    slot_id_t connect(void(fp)(Args...)) { // for global functions
        return add_slot(slot&lt;Args...&gt;(fp));
    }

    void disconnect(slot_id_t slot) {
        slots.erase(slot);
    }

private:
    slot_id_t add_slot(slot&lt;Args...&gt;&amp;&amp; t) {
        slots[t.slot_id] = std::move(t);
        return t.slot_id;
    }

    std::map&lt;slot_id_t, slot&lt;Args...&gt;&gt; slots

PRE

If you do choose to keep the <code>slot_id</code> member, it would probably be better off in the <code>slot</code> class, rather than a base class (prefer composition to inheritance), and the key generation part might be better off as a <code>key_generator</code> object, existing in the signal.

All the functionality of the <code>slot</code> class can be handled by <code>std::function</code>, which makes the class redundant:

MID

#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;functional&gt;
#include &lt;cassert&gt;

using slot_id_t = std::uint64_t;

struct slot_key_generator {
    slot_id_t _slots_id = 0;

    slot_id_t get_next() {
        return _slots_id++;
    }
};

template &lt;class... Args&gt;
struct signal {

    using function_t = std::function&lt;void(Args...)&gt;;

    signal() = default;
    signal(signal&amp;&amp;) = default;
    signal(const signal&amp;) = default;

    signal&amp; operator=(signal&amp;&amp;) = default;
    signal&amp; operator=(signal const&amp;) = default;

    void emit(Args&amp;&amp;... args) {
        for (auto &amp;s : _slots)
            s.second(std::forward&lt;Args&gt;(args)...);
    }

    slot_id_t connect(function_t function) {
        assert(function); // no empty functions!
        return add_slot(std::move(function));
    }

    void disconnect(slot_id_t slot) {
        _slots.erase(slot);
    }

private:

    slot_id_t add_slot(function_t&amp;&amp; t) {
        auto key = _generator.get_next();
        _slots.emplace(key, std::move(t));
        return key;
    }

    slot_key_generator _generator;
    std::map&lt;slot_id_t, function_t&gt; _slots;
};


POST

The user code is the same, except for functors, which can use <code>std::bind</code> (or a lambda if it's easier):

SUBMITTED

new MySqlCommand(query, connection))
            {
                cmd.Parameters.AddWithValue("@userName", this.UserName);
                using (var

PRE

This is odd to put here. For one, other pieces of code refer to <code>MessageBox</code> to display errors and messages, while this uses the console. Why this inconsistency? Either use one display technology or the other, but clearly not both. As before, this creates a poor user experience in seeing random debug messages out of nothing. Most likely, this could be replaced by some kind of log to a file or similar, but remember to add more context to it, so you can extract some useful information out of the file.

MID

cmd.Parameters.AddWithValue("@userName", this.UserName);


POST

It's always nice to see properly parametrized queries. But remember that <a href="http://blogs.msmvps.com/jcoehoorn/blog/2014/05/12/can-we-stop-using-addwithvalue-already/" rel="nofollow noreferrer"><code>AddWithValue</code> is a bad practice</a>, declare the exact data type for the parameter and make sure it matches the server side declaration exactly.

SUBMITTED

function getSafeInputs

PRE

MID

getSafeInputs

POST

SUBMITTED

Returns found

PRE

MID

found

if(!found)

POST

SUBMITTED

using System.Threading;
using System.Net;
using System.Net.Sockets;
using System;

namespace ConsoleApp2
{
    class Program
    {
        public static void Main()
        {
            var localIP = IPAddress.Parse("10.10.10.117");
            var listenerPort = 20000;
            var senderPort = listenerPort + 2;
            IPEndPoint listenerEndpoint = new IPEndPoint(localIP, listenerPort);
            IPEndPoint senderEndpoint = new IPEndPoint(localIP, senderPort);
            TcpListener tcpListener = new TcpListener(listenerEndpoint);
            StarttcpListenerThread(tcpListener);
            Thread.Sleep(300);
            StartTCPSendingThread(listenerEndpoint, senderEndpoint);
            while (true)
            {
            }
        }

        static void StarttcpListenerThread(TcpListener tcpListener)
        {
            tcpListener.Start();
            Thread tcpListenerThread = new Thread(() =&gt;
            {
                while (true)
                {
                    try
                    {
                        byte[] bytes = new byte[1024];
                        TcpClient currentConnection = tcpListener.AcceptTcpClient();
                        NetworkStream stream = currentConnection.GetStream();
                        int numBytesReadFromStream = stream.Read(bytes, 0, bytes.Length);
                    }
                    catch (Exception e)
                    {
                        Console.WriteLine(e.Message);
                    }

                }
            });
            tcpListenerThread.Start();
        }

        static void StartTCPSendingThread(IPEndPoint listenerEndpoint, IPEndPoint senderEndpoint)
        {
            TcpClient tcpClient = new TcpClient(senderEndpoint);
            tcpClient.Connect(listenerEndpoint);
            Thread tcpSendingThread = new Thread(() =&gt;
            {
                while (true)
                {
                    try
                    {
                        tcpClient.Client.Send(new byte[] { 1, 2, 8 });
                    }
                    catch (Exception e)
                    {
                        Console.WriteLine(e.Message);
                    }
                }
            });
            tcpSendingThread.Start

PRE

The <code>Main</code> method looks a bit like spaghetti code. 
Specially because you keep alternating statements between things you need for the <code>TcpListener</code> and things that you need for <code>TcpClient</code>.

One possible thing you could do about this is to let Start<strong>T</strong>cpListenerThread create the <code>TcpListener</code> himself. 
Same goes for StartT<strong>cp</strong>SendingThread.

var senderPort = listenerPort + 2;

You don't have to be explicit about the port the client should use, since the operating system 
will attribute a port dynamically as long as you use <code>TcpClient tcpClient = new TcpClient("localhost", 20000);</code>

while (true)    {   }

This is great, if you want to increase your power bill by putting your CPU usage on <code>100</code>. 
If you don't want to do that however, you can use <code>Console.ReadLine();</code> or <code>Thread.Sleep(Timeout.Infinite);</code>

If possible you should also be consistent on whatever you use <code>var</code> or not.

Here is the code with the things I stated applied to it.

MID

public static readonly int Port = 20000;

public static void Main()
{
    StartTcpListenerThread();
    Thread.Sleep(300);
    StartTcpSendingThread();
    Console.ReadLine();
}

static void StartTcpListenerThread()
{
    var tcpListener = new TcpListener(IPAddress.Any, Port);
    tcpListener.Start();
    Thread tcpListenerThread = new Thread(() =&gt;
    {
        while (true)
        {
            try
            {
                var bytes = new byte[1024];
                var currentConnection = tcpListener.AcceptTcpClient();
                var stream = currentConnection.GetStream();
                var numBytesReadFromStream = stream.Read(bytes, 0, bytes.Length);
            }
            catch (Exception e)
            {
                Console.WriteLine(e.Message);
            }

        }
    });
    tcpListenerThread.Start();
}

static void StartTcpSendingThread()
{
    var tcpSendingThread = new Thread(() =&gt;
    {
        var tcpClient = new TcpClient("localhost", Port);
        while (true)
        {
            try
            {
                tcpClient.Client.Send(new byte[] { 1, 2, 8 });
            }
            catch (Exception e)
            {
                Console.WriteLine(e.Message);
            }
        }
    });
    tcpSendingThread.Start();
}


POST

Regarding your question about exceptions it seems reasonable to me, to catch the exception and display what is wrong to the console. Most of the time this will be due to some network issue and there isn't much you can do on those scenarios. Keeping the listener listening requests may or may not be a good decision but I would say it's at least a somewhat decent decision for a first approach.

SUBMITTED

class Student

PRE

MID

Student

POST

SUBMITTED

drives
    initial_usbDrivesCount = getCountOfUSBDevices();
    initial_inputDevicesCount = getCountOfInputDevices();
    checkForKeyStrokeInjectoThread = QtConcurrent::run(this, &amp;RubberDuckyDetector::checkPresenceOfKeyStrokeInjector);
    connect(this, SIGNAL(driveIsKeyStrokeInjector()), this, SLOT(informKeystrokeInjector()));
    connect(this, SIGNAL(driveIsUSB()), this, SLOT(informUSBDrive()));
 }

RubberDuckyDetector::~RubberDuckyDetector()
{
    running = false;
    checkForKeyStrokeInjectoThread.cancel();
    checkForKeyStrokeInjectoThread.waitForFinished();
    delete ui

PRE

You have a data race in your code. You access <code>running</code> reading and writing. <code>volatile</code> <strong><em>does not mean threadsafe</em></strong>. Therefore, your code exhibits undefined behaviour.

Neither <code>getCountOfUSBDevices</code> nor <code>getCountOfInputDevices</code> need to be associated with <code>RubberDuckyDetector</code>. They can be <code>static</code> or&mdash;even better&mdash;free standing functions.

If possible, use C++11 features for <code>connect</code> instead of <code>SLOT</code> and <code>SIGNAL</code>:

MID

connect(this, &amp;RubberDuckyDetector::driveIsKeyStrokeInjector, 
        this, &amp;RubberDuckyDetector::informKeystrokeInjector);
connect(this, &amp;RubberDuckyDetector::driveIsUSB, 
        this, &amp;RubberDuckyDetector::informUSBDrive);


POST

This will enable the compiler to check whether the signal and slot a) exist and b) are compatible.

To remove possible data races in <code>checkForKeyStrokeInjectoThread</code> have <code>checkPresenceOfKeyStrokeInjector</code> take two arguments. Then you don't have to store the <code>initial_usbDrivesCount</code> in your class at all.

You switch naming conventions. <code>initial_usbDrivesCount</code> is both <code>camelCase</code> and <code>python_case</code>.

This is personal preference, but if you put the doxygen comments into the implementation, your header gets a lot smaller and easier to read through, e.g.

SUBMITTED

elif depthLimit == 0:
                path.pop()
                visited[u] = False
                return
            else:
                for

PRE

If you need a number that's larger than any possible cost, use infinity, that is, <code>float('inf')</code> instead of an arbitrary number.

The goal of the problem is to find just one path to the destination (the cheapest one), so it is wasteful to maintain a collections of all paths to the destination. Better just to remember the best path found so far.

There is no need to pass the variables <code>goal</code> and <code>visited</code> and <code>path</code> into the <code>enumerateAllPaths</code> function. These do not change during the search.

These lines of code are repeated:

MID

path.pop()
visited[u] = False


POST

By testing <code>depthLimit != 0</code> instead of <code>depthLimit == 0</code> you could avoid this repetition.

Instead of implementing <code>visited</code> as a dictionary mapping nodes to <code>True</code> or <code>False</code>, use a set of nodes instead.

The <code>path</code> list is not needed: this is only used to find the length of the path, but that is redundant as <code>len(path)</code> is always equal to <code>K + 1 - depthLimit</code>. And since you don't care about the actual length of the path, only its relative length compared with other paths, you can drop the <code>K + 1</code> (since this is the same for all paths) and just use <code>-depthLimit</code>.

SUBMITTED

data != null

PRE

MID

null

POST

SUBMITTED

byte[] GenerateSalt()
    {
        using (var randomNumberGenerator = new RNGCryptoServiceProvider())
        {
            var randomNumber = new

PRE

Cryptography is an arms war: it's always worth thinking about the upgrade path. That means recording the parameters (name of hash, number of iterations, length of salt) in such a way that they can be extracted when it's time to validate.

MID

        using (var randomNumberGenerator = new RNGCryptoServiceProvider())


I think it's better practice to use <code>RandomNumberGenerator.Create()</code> and leave the selection of the provider to the system-wide configuration.

        using (var rfc2898DeriveBytes = new Rfc2898DeriveBytes(toBeHashed, salt, numberOfRounds))


POST

RFC 2898 was intended as a key derivation function, not a password validation mechanism. It's probably safe, but I'm leery of using it for a different purpose without including a reference to a respected cryptographer who says it's safe.

SUBMITTED

int number1

PRE

MID

number1

POST

SUBMITTED

return goToWork;
    }

    //////////////////////////////////////////////////////////////////////////////
    /////////////////////////// BEGIN FUNCTIONS //////////////////////////////////
    //////////////////////////////////////////////////////////////////////////////

    /**
     * //////////////////////// Model Constructor ////////////////////////////////
     * Model Constructor

PRE

This is just useless. It's not only useless, I have no idea what I have to do with that information. And it's wrong. The first line after that comment is the serialVersionUID. And it's not parameters. Just get rid of all those comments, it's just clutter and misleading.

Disable the eclipse warning for the serialVersionUID. And delete all of those uids. When I'm pair programming with my apprentices, I forbid them to use quick fix. Because they don't know what the error/warning is, and what the quick fix does.

Don't explose <em>implementation detail</em>:
    public GeomVectorField roads = new GeomVectorField();

See <em>information hiding</em>

Okay, I withdraw my previous statement, THIS is the worst:

MID

/**
 * //////////////////////// Model Constructor ////////////////////////////////
 * Model Constructor
 */


POST

JavaDoc WITH single line comments.

Don't declare your variables with the implementation of the datastructure, use <code>Map</code> instead of <code>HashMap</code>. It shouldn't concern you what type of Map it is. The decision what map to use is taken once.

instead of

SUBMITTED

for iteamList

PRE

MID

iteamList

POST

SUBMITTED

Method that returns a client from a string
    private static Cliente ObtenerCliente(string query)
    {
        try
        {
            abrirConexion(); //Static method that opens a connection

            cmd = new MySqlCommand(query, mySqlConexion);
            MySqlDataReader dataReader = cmd.ExecuteReader();

            if (dataReader.Read())
            {
                return new Cliente(
                    Convert.ToInt32(dataReader["id_cliente"]),
                    dataReader["nombre_cliente"].ToString());
            }
            else
            {
                dataReader.Close();
                return null;
            }
        }
        catch (MySqlException e)
        {
            MessageBox.Show(e.ToString());
            return null;
        }
        finally
        {
            cerrarConexion(); //Static method that closes the connection
        }
    }

    //Method that returns a customer from a phone number given
    public static Cliente ObtenerCliente_Telefono(string telefono)
    {
        string query = "SELECT * FROM clientes WHERE (telefono1_cliente = '" + telefono + "' OR telefono2_cliente = '" + telefono + "');";
        return ObtenerCliente(query); //Metodo que hace la consulta
    }
    public static Cliente ObtenerCliente_Id(int id)
    {
        string query = "SELECT * FROM clientes  WHERE id_cliente = " + id + ';';
        return ObtenerCliente(query

PRE

Nothing wrong with <code>Cliente ObtenerCliente</code> accepting the query text.

Suffers from non-deterministic.  You are only going to get the first but without an <code>order by</code> then SQL will just pick one for you.

<code>using</code> is a better approach in my opinion   

For sure I don't like 

Static method that opens a connection

Create the connection and let it be properly disposed  

MID

private static Cliente ObtenerCliente(string query)
{
    using (Connection mySqlConexion = new Connection(conString))
    {
        try
        {
            //abrirConexion(); //Static method that opens a connection
            mySqlConexion.Open();
            using (cmd = new MySqlCommand(query, mySqlConexion))
            {
                using (MySqlDataReader dataReader = cmd.ExecuteReader())
                {                    
                    if (dataReader.Read())
                    {
                        return new Cliente(
                        Convert.ToInt32(dataReader["id_cliente"]),
                        dataReader["nombre_cliente"].ToString());
                    }
                    else
                    {
                        //dataReader.Close();  let the using dispose
                        return null;
                    }
                }
            }
        }
        catch (MySqlException e)
        {
            MessageBox.Show(e.ToString());
            return null;
        }
        finally
        {
             //cerrarConexion(); //Static method that closes the connection
        }
    }
}


POST

SUBMITTED

MailManager To

PRE

MID

To

POST

SUBMITTED

input("")
        if cyclea == 1:
            store

PRE

On the <code>if</code> statements in your code, you use integers rather than strings. Add quotes around them, or change the input to integers. Like this:

MID

if store == 1:


or

store = int(input(""))


POST

SUBMITTED

let context

PRE

MID

let

POST

Variables like <code>context</code>, <code>activeColumn</code> and <code>winner</code>  in <code>putPieceInColumnNo()</code>, <code>activeCol</code> in <code>checkWinnerVertical()</code>, etc. don't get re-assigned and thus are good candidates for <code>const</code> instead of <code>let</code>. While properties of constants can be re-assigned, the object/value itself cannot be re-assigned. 

SUBMITTED

MainPage.xaml

PRE

Generally speaking I find a good implementation and like the simplicity of the approach. I would point out some problems I found though.

You are using two different ways to instantiate views and viewmodels and linking them together in both views, an inconsistence that could get bigger the and messier the more complex the program becomes.

In the <code>MainPage</code> you're creating the viewmodel in the view's constructor, and assigning it to the <code>BindingContext</code> right away. But in the <code>LoginPage</code> you create the viewmodel in the handler of the main page and pass it to the constructor of the view (not show here, but I guess it also assigns the <code>BindingContext</code> with it).

Specially for bigger applications, it's important to clearly define one style, either <em>view first</em> or <em>viewmodel first</em>, and live with it (I don't even know if it's called "style", but it sounds like that to me). A more concerning problem is that when VMs begin to take dependencies on services and other stuff, you most likely will want to use an <a href="https://en.wikipedia.org/wiki/Inversion_of_control" rel="nofollow noreferrer">IoC container</a> for injecting them, and then it becomes more important to clearly define who'll create viewmodels and how. Personally, I like viewmodel-first approach, in which viewmodels create other viewmodels and are passed to the views.

MID

MainPage

POST

SUBMITTED

jobs\pattern_file

PRE

MID

pattern_file

POST

SUBMITTED

public abstract class Notification
{
    private IEmailSender emailSender;

    public string To { get; }

    public virtual string Subject { get; }

    public virtual string Template { get; }

    public virtual object Model { get; }

    public Notification(IEmailSender emailSender, string to, object model)
    {
        this.emailSender = emailSender;
        this.To = to;
        this.Model = model;
    }

    public virtual async Task SendAsync()
    {
        var engine = new RazorLightEngineBuilder()
            .UseFilesystemProject(Directory.GetCurrentDirectory())
              .UseMemoryCachingProvider()
              .Build();

        string message = await engine.CompileRenderAsync(this.Template, this.Model);

        await emailSender.SendEmailAsync(To, Subject, message

PRE

The implementation can be as simple as the following

MID

public class NotoficationService : INotificationService {
    private readonly IEmailSender emailSender;

    public NotoficationService(IEmailSender emailSender) {
        this.emailSender = emailSender;
    }

    public async Task SendAsync(Notification notification) {
        var engine = new RazorLightEngineBuilder()
           .UseFilesystemProject(Directory.GetCurrentDirectory())
             .UseMemoryCachingProvider()
             .Build();

        string message = await engine.CompileRenderAsync(notification.Template, notification.Model);

        await emailSender.SendEmailAsync(notification.To, notification.Subject, message);
    }
}


Even the compilation of the razor template can be extracted out into its own service in order for this code to be more SOLID. I'll leave that choice up to you to implement.

Finally, the <code>AccountController</code> would now explicitly depend on the <code>INotificationService</code> in order to be able to send notifications. The <code>Notification</code> derived model can be then passed to the service and the message sent.

public class AccountController : Controller {
    private readonly INotificationService notificationService;

    public AccountController(INotificationService notificationService) {
        this.notificationService = notificationService;
    }

    //...

    [HttpPost]
    public async Task&lt;IActionResult&gt; Register([FromBody]MyModel model) {
        //...

        var notificationModel = new RegisterConfirmationViewModel { FirstName = "Jacques" };
        var notification = new RegisterConfirmationNotification (model.Email, notificationModel);
        await notificationService.SendAsync(notification);

        //...

        return View();
    }

}


POST

SUBMITTED

or type(repr) is

PRE

MID

type() is

POST

SUBMITTED

public class Document
{
    public int Id { get; set; }
    public string Name { get; set; }

    #region Navigation Properties

    public int CollectionId { get; set; }
    public DocumentCollection Collection { get; set; }

    public int? PredecessorId { get; set; }
    public Document Predecessor { get; set

PRE

I find you should stick to the same naming convention of the original <a href="https://msdn.microsoft.com/en-us/library/ahf4c754(v=vs.110).aspx" rel="nofollow noreferrer"><code>LinkedListNode</code></a>. This means that you should have a <code>Preview</code> and <code>Next</code> properties and not <code>Predecessor</code> and <code>Successor</code> respecitively.

I then would implement these two in another class, e.g. <code>LinkedEntityNode</code>:

MID

public class LinkedEntityNode
{
    public int Id { get; set; }
    public int? NextId { get; set; }
    public int? PreviousId { get; set; }
}


and put this in a separate table.

Then let the document reference the node:

public class Document
{
    public int Id { get; set; }    

    public string Name { get; set; }

    public int? NodeId { get; set; }   

    #region Navigation Properties

    public LinkedEntityNode Node { get; set; }

    #endregion
}


POST

It would require a couple of adjustments to the models and to the sorting and finding logic but this way you could implement it once and for all and use it in any other project to link all kinds of stuff this way. Not just the <code>Document</code> entity.

I also think you don't need the collection type because as soon as you know one document (a node), you can rebuild it from there.

SUBMITTED

self.new_players

PRE

MID

new_players()

POST

SUBMITTED

is set to $replaceUrl"

mysql --user="$user" --password="$password" --host="$databaseHost" --database="$databaseName" -e "UPDATE messages SET message = REPLACE(message, '$searchUrl', '$replaceUrl

PRE

Avoid writing <code>"$password"</code> into the <code>mysql</code> command line like that - as the man page says:

Specifying a password on the command line should be considered insecure. See <a href="https://dev.mysql.com/doc/refman/5.7/en/password-security-user.html" rel="nofollow noreferrer">Section 6.1.2.1, “End-User Guidelines for Password Security”</a>. You can use an option file to avoid giving the password on the command line.

It also says

If you omit the password value following the <code>--password</code> or <code>-p</code> option on the command line, mysql prompts for one.

So I'd recommend not reading the password in this script, but passing <code>--password</code> to tell mysql to do its own prompting.

The other thing that's dangerous is using user input to construct the SQL query string - even if your users are trusted (and you know they have permission to connect and execute this command), it's worth validating the strings to prevent accidents.  An alternative could be to <a href="//stackoverflow.com/a/4383994">use Bash to quote the arguments</a>:

MID

command=$(printf 'UPDATE messages SET message = REPLACE(message, %q, %q') \
                 "$searchUrl", "$replaceUrl")

mysql --user="$user" --password \
   --host="$databaseHost" --database="$databaseName" \
   -e "$command"


POST

It may be worth writing the script in a different language (or passing these variables to a sub-script in the different language), to enable the use of prepared statements.  I thought there might be a way to define variables for the mysql command like you can for Awk, and then use them in statements, but I couldn't find any provision for that, unfortunately.

An enhancement I would make is to ask for confirmation after reading all the interactive inputs.  Right now, if I make a mistake in <code>replaceUrl</code> (e.g. I manage to press <kbd>\</kbd> and <kbd>Enter</kbd> together), then I don't get a chance to interrupt the update.  At the very least <code>sleep 2 &amp;&amp; mysql</code> so I can <kbd>Control</kbd>+<kbd>C</kbd> before it's too late.

SUBMITTED

token = $this-&gt;getToken($user);

    if ('main' !== session('type') &amp;&amp; is_null($token)) {
        $instagramProfile = $this-&gt;findInstagramProfile($user);
        $token = $instagramProfile-&gt;profile-&gt;user-&gt;api_token ?? null;
    } else {
        if (!$instagramProfile = $this-&gt;findInstagramProfile($user)) {
            $profile = create_instagram_profile($user);
            $user = $this-&gt;createUser($profile);
            $token = $user

PRE

I am not sure I understand what is supposed to happen in

MID

    if ('main' !== session('type') &amp;&amp; is_null($token)) {
        $instagramProfile = $this-&gt;findInstagramProfile($user);
        $token = $instagramProfile-&gt;profile-&gt;user-&gt;api_token ?? null;
    }


if by any chance <code>$instagramProfile-&gt;profile-&gt;user</code> happens to be <code>null</code>. Otherwise, refactoring is very straightforward. Just lift the common actions out of the <code>if/else</code> one by one:

    $instagramProfile = this-&gt;findInstagramProfile($user);

    if (!$instagramProfile) {
        $instagramProfile = create_instagram_profile($user);
    }   

    user = $instagramProfile-&gt;profile-&gt;user;
    if (!user) {
        $user = $this-&gt;createUser($instagramProfile-&gt;profile);
    }

    $token = $user-&gt;api_token;


POST

Observe that it is just a mechanical rewrite.

PS: I presume that <code>create_instagram_profile</code> can be safely called with <code>null</code> argument; you are doing it anyway.

SUBMITTED

flip compare uy1 uy2 
                  else ux1 `compare` ux2
    where (ux1, uy1) = upper t1
          (ux2, uy2) = upper t2

-- total height -&gt; iteration -&gt; triangles 
sierpinski :: Int -&gt; Int -&gt; [Triangle]
sierpinski h 0 = [makeTriangle (h, h) h] 
sierpinski h n

PRE

For iteration inside <code>serpinski</code> you can benefit from <a href="https://hackage.haskell.org/package/base-4.11.1.0/docs/Prelude.html#v:iterate" rel="nofollow noreferrer"><code>iterate</code></a> and take the <code>n</code>-th element of the output. Note that thanks to laziness, you don't have to care that further elements in the list are not defined.

MID

-- total height -&gt; iteration -&gt; triangles 
sierpinski :: Int -&gt; Int -&gt; [Triangle]
sierpinski h = (iterate (concatMap split) [Triangle (0, 0) h] !!)


POST

For grouping, sorting etc. according to some property there are two very useful combinators: <a href="https://hackage.haskell.org/package/base-4.11.1.0/docs/Data-Function.html#v:on" rel="nofollow noreferrer"><code>on</code></a>, which we use here:

SUBMITTED

errorSet = false;

    @FXML
    private void createAccount() throws IOException {

        if (!lastNameField.getText().isEmpty() &amp;&amp; !firstNameField.getText().isEmpty() &amp;&amp; userRole.getValue() != null &amp;&amp; !emailField.getText().isEmpty() &amp;&amp; !passwordField.getText().isEmpty()) {
            if (SharedRegexController.isEmailSyntax(emailField.getText()) &amp;&amp; SharedRegexController.isValidateEmail(emailField.getText())) {
                if (passwordField.getText().length() &gt; StaticDigit.USER_PASSWORD_MIN_LENGTH) {
                    if (passwordField.getText().matches(".*[a-z]*.") &amp;&amp; passwordField.getText().matches(".*[A-Z].*") &amp;&amp; passwordField.getText().matches(".*[1-9]*.")) {
                        if (termsAgreementCheckBox.isSelected()) {
                            //Get values from text fields
                            String lastNameValue = lastNameField.getText().toLowerCase(Locale.ENGLISH);
                            String firstNameValue = firstNameField.getText().toLowerCase(Locale.ENGLISH

PRE

I see that this code violates some OOP principals, <a href="https://en.wikipedia.org/wiki/Single_responsibility_principle" rel="nofollow noreferrer">SRP</a> for instance where a function should have one and only responsibility where this latter does more.

So if I were in your shoes I would split each condition to a function and call 'em all once, so it would be something like this:

MID

private boolean checkFullName(...){
   return !lastNameField.getText().isEmpty() &amp;&amp;
          !firstNameField.getText().isEmpty() &amp;&amp; 
          userRole.getValue() != null &amp;&amp; 
          !emailField.getText().isEmpty() &amp;&amp; 
          !passwordField.getText().isEmpty()
}

private boolean checkPassword(...){
...
}


@FXML
private void createAccount() throws IOException {
if (checkFullName() &amp;&amp; checkPassword() &amp;&amp; ...){
   ...
else{
   pinError()
    }
  }
}


POST

Does this work? would like to hear your thoughts and feedback...

SUBMITTED

str(Ncol))
    mid=Ncol//2
    (substartR,subnrow)=(0,Nrow)
    (substartc1,subncol1)=(0,mid)
    (substartc2,subncol2)=(mid,Ncol-mid+1)
    subproblem=[]
    subproblem.append((substartR,substartc1,subnrow,subncol1))
    subproblem.append((substartR,substartc2

PRE

Now why 3 lines for this:

MID

subproblem=[]
subproblem.append((substartR,substartc1,subnrow,subncol1))
subproblem.append((substartR,substartc2,subnrow,subncol2))


when you can create your list directly:

subproblem= [(substartR,substartc1,subnrow,subncol1),(substartR,substartc2,subnrow,subncol2)]


POST

and last thing, learn about list comprehensions for things like this:

SUBMITTED

Type', 'Text');
                delete(assets);
                set(circles, 'Position', [0 0 0 0]);
            end
        end
    end

    function updateCircle(~, ~)
        if buttonDown
            [x, y] = get_point(ah);
            x0 = x1(circleCount);
            y0 = y1(circleCount);
            xx = (x + x0) / 2;
            yy = (y + y0) / 2;
            r = norm([x-x0, y-y0]) / 2;
            set(circles(circleCount), 'Position', [xx-r yy-r 2*r 2*r]);
            axis ([0 1 0 1]);
        end
    end

    function getEndPoint(~, ~)
        buttonDown = 0;
        [x2(circleCount), y2(circleCount)] = get_point(ah);
        circleCount = circleCount + 1;
        if circleCount &gt; 2
            rawData

PRE

This is a nice little program. But it does have a bug, stemming from your misunderstanding of the <code>deal</code> function. This one is difficult to trigger, though. I'm not surprised you didn't know about it. I'll deal with this at the end.

You make nice use of the MATLAB graphics capabilities, especially <code>hgtransform</code>, which I have not seen used before.

You display pretty good general programming practices, in terms of program structure, function naming, etc.

The one aspect where this program could be improved is the separation of x and y components for the coordinates. This separation leads to several problems in the code:

<strong>Variable names</strong>

They are in general very good, except when you're naming coordinates. You start with <code>x1</code>, <code>y1</code>, <code>x2</code> and <code>y2</code> for the two coordinates that define each circle. Then you use <code>x</code>, <code>xx1</code>, <code>X1</code>, <code>vX</code>, ... and things get a little confusing to me there. I think this stems from the division of x and y components into separate variables. It is the x and y component separation that drives the choice of names, rather than the function of the particular coordinate. If you had kept x and y together in a single variable, you would have been forced to come up with a better naming scheme.

For example, use <code>circle_edge1</code> and <code>circle_edge2</code> for the two points defining each circle, with <code>circle_edge1(1,:)</code> the coordinates for the first point of circle 1, etc. Then <code>xx1</code>, <code>yy1</code>, <code>xx2</code> and <code>yy2</code> could be <code>centers</code>, with <code>centers(1,:)</code> the coordinates for the center of circle 1, etc.

<strong>Code repetition</strong>

In many places you repeat calculations for the x and y component. Using a single variable to hold both components would mean you only write the calculation once (MATLAB automatically "vectorizes" many calculations, make use of that!).

<strong>Length of <code>drawCommonTangent</code></strong>

This function is a little too long to easily follow where <code>xx1</code> and friends go. But with less code repetition this would be solved as well, I think.

As an example for simplification of code as a result of using the more natural coordinate representation, this bit of code from <code>updateCircle</code>:

MID

[x, y] = get_point(ah);
x0 = x1(circleCount);
y0 = y1(circleCount);
xx = (x + x0) / 2;
yy = (y + y0) / 2;
r = norm([x-x0, y-y0]) / 2;
set(circles(circleCount), 'Position', [xx-r yy-r 2*r 2*r]);


could instead be written as

pt2 = get_point(ah); % assuming it returns a single value
pt1 = circle_edge1(circleCount);
center = (pt1 + pt2) / 2;
d = norm(pt1 - pt2) / 2;
set(circles(circleCount), 'Position', [center-d/2, d, d]);


POST

You could also write

SUBMITTED

check_expression(char expression[80], bool&amp; valid

PRE

MID

check_expression(expression, valid);


No, <em>return</em> results. And declare variables where used and initialized:

bool valid = check_expression(expression);


POST

Using “out” parameter instead of returns is bad; for no reason is just horrible. (See <a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#f20-for-out-output-values-prefer-return-values-to-output-parameters" rel="noreferrer">F.20</a>.)

Your parameters taking arrays probably don't mean what you think.  In any case, pass <code>std:string</code> (or <code>string_view</code> which can be especially handy for parsing).

SUBMITTED

h;

        for (int i = 0; i &lt; height; i++) {
            elements.push_back(std::vector&lt;float

PRE

Both of the other answers make some very good points, especially when it comes to replacing vector. Two dimensional vectors are particularly iffy because the whole lump of memory will not be contiguous. If you access <code>elements[y][x]</code> you first have to look in elements[y] for the address of the inner vector, and then have to look into that inner vector. By contrast if you have an array that is say, 4x4, the compiler would typically internally have a single 1D array of length 16. Then to get <code>elements[2][2]</code> it might just grab the entry in offset 11 (i.e. 2*4+3)

There are (at least) three distinct performance advantages associated with this when you think about low level hardware. 

Snowbody mentions templating your <code>Matrix</code> so that you could have different primitive types in it (A matrix of ints or of doubles or whatever). I would further suggest templating your matrix to specify the sizes. Comparing with how <code>std::array</code> is done, where you might have <code>std::array&lt;int, 3&gt;;</code>, you could have <code>matrix&lt;float, 3, 3&gt;</code>. (In fact it would be necessary if you wanted your internal data storage to be a std::array as vnp suggests.)

This again gives the compiler more guarantees about your program ahead of time, which again means it has a better chance of doing helpful optimisations. For example a classic optimisation that compilers might do is "Loop unrolling", whereby they actually rewrite 

MID

for (int i = 0; i &lt; 3; ++i) {
    doSomething();
}


POST

as 

SUBMITTED

gt; map = {1=abcdef, 2=xyz, 9=aaa, 6=xxx

PRE

<strong>Result</strong> 

MID

{1=abcdef, 2=xyz, 9=aaa, 6=xxx}


POST

If you are using Java 8 or lower, you can use :

SUBMITTED

canAddTasks = false;
        while (!taskQueue.isEmpty());
        for

PRE

In my opinion, <code>My...</code> names are useless, don't start with that practice. <code>CustomThreadPool</code> is an acceptable name enough for a test.

MID

while (!taskQueue.isEmpty());


POST

You might want to choose a different form for waiting instead of a busy-loop. Having a <code>Thread.sleep</code> in there would already help, but even better would be to be notified every time a thread finishes its work.

SUBMITTED

cpos += order;
                dump += 2;
            }
        }
    }
    return len / 2 + len &amp

PRE

This did reveal the first bug (so I'm guessing your tests are even less thorough):

This doesn't return what you think it does:

MID

return len / 2 + len &amp; 1;


I think you meant

return len / 2 + (len &amp; 1);


or simply

return (len+1) / 2;


POST

Now we have some tests in place, let's look at the implementation.

The tests for <code>CHECKINVALID == 1</code> are unusual.  Generally, this sort of on/off compilation flag is controlled simply by whether or not it's <em>defined</em>, i.e. using <code>#ifdef</code>.  Moreover, it's risky to duplicate the functional code within the testing option; instead of

SUBMITTED

ShipCollidesWith(std::shared_ptr&lt;CAsteroidBase&gt; aAsteroidBase) const override;
  void ShipCollidesWith(std::shared_ptr&lt;CExplodingAsteroid&gt; aExplodingAsteroid) const override;
  void ShipCollidesWith(std::shared_ptr&lt;CStonyAsteroid&gt; aStonyAsteroid) const override;
};

#endif // APOLLOSPACESHIP_H

PRE

I presume this is your visitor part.

MID

  virtual void ShipCollidesWith(std::shared_ptr&lt;CAsteroidBase&gt; aAsteroidBase) const = 0;
  virtual void ShipCollidesWith(std::shared_ptr&lt;CExplodingAsteroid&gt; aExplodingAsteroid) const = 0;
  virtual void ShipCollidesWith(std::shared_ptr&lt;CStonyAsteroid&gt; aStonyAsteroid) const = 0;


This looks good. Though I would not pass the <code>std::shared_ptr&lt;&gt;</code> part. Just pass the class as a reference. The visitor does not need to know how you are maintaining ownership. So something like this:

  virtual void ShipCollidesWith(CAsteroidBase&amp; aAsteroidBase) const = 0;
  virtual void ShipCollidesWith(CExplodingAsteroid&amp; aExplodingAsteroid) const = 0;
  virtual void ShipCollidesWith(CStonyAsteroid&amp; aStonyAsteroid) const = 0;


POST

Don't see the need for this:

SUBMITTED

from math import sqrt
def list_squared(m, n):
    def D(x):return sum(i**2 for i in range(1,x+1) if not x%i)
    return [[i,D(i)] for i in range(m,n) if sqrt(D(i)).is_integer

PRE

There is no need to go up to the number to know its factor, going up to the sqrt is enough:

MID

def D(x):
    return sum(i**2 + int(((x / i) ** 2 if i * i != x else 0))  for i in range(1, floor(x ** 0.5) + 1) if not x%i)


POST

That should speed up quite a bit the computation if you are dealing with big numbers

SUBMITTED

candidates[rand

PRE

MID

rand()

POST

SUBMITTED

class ApplicationController &lt; ActionController::Base
  protect_from_forgery with: :exception

  helper_method :resource_name, :resource, :devise_mapping, :resource_class, :is_admin?, :is_representative?, :is_shipper?,
    :is_agent?, :is_operation_completed?, :is_fcl_exw?, :is_fcl_exw_info_stage_completed?, :is_fcl_exw_info_requested?, :is_fcl_exw_info_confirmed?,
    :is_pricing_representative?, :is_fcl_exw_quotation_confirmed?



  # Roles detection helpers
  def is_admin?
    current_role == 'admin' ? true : false
  end

  def is_representative?
    current_role == 'representative' ? true : false
  end

  def is_shipper?
    current_role == 'shipper' ? true : false
  end

  def is_agent?
    current_role == 'agent' ? true : false
  end

  def is_pricing_representative?
    current_role == 'pricing_representative' ? true : false
  end



  # Devise helpers
  def resource_name
    :user
  end

  def resource
    @resource ||= User.new
  end

  def resource_class
    User
  end

  def devise_mapping
    @devise_mapping ||= Devise.mappings[:user]
  end


  # Operation helpers
  def is_operation_completed?(operation_id)
    GeneralCargoInfo.find_by(operation_id: operation_id).nil? ? false : true
  end

  # FCL-EXW helpers
  def is_fcl_exw_info_stage_completed?(operation_id)
    FclExwCargoInfo.find_by(operation_id: operation_id).nil? ? false : true
  end

  def is_fcl_exw?(operation_id)
    Operation.find(operation_id).modality == 'FCL - EXW' ? true : false
  end

  def is_fcl_exw_info_requested?(operation_id)
    Operation.find(operation_id).fcl_exw_info_requested
  end

  def is_fcl_exw_info_confirmed?(operation_id)
    Operation.find(operation_id).fcl_exw_info_confirmed
  end

  def is_fcl_exw_quotation_confirmed?(operation_id)
    Operation.find(operation_id).fcl_exw_quotation_confirmed
  end

  private
    def current_role
        current_role = current_user.nil? ? 'Not logged in' : Role.find(current_user.role_id).name 
    end

    def require_new_operation_permission
      check_permission('representative', 'agent')
    end

    def check_permission(*roles)
      unless roles.include? current_role
        flash[:alert] = "Access denied"
        redirect_back(fallback_location: authenticated_root_path)
      end
    end


end

PRE

There is no need to use the prefix <code>is</code> with every method if your method return type is boolean then simply use <code>?</code> at the end of the method name
I replace all the role methods name from <code>is_role?</code> with <code>role?</code> ,i.e <code>is_admin?</code> to <code>admin?</code> etc.
instead of <code>nil?</code> Should use <code>present?</code>

MID

class ApplicationController &lt; ActionController::Base
  protect_from_forgery with: :exception

  helper_method :resource_name, :resource, :devise_mapping, :resource_class, :is_operation_completed?, :is_fcl_exw?, :is_fcl_exw_info_stage_completed?, :is_fcl_exw_info_requested?, :is_fcl_exw_info_confirmed?,:is_fcl_exw_quotation_confirmed?

  ROLES = %w[admin representative shipper agent pricing_representative]
  ROLES.each do |role|
    define_method("#{role}?") { current_role == role }
    helper_method "#{role}?".to_sym
  end

  # Devise helpers
  def resource_name
    :user
  end

  def resource
    @resource ||= User.new
  end

  def resource_class
    User
  end

  def devise_mapping
    @devise_mapping ||= Devise.mappings[:user]
  end


  # Operation helpers
  def is_operation_completed?(operation_id)
    GeneralCargoInfo.find_by(operation_id: operation_id).present?
  end

  # FCL-EXW helpers
  def is_fcl_exw_info_stage_completed?(operation_id)
    FclExwCargoInfo.find_by(operation_id: operation_id).present?
  end

  def is_fcl_exw?(operation_id)
    Operation.find(operation_id).modality == 'FCL - EXW'
  end

  def is_fcl_exw_info_requested?(operation_id)
    Operation.find(operation_id).fcl_exw_info_requested
  end

  def is_fcl_exw_info_confirmed?(operation_id)
    Operation.find(operation_id).fcl_exw_info_confirmed
  end

  def is_fcl_exw_quotation_confirmed?(operation_id)
    Operation.find(operation_id).fcl_exw_quotation_confirmed
  end

  private
    def current_role
        current_role = current_user.nil? ? 'Not logged in' : Role.find(current_user.role_id).name 
    end

    def require_new_operation_permission
      check_permission('representative', 'agent')
    end

    def check_permission(*roles)
      unless roles.include? current_role
        flash[:alert] = "Access denied"
        redirect_back(fallback_location: authenticated_root_path)
      end
    end
end


POST

Note: remove <code>is</code> with other methods as well also if you not consume this helper methods with any of the <code>controllers</code> then move them to <code>view helper</code> 

SUBMITTED

function getWordsWithOnlySpecifiedLetters(array $dictionary, string $letters)
{
    foreach ($dictionary as $key =&gt; $value) {
        if(mb_strlen($value) &gt; mb_strlen($letters)) unset($dictionary[$key]);
    }

    $step = 0;
    $strSplit = preg_split('//u', $letters, null, PREG_SPLIT_NO_EMPTY);
    $result = [];
    foreach ($dictionary as $word) {
        $step++;
        $wordSplit = preg_split('//u', $word, null, PREG_SPLIT_NO_EMPTY);
        sort($wordSplit);
        sort($strSplit);
        if (array_map('mb_strtolower', $wordSplit) === array_map('mb_strtolower', $strSplit)) {
            //echo "All specified letters from $letters are in $word | Step $step&lt;hr&gt;" . PHP_EOL;
            $result[] = $word;
        }
    }

    return $result

PRE

Leveraging something like this technique: <a href="https://stackoverflow.com/a/9032951/2943403">Custom REGEXP Function to be used in a SQLITE SELECT Statement</a> with this intended usage: <code>~.*и.*к.*о.*т.*ҷ.*~u</code>

This, of course, is just a theoretical suggestion -- I haven't tried to do anything like this before.

And definitely remember to sanitize and escape the <code>$needle</code> to be offered to the query for security reasons.

Mostly I am suggesting that you sacrifice memory for speed.  Only the <code>$needle</code> should be modified with character sorting and strtolower actions.  These processes are expected to be &quot;already done&quot; on words prior to being stored in the dictionary.

Here is another post of mine with the same basic logic: <a href="https://stackoverflow.com/a/49951887/2943403">How to best compare these two strings for values even though they are in random order?</a>

If altering the dictionary table structure is unattractive, this is how I would recommend searching for exact character matches in any order:

Code:

MID

function getWordsContainingTheExactSpecifedLetters_inanyorder_nomore_noless(array $dictionary, string $letters, string $encoding = 'UTF-8'){
    $lettersLength = mb_strlen($letters, $encoding);  // call just once and cache
    $lettersSplit = preg_split('//u', mb_strtolower($letters, $encoding), null, PREG_SPLIT_NO_EMPTY);
    sort($lettersSplit);

    $result = [];
    foreach ($dictionary as $word) {
      if(mb_strlen($word, $encoding) == $lettersLength) {
        $wordSplit = preg_split('//u', mb_strtolower($word, $encoding), null, PREG_SPLIT_NO_EMPTY);
        sort($wordSplit);
        if ($wordSplit === $lettersSplit) {
          $result[] = $word;
        }
      }
    }
    return $result;
}


POST

Of course, you will need to change the qualifying condition if you wish to retain larger words that merely contain the letters.

SUBMITTED

String,Student

PRE

MID

.Student

POST

SUBMITTED

Print game-play instructions */
void print_instructions(int **board)
{
  printf("\t\t\t\tWelcome to my Tic Tac Toe game\n\n");
  printf("\t\t\tWhen prompted to make a move, simply enter the number\n\t\t\t     corresponding to a tile of your choosing\n");
  printf("\t\t\t\tThe board will initalize as below: \n");
  printf("\t\t\t\t    Hit ENTER to start playing.\n");
  print_state(board

PRE

Instead of multiple <code>printf()</code> calls, we can <code>puts()</code> a single string to give instructions:

MID

void print_instructions(int **board)
{
    puts("\t\t\t\tWelcome to my Tic Tac Toe game\n\n"
         "\t\t\tWhen prompted to make a move, simply enter the number\n"
         "\t\t\t     corresponding to a tile of your choosing\n"
         "\t\t\t\tThe board will initalize as below: \n"
         "\t\t\t\t    Hit ENTER to start playing.");
    print_state(board);
}


POST

Note that <code>puts()</code> inserts a newline of its own at the end, so we don't supply one there.

SUBMITTED

be converted
   * @return The converted EightsCard
   */
  public EightsCard convert(Card card) {
    if (card != null) {
    EightsCard result = new EightsCard(card.getRank(), card.getSuit());
    return result;
    } 
    return null

PRE

There's a lot to be said for using domain specific types to isolate the decisions you have made about the in memory representations.  Using primitive types like ints, Strings, and so on is a code smell called <a href="http://wiki.c2.com/?PrimitiveObsession" rel="nofollow noreferrer">Primitive</a> <a href="http://blog.ploeh.dk/2011/05/25/DesignSmellPrimitiveObsession/" rel="nofollow noreferrer">Obsession</a>.  Unfortunately, Java doesn't have a great toolkit for introducing new types; there are some libraries that can help if you are willing to introduce new dependencies.

MID

public EightsCard convert(Card card) {
  if (card != null) {
  EightsCard result = new EightsCard(card.getRank(), card.getSuit());
  return result;
  } 
  return null;
}


If you really need to be managing nulls, I would consider teasing these apart into two different ideas

public static EightsCard convert(Card card) {
  if (null == card) {
    // This could reasonably be an AssertionError if you think
    // this _can't_ ever happen
    throw new IllegalArgumentException();
  }
  return new EightsCard(card.getRank(), card.getSuit());
}

public static Optional&lt;EightsCard&gt; convert(Optional&lt;Card&gt; card) {
    return card.map(EightsCard::convert);
}


POST

SUBMITTED

id, Book

PRE

Before I get into the meat of the code review, I need to start by saying the whole concept you're working with seems to be misguided. You keep saying you want to show C programmers what a modern C++ program looks like to "ease" them into C++. But then you deliberately choose <em>not</em> to use modern C++ techniques - and in fact use bad practices.

Your logic for doing so is that you don't want to throw an entire complex Greek essay at them because that would be too much for them to swallow all at once. But that makes no sense. When teaching someone Greek, you don't teach them with an essay in mangled Greek with bad grammar and English words and phrasing mixed in. You teach them with a <em>good</em> Greek essay. If the essay is too complicated for beginners, the solution is not to make it crappy Greek. The solution is to just use a simpler essay.

If you want to teach someone C++ - whether a C programmer or not - you teach them C++. You don't teach them "C with classes".

Your fixation on "familiarity" is completely misguided. Most modern C++ constructs are not only smarter and safer than anything in C, <em>they are easier to reason about and understand</em>. You're actually making C++ <em>harder</em> by regressing to C constructs rather than using modern C++. You don't need to mimic what C code looks like to make a C programmer understand C++, you just need to explain the C++ code... which you should be doing in any case.

So I am going to review the code not just as C++ code, but as C++ <em>intended to be a teaching instrument</em> for people familiar with C.

Let's start with the <code>Book</code> class.

MID

Book

POST

There is not really a good case for making the title, author, and year private members. <code>Book</code> has no real invariants that require protecting the data members. You can't "break" a book modifying the title without modifying the author or year at the same time.

A C programmer would probably write <code>Book</code> as (ignoring the different namespaces in C):

SUBMITTED

if(num_generated == 1)
       move_selected = "rock

PRE

Consider setting up some sort of inheritance structure. If there was a base class <code>Player</code> which <code>HumanPlayer</code> and <code>ComputerPlayer</code> inherited from, it would be easier to write the program flexibly. You could have the same game logic, and swap in different sorts of players for PvP games, CvC simulations, and potentially new additions such as playing against another player on the internet.

MID

move_selected = "rock";


POST

For a problem like this, it's better to use integer (or better still <code>enum</code>) types. Keep strings for when the task is inherently about the text (including text input and output) rather than the thing the text represents. Among other things, strings are expensive to work with and tend to confuse the compiler in places where it would otherwise be able to help point out bugs. 

On the topic of strings, there is a lot of redundancy in <code>whoWon</code>. Consider separating out the logic of working out who won from the logic of displaying it. Every output has the form. 

SUBMITTED

add.close();
ifstream input ;
input.open("abc.dat",ios::in);
int n;
while(!input.eof())
{
input

PRE

The same pattern applies to the number-reading part of the program.

MID

ifstream input ;
input.open("abc.dat",ios::in);


POST

Once again, you need <code>std::</code>, you can do the open with the constructor - you don't need two lines - and you don't need <code>std::ios::in</code> because it's an <code>ifstream</code>.

SUBMITTED

void Game::Stop()
{
    SDL_DestroyWindow

PRE

For <code>Game</code> (disregarding above design changes):

MID

Game::Stop

POST

SUBMITTED

void cFakeWorker::PushJob()
{
    std

PRE

Is there any need for the second include? In any case, including C headers (like <code>&lt;time.h&gt;</code> rather than <code>&lt;ctime&gt;</code>) in C++ is deprecated.

The default constructor seems unnecessary.

With <code>StartFlow()</code>, you don't take into account what should happen if <code>StartFlow()</code> is called twice in a row, or <code>StartFlow(); Terminate(); StartFlow();</code>. That could be intentional; you may intend for doing those things to be undefined behaviour. I'm just warning you.

MID

cFakeWorker::PushJob()

POST

SUBMITTED

id = ((Guid

PRE

MID

Guid

POST

SUBMITTED

in increasingSeriesOfDividers)
            {
                if (divider * divider &gt; inputValue)
                    return false;
                if (inputValue % divider == 0)
                    return true

PRE

There's a lot to be improved here.  What you call <code>dividers</code> would be simply called <code>primes</code>.  This may have loosely been inspired by a sieve, but its inner mechanics are nothing like a sieve.  It's no surprise that performance degrades with larger numbers, and if you go too high, you may run into memory issues since the <code>dividers</code> (or <code>primes</code>) keeps a list in memory.

Performance should also suffer because you check every number from 2 onward.  You could check 2 to eliminate all evens first, and then only check odd numbers after that.

We discourage one line calls here unless enclosed in braces.  So change this:

MID

if (divider * divider &gt; inputValue)
    return false;


To this:

if (divider * divider &gt; inputValue)
{ 
    return false; 
}


POST

You may want to investigate using a sieve.  Here are old examples:

<a href="https://codereview.stackexchange.com/questions/92366/sieve31-my-sieve-of-eratosthenes-returning-ienumerableint">Sieve31, my sieve of Eratosthenes returning IEnumerable&lt;int&gt;</a>

<a href="https://codereview.stackexchange.com/questions/92491/sieve32-a-simple-32-bit-sieve-returning-ienumerableuint-using-c">Sieve32, a simple 32 bit sieve returning IEnumerable&lt;uint&gt; using C#</a>

<a href="https://codereview.stackexchange.com/questions/104736/sieve32fastv2-a-fast-parallel-sieve-of-eratosthenes">Sieve32FastV2 - A fast parallel Sieve of Eratosthenes</a>

SUBMITTED

the nRows

PRE

MID

nRows

POST

SUBMITTED

App() {
  Py_SetProgramName(Py_DecodeLocale("App", NULL));
  Py_Initialize();
  PyRun_SimpleString("import

PRE

The anonymous namespace is to make sure <code>PY_CLASS_NAME</code> is only visible in <code>app.cc</code>.

On to the constructor:

MID

Py_SetProgramName(Py_DecodeLocale("App", NULL));


POST

This is an issue generally, but you're not doing any error checking here. <code>Py_DecodeLocale()</code> can return <code>nullptr</code> if it fails for a number of reasons. You should really check for that, and handle it - probably by throwing an exception.

There's another issue here: resource management. You're doing everything the old-fashioned C way... mostly because the Python library is a C API. Generally when you're using a C API, you should make some proper C++ RAII classes for resource management.

For example, the memory allocated by <code>Py_DecodeLocale()</code> needs to be freed by a call to <code>PyMem_RawFree()</code>... but you never do that.

The smart thing to do is to create a <code>PyMem_RawFree()</code> deleter:

SUBMITTED

n)
{
    for

PRE

MID

for

for (uint element : bustTimeCopy)

POST

SUBMITTED

import os
import fnmatch
import subprocess
import xml.etree.ElementTree as ElementTree
from xml.parsers.expat import ExpatError
import sys
from shutil import copyfileobj


def locate(pattern, root="Z:/Automation/"):
    '''Locate all files matching supplied filename pattern in and below
    supplied root directory.'''
    for path, dirs, files in os.walk(os.path.abspath(root)):
        for filename in fnmatch.filter(files, pattern):
            yield os.path.join(path, filename)


csv_path_unrefined = []
for xml in locate("*.csv"):
    try:
        ElementTree.parse(xml)
    except (SyntaxError, ExpatError):
        csv_path_unrefined.append(xml)
csv_path = []
for paths in csv_path_unrefined:
    if "results" in str(paths):
        csv_path.append(paths)


def check_rule1(path):
    # path = "PWLLOGGER_DEMO.csv"
    file = 'ConsoleApplication9.exe "' + path + '"'
   # print(file)
    details = os.popen(file).read()
    log_file = open("logs/Rule_1.txt")
    state = log_file.read()
    with open('results/Rule_1_log.log', 'a+') as files:
        files.write("\n========" + path + "========\n")
        files.close
    with open('results/Rule_1_log.log', 'a+') as output, open('logs/Rule_1.txt', 'r') as input:
        copyfileobj(input, output)
    if "failed" in state:
        return False
    else:
        return True


rule_1_passed = []
rule_1_failed = []

for paths in csv_path:
    result_r1 = check_rule1(paths)
    # print(result_r1)
    if result_r1 == False:
        rule_1_failed.append(paths)
        #print("Rule 1 has failed for " + paths)
    elif result_r1 == True:
        rule_1_passed.append(paths)
        #print("Rule 1 has passed for " + paths)
    open('logs/Rule_1.txt', 'w').close()


print(rule_1_failed)
print(rule_1_passed

PRE

Really, to answer your question, you need to profile your code. You need to understand what is taking up all that time. Just by looking at your code, it's impossible to tell, but my guess would be that the most time is spent in one of the following places:

Running every <code>*.csv</code> file you run into through the XML parser. I get the feeling you consider this necessary in order to discard XML files that are pretending to be CSV files. Ideally, you should do this once, then properly label your files thenceforth so you don't have to do this check every time. This strikes me as a potentially very expensive thing to do; as such, I've modified this check below so it only occurs when you might actually be interested in the file later on (that is, its path contains 'results')

Kicking off the external process individually for each file you want to check. Launching processes is not a cheap operation. Ideally, you'd want to EITHER launch a single process for each rule, passing it all relevant file paths for it to check all at once, OR if you wrote your rules in Python, you could read each file in exactly once, then process it through all your rules all at once. Launching a new process for each rule, for each file, is probably a huge source of slowness.

There are also several parts of the code that just seem hacky and bad practice. Also, if you use Python 3.5+, you can use <code>glob</code> instead of your custom <code>locate</code> function. In the spirit of reviewing all your code anyway and making any suggestions that seem appropriate, here's how I'd suggest your code be written, though admittedly without any good suggestions about how to speed up the code (because, again, you MUST profile your code to understand what's actually taking the time):

MID

import os
import subprocess
import xml.etree.ElementTree as ElementTree
from xml.parsers.expat import ExpatError
from glob import iglob



def is_xml(path):
    try:
        ElementTree.parse(path)
        return True
    except (SyntaxError, ExpatError):
        return False


def check_rule1(path):
    subprocess.run(['ConsoleApplication9.exe', path])
    state = open("logs/Rule_1.txt").read()

    with open('results/Rule_1_log.log', 'a+') as output:
        output.write("\n========" + path + "========\n")
        output.write(state)
    return "failed" not in state:


def main():
    csv_path = (path for path in iglob('**/*.csv', recursive=True) if 'results' in path and not is_xml(path))
    rules = [check_rule1]

    for rule_num, rule in enumerate(rules):
        rule_num += 1  # We want to count rules from 1 up
        passed = []
        failed = []

        for paths in csv_path:
            result = rule(paths)
            if result:
                passed.append(paths)
                #print("Rule 1 has passed for " + paths)
            else:
                failed.append(paths)
                #print("Rule 1 has failed for " + paths)

            os.remove('logs/Rule_1.txt')

        # Do something with passed/failed, presumably?


if __name__ == '__main__':
    main()


POST

SUBMITTED

to 0b0000

PRE

MID

0b0000

POST

SUBMITTED

lt;string

PRE

MID

string

string const&amp;

POST

SUBMITTED

include "Card.hpp"
#include

PRE

You have <code>std::ostream</code> in the header, but never include anything to get it. You should <code>#include &lt;iosfwd&gt;</code> in the header, and <code>#include &lt;ostream&gt;</code> in the cpp file.

The only reason you need this function to be a friend is because you have no accessor functions for the rank or suit. You should have those, and if you do, this function doesn't need to be a friend.

MID

Card.hpp

POST

SUBMITTED

return _cards[cardNumber - indexOffset];
}

const unsigned int Hand::numberOfCards() const

PRE

As usual, no <code>const&amp;</code>, and choose either <code>int</code> or <code>size_t</code>.

MID

const unsigned int numberOfCards() const;


POST

This should return <code>int</code> or <code>size_t</code>, and should probably be <code>noexcept</code>.

SUBMITTED

lt;T&gt;(this T value

PRE

MID

this T value

POST

SUBMITTED

family: var

PRE

MID

var

POST

SUBMITTED

void transform_word

PRE

MID

transform_word()

POST

SUBMITTED

self.pay = pay
    self.manager = None
    self.start_time = time.strftime("%D @ %I:%M:%S %p")
    Employee.num_of_emps += 1
    Employee

PRE

MID

self.start_time = time.strftime("%D @ %I:%M:%S %p")

POST

SUBMITTED

m_capacity(0),
    m_size

PRE

You might want to look into using <code>std::unique_ptr&lt;T[]&gt;</code> for <code>buff</code>. While this doesn't fix out of bounds memory access, it will help with some of the other issues.

The name changes of <code>push_back</code>, <code>pop_back</code>, <code>cbegin</code> and <code>cend</code> make this container unusable for standard algorithms.

<code>begin</code> and <code>end</code> should provide a <code>const</code> overload, so they can be called on a <code>const Vector&lt;T&gt;&amp;</code>.

Similarly, <code>cbegin</code> and <code>cend</code> should be declared <code>const</code>.

Also, <code>push_front</code>, <code>pop_front</code>, <code>emplace</code>, <code>emplace_back</code>, <code>emplace_front</code>, <code>remove</code>, <code>insert</code> and all the reverse iterator variants are missing.

MID

m_size

POST

SUBMITTED

a,b

PRE

MID

b

POST

SUBMITTED

std::free

PRE

MID

free()

POST

SUBMITTED

n";
    std::cin.get

PRE

MID

std::cin.get();

cin.get()

POST

Now the naming. <em>Most</em> of your identifiers are inappropriate for a real codebase. For example, you have a vector that in a real program would be called something like <a href="https://en.wiktionary.org/wiki/neighbor" rel="noreferrer"><code>neighbors</code></a> or <code>outgoing_passages</code>; you call it <a href="https://en.wiktionary.org/wiki/broom" rel="noreferrer"><code>brooms</code></a>.

Some of your identifiers are at least plausibly related by abbreviation to their actual meanings; for example <code>int tar</code>, which from context clearly means something like <code>int target</code>. But you should still write them out! Remember, we write our C++ code for <em>people</em>, not for machines. (Machines are totally happy reading machine code.) So <code>rnd_room</code> should be <code>random_room</code>; <code>rnumber</code> should be <code>room_number</code> (or just <code>room</code>?), <code>tar_rooms</code> should be <code>target_rooms</code> (or <code>path</code>?), and so on.

Consider introducing a type alias

SUBMITTED

import java.util.ArrayList;
import java.util.List;

public class Main {

    public static void main(String[] args) {

        ArrayList&lt;Person&gt; originalPeople = new ArrayList&lt;&gt;();
        ArrayList&lt;Person&gt; newPeople = new ArrayList&lt;&gt;();

        originalPeople.add(new Person("William", "Tyndale"));
        originalPeople.add(new Person("Jonathan", "Edwards"));
        originalPeople.add(new Person("Martin", "Luther"));

        newPeople.add(new Person("Jonathan", "Edwards"));
        newPeople.add(new Person("James", "Tyndale"));
        newPeople.add(new Person("Roger", "Moore"));

        // Create a list of people that no longer exist in the new list
        for (Person original : originalPeople) {
            if (getPersonInList(
                    newPeople, original.getFirstName(), original.getLastName()) == null) {
                System.out.printf("%s %s is not in the new list!%n",
                        original.getFirstName(), original.getLastName());
            }
        }
    }

    private static Person getPersonInList(
            final List&lt;Person&gt; list, final String firstName, final String lastName) {

        return list.stream()
                .filter(t -&gt; t.getFirstName().equalsIgnoreCase(firstName))
                .filter(t -&gt; t.getLastName().equalsIgnoreCase(lastName))
                .findFirst().orElse(null);
    }
}

class Person {

    private final String firstName;
    private final String lastName;

    Person(String firstName, String lastName) {
        this.firstName = firstName;
        this.lastName

PRE

To find if an object exists in a list, you need to perform a linear search,
potentially visiting every single element, in \$O(n)\$ time.
More efficient data structures exist:

Use an <em>ordered</em> data structure: if the values are sorted, then you can find if an element exists using binary search, in \$O(\log n)\$ time.

Use a <em>hashset</em>: you can find if an element is in the set in constant time, \$O(1)\$

To be to search efficiently, use a hashset instead of a list.
However, to be able to use a hashset efficiently,
it is required that the objects you put in it have appropriate implementation of <code>hashCode</code> and <code>equals</code> methods.

See the <a href="https://docs.oracle.com/javase/tutorial/java/IandI/objectclass.html" rel="nofollow noreferrer">official tutorial on the <code>Object</code> class</a>,
especially the sections on the <code>equals</code> and <code>hashCode</code> methods.
Note that IDEs like IntelliJ and Eclipse can generate these methods for you easily (they are boring to write by hand, and usually there's little reason to do so).

With correct implementation of the <code>equals</code> and <code>hashCode</code> methods,
for example as in the other <a href="https://codereview.stackexchange.com/a/199990/12390">answer</a> by @Teddy,
your main program could be reduced to this:

MID

public static void main(String[] args) {

    Set&lt;Person&gt; originalPeople = new HashSet&lt;&gt;();
    Set&lt;Person&gt; newPeople = new HashSet&lt;&gt;();

    originalPeople.add(new Person("William", "Tyndale"));
    originalPeople.add(new Person("Jonathan", "Edwards"));
    originalPeople.add(new Person("Martin", "Luther"));

    newPeople.add(new Person("Jonathan", "Edwards"));
    newPeople.add(new Person("James", "Tyndale"));
    newPeople.add(new Person("Roger", "Moore"));

    for (Person original : originalPeople) {
        if (!newPeople.contains(original)) {
            System.out.printf("%s %s is not in the new list!%n",
                    original.getFirstName(), original.getLastName());
        }
    }
}


POST

SUBMITTED

x, int y);

    SDL_Texture * mTexture;
    int mWidth;
    int mHeight;
    SDL_Rect mButton;
};

LTexture::LTexture()
{
    mTexture = NULL;
    mWidth = 0;
    mHeight = 0;
}

LTexture::~LTexture()
{
    SDL_DestroyTexture(mTexture);
    mTexture = NULL;
    mWidth = 0;
    mHeight = 0;
}

void LTexture::loadfromSurface

PRE

It is now basically impossible to use <code>LTexture</code> wrong. You can't construct it then forget to initialize it. You can't forget to free it. You can't free it multiple times.

That is what a good, modern C++ type looks like.

MID

LTexture::LTexture()
{
    mTexture = NULL;
    mWidth = 0;
    mHeight = 0;
}

LTexture::~LTexture()
{
    SDL_DestroyTexture(mTexture);
    mTexture = NULL;
    mWidth = 0;
    mHeight = 0;
}


If you follow the advice above, you don't need the default constructor. In fact, you shouldn't have one.

As for the destructor, if you read the blog post about the universal resource class pattern, you know that you need to check <code>mTexture</code> for <code>nullptr</code> before calling <code>SDL_DestroyTexture()</code>. Other than that, there's no real point to setting everything to null and zero. It's just wasting cycles for no purpose.

So the above two functions become:

LTexture::~LTexture()
{
    if (mTexture)
        SDL_DestroyTexture(mTexture);
}


POST

That's all you need.

SUBMITTED

random_values = map

PRE

MID

map

POST

SUBMITTED

int count

PRE

MID

count()

POST

SUBMITTED

n";
cout &lt;&lt; "Type '3a3'to exit... \n";

double a=0 ,b=0;
char op = 'a'; //operator // 'a' is the exit operator, the value of the integers doesn't matter

int ch = 0; //while loop checker

do
{
    cin &gt;&gt; a &gt

PRE

Prefer avoiding global <code>using</code> declarations and prefix the namespace.  Global aliases clutters the global namespace.  Readers actually want to know where identifiers are coming from. Finally, you become vulnerable to argument dependent lookup issues.  If you want to use <code>using</code> declarations, use them as locally as possible to avoid namespace pollution issues.

MID

    double a=0 ,b=0;
    char op = 'a'; //operator // 'a' is the exit operator, the value of the integers doesn't matter


POST

In C++, we typically have one-declaration per line to avoid mistakes related to the C/C++ grammar rules.  That also allows us to have room for descriptive names and additional comments.

Prefer not to introduce a variable before you need to use it. Code becomes safer as variables aren't being used for multiple purposes.  The reader also needs to retain less information on variables from higher scopes.  There are exceptions, like the cost of tearing down and rebuilding an object is expensive when all you want is a reusable buffer for a loop.  

You should reserve comments for statements of intent (why it is done, not what is supposed to be done).  Your comment on the exit condition would be better placed as part of your statement to the user ("'a' is the exit operator. Type any values with 'a' to exit. Example: '3a3'.).

SUBMITTED

map&gt;

namespace roman_int

PRE

Only include what is required to make a file self-sufficient. You don't want to burden users of your code with the bloat of unused code (like <code>&lt;map&gt;</code> and <code>&lt;iostream&gt;</code>) but you don't want users latently including files because you forgot to include something.

<code>&lt;iostream&gt;</code> is a special case.  Many of the implementations of C++ transparently injects static constructors into every translation unit that includes it's library.  You should avoid including <code>&lt;iostream&gt;</code> in headers unless you absolutely need it.  Consider splitting IO related operations from your class or include the minimal amount possible.  In your case, <code>&lt;iosfwd&gt;</code> provides the forward declarations for <code>std::ostream</code> and <code>std::istream</code>.  In the source file, you'll need <code>&lt;iostream&gt;</code> for the definitions to the declarations.

MID

namespace roman_int


POST

Use namespaces for logical structuring as they exist to group together types and functions that are similar.  Maybe you have a namespace for numerics (number systems).  Maybe you have a bunch of roman-related things.  Maybe you have a project-wide workspace of stuff written by you.

SUBMITTED

gt;
using namespace std;

int x

PRE

I see some things that may help you improve your program.

MID

using namespace std

POST

Putting <code>using namespace std</code> at the top of every program is <a href="http://stackoverflow.com/questions/1452721/why-is-using-namespace-std-considered-bad-practice">a bad habit</a> that you'd do well to avoid.  

The code declares and uses 5 global variables.  Global variables obfuscate the actual dependencies within code and make maintainance and understanding of the code that much more difficult.  It also makes the code harder to reuse.  For all of these reasons, it's generally far preferable to eliminate global variables and to instead pass pointers to them.  That way the linkage is explicit and may be altered more easily if needed.  For example, one way to do it would be to gather all of the variables into a <code>struct</code> and pass a reference to the struct to each thread instance.  The structure instance could be a local variable within <code>main</code>.

Since boolean variables <code>evenready</code> and <code>oddready</code> are always in opposite states, one of them is redundant.  In fact, in this case, both are redundant since one can easily derive the same function from the value of <code>x</code>.

This line is somewhat strange:

SUBMITTED

JobQueue&gt;();
                })
                .BuildSessionFactory();
            Session = _sessionFactory.OpenSession();
            Session.FlushMode = FlushMode.Auto

PRE

Create a session from a connection string received in the constructor (Thanks for the recommendation of @Nkosi ).

MID

public void OpenSession()
{
    Session = _sessionFactory.OpenSession();
    Session.FlushMode = FlushMode.Auto;
}


POST

Create an <code>OpenSession()</code> method in our <code>UnitOfWork</code> class

<strong>RepositoryV.cs</strong>

SUBMITTED

final = round(frequency / octave);
    }
    return final

PRE

Notice that I changed the calculation for B from a multiplication to a division so it was the same form as the other calculations. This is possible because raising a number to a negative power is the same as dividing by that number raised to the positive power.

We can use this same trick to calculate <code>final</code> without the <code>if</code> statement, like this:

MID

final = round(frequency * pow(2, octave - 4));


POST

When <code>octave</code> is less than 4, we get a negative number and end up dividing. When it's 0, we get 1 so the multiplication does nothing.

In addition to switching to using a table, you can also remove unnecessary code. For example the <code>if</code> statement you use to check if the user specifically entered A4. That code is unnecessary because you will correctly calculate the value using the rest of your code. Unless this function is being called inside some tight inner loop, its speed isn't a concern, so that optimization is not very helpful.

Your code also has a bunch of <a href="https://en.wikipedia.org/wiki/Magic_number_(programming)" rel="nofollow noreferrer">magic numbers</a>. These are hard-coded values in the code that have no indication what their purpose is. You should create named constants for these. You have one for 440Hz, but the values of the semitone offsets are a bit mysterious. In my code I put them in a table with a name so it's more obvious what they are. But in general, values other than 0 or 1 should have a name. I would also comment the relationship of 2^(numSemitones / 12) as it would be non-obvious to people who haven't studied the physics of Western music.

One other thing I noticed is that in your code you didn't handle the cases of Fb, Cb, E#, or B#. These are valid notes that you'll want to handle. They don't come up often, and they are synonyms (at least in equal temperament) for E, B, F, and C, but they are legit, so I'd recommend handling them. (And if you want to get really technical, you could handle double sharps (Ax4, for example), and double flats (Bbb3, for example).)

SUBMITTED

newsChannel1.SendMessage

PRE

You provide a custom <code>unsubscriber</code> to each listener that subscribes. This seems a bit heavy for my taste. Why not just provide an <code>Unsubscribe</code> method? You now have to cope with additional complexity: 

MID

SendMessage

POST

SUBMITTED

payload interface

PRE

MID

interface

POST

<strong>chat/message.go:</strong>

SUBMITTED

m, d

PRE

MID

d / 3

POST

SUBMITTED

public virtual

PRE

How to provide additional conversion rules in derived classes? You have to add more rules (if default behavior isn't enough) to the conversions dictionary. I think it's then time to <strong>move this logic to a separate class</strong> because it's both reusable and outside <code>FinProductData</code> responsibilities. You may do:

MID

virtual

POST

SUBMITTED

priority].pop

PRE

MID

pop

POST

SUBMITTED

d[0]))
.y(d =&gt; yScale(d[1]))
.curve(d3.curveCardinalClosed) 

// draw sine wave going around a circle
const wave = vis
.append('path')
.attr('d', getPath(rotatedSine))
.attr('fill', 'none')
.attr('stroke', 'black')
.attr('stroke-width', '1px

PRE

Then, you append the path:

MID

const wave = vis.append('path')
  .attr('d', radialGenerator(data))
  .attr('fill', 'none')
  .attr('stroke', 'black')
  .attr('stroke-width', '1px');


POST

Have in mind that my function here is not as complex as yours, which accepts several different parameters: this answer is just to show you the existence of <code>d3.lineRadial()</code>, you can certainly improve it.

Here is the demo:

<div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>const svg = d3.select('svg');
const margin = {
  top: 50,
  right: 50,
  bottom: 50,
  left: 50
};
const width = +svg.attr('width') - margin.left - margin.right;
const height = +svg.attr('height') - margin.top - margin.bottom;

// content area of your visualization
const vis = svg.append('g')
  .attr('transform', `translate(${margin.left+width/2},${margin.top+height/2})`);

// show area inside of margins
const rect = vis.append('rect')
  .attr('class', 'content')
  .attr('width', width)
  .attr('height', height)
  .attr('transform', `translate(${-width/2},${-height/2})`);

// show scales
const xScale = d3.scaleLinear()
  .domain([-100, 100])
  .range([-width / 2, width / 2]);
const yScale = d3.scaleLinear()
  .domain([100, -100])
  .range([-height / 2, height / 2]);
vis.append('g').call(d3.axisTop(xScale));
vis.append('g').call(d3.axisLeft(yScale));

// draw circle
const pi = Math.PI
const radius = 63.66
const circle = vis.append('circle')
  .style('stroke-dasharray', '3, 3')
  .style('stroke', 'black')
  .style("fill", "transparent")
  .attr("r", xScale(radius))
  .attr("cx", 0)
  .attr("cy", 0);

const length = 100;
const amplitude = 20;

const radialGenerator = d3.lineRadial()
  .angle(d =&gt; d.angle)
  .radius(d =&gt; d.radius)
  .curve(d3.curveCardinalClosed)

const radialScale = d3.scaleLinear()
  .domain([0, length])
  .range([0, Math.PI * 2]);

const data = d3.range(length).map(function(d) {
  return {
    angle: radialScale(d),
    radius: xScale(radius) + Math.sin(d) * amplitude
  }
});

const wave = vis.append('path')
  .attr('d', radialGenerator(data))
  .attr('fill', 'none')
  .attr('stroke', 'black')
  .attr('stroke-width', '1px')</code></pre>
<pre class="snippet-code-css lang-css prettyprint-override"><code>svg {
  background-color: steelblue;
}

.content {
  fill: lightsteelblue;
}</code></pre>
<pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;script src="https://d3js.org/d3.v5.min.js"&gt;&lt;/script&gt;
&lt;svg width="1000" height="1000"&gt;&lt;/svg&gt;</code></pre>
</div>
</div>


SUBMITTED

w')
        {
            _direction = 1;
        }
        else if

PRE

MID

if ...else

POST

The pattern matching logic is much easier to see if a <code>swtich</code> statement is used instead of the long <code>if...else</code> chain.  For example, instead of this:

SUBMITTED

naturalWidth
    }

    else

PRE

MID

else

POST

SUBMITTED

least 2 slides */
  $elm.prepend('&lt;ul class="slider-nav"&gt;&lt;/ul&gt;');

  // make a bullet for each slide
  for (var i = 0; i &lt; slidesCount; i++) {
    var bullets = '&lt;li&gt;&lt;a href="#"&gt;' + i + '&lt;/a&gt;&lt;/li&gt;';
    if (i == 0) {
      // active bullet
      var bullets = '&lt;li class="activeSlide"&gt;&lt;a href="#"&gt;' + i + '&lt;/a&gt;&lt;/li&gt;';
      // active slide
      $(slides[0]).addClass('active');
    }
    $('.slider-nav').append(bullets);
  }
};

var Queue = function

PRE

The carousel appears to work acceptably. The code is a bit scattered. Consider the variable <code>activeIdx</code>. It appears to be set in the click handler and referenced in the function <code>setActiveSlide()</code> as a global variable - not as a parameter, but in <code>slideUpDown()</code> it is a parameter.

I'm not convinced the promise queue is absolutely necessary. Perhaps a simple <a href="https://davidwalsh.name/javascript-debounce-function" rel="nofollow noreferrer">debounced function</a> would suffice. 

And there are a lot of repeated DOM queries - remember those are not cheap! Especially in the function <code>advanceFunc()</code>. Instead of querying the DOM so many times, it would be better to store the list items (A.K.A. <code>bullets</code>) in a variable after they are added and re-use them in <code>advanceFunc()</code>. <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Remainder_()" rel="nofollow noreferrer">Modulus division</a> can then be used to determine the next index.

The name of the variable <code>bullets</code> is a bit misleading for a single element. A singular name like <code>bullet</code> would be more appropriate.

And to create each bullet, the <a href="http://api.jquery.com/jQuery/#jQuery2" rel="nofollow noreferrer">jQuery function</a> could be used. So instead of manually constructing the HTML for the list items:

MID

var bullets = '&lt;li&gt;&lt;a href="#"&gt;' + i + '&lt;/a&gt;&lt;/li&gt;';
if (i == 0) {
  // active bullet
  var bullets = '&lt;li class="activeSlide"&gt;&lt;a href="#"&gt;' + i + '&lt;/a&gt;&lt;/li&gt;';


use <code>$('&lt;li&gt;')</code> for the bullet and <a href="http://api.jquery.com/html" rel="nofollow noreferrer">.html()</a> to set the inner HTML:

var bullet = $('&lt;li&gt;').html('&lt;a href="#"&gt;' + i + '&lt;/a&gt;');


POST

Then the class name can be added via <a href="http://api.jquery.com/addclass" rel="nofollow noreferrer"><code>.addClass()</code></a>

SUBMITTED

move',
      ready: function () {
        croppable = true;
        button.onclick = function () {
          var croppedCanvas;
          var roundedCanvas;
          var roundedImage

PRE

It apppears that <code>croppable</code> is set to <code>true</code> in the <code>ready</code> function:

MID

ready: function () {
    croppable = true;
    button.onclick = function () {


POST

While it would be <code>undefined</code> before that line, the <code>onclick</code> function wouldn't be set until after that is set to <code>true</code>, so the following block seems superflous in the <code>onclick</code> function:

SUBMITTED

class Library

PRE

MID

Library

POST

SUBMITTED

Gamepad.handleEvents

PRE

nice job!

Some hints:

<strong>Gamepad.java</strong>

MID

Gamepad

POST

SUBMITTED

for(auto o : stock_observers[stock_name])
    {
        o-&gt;notify(stock_name

PRE

Of course, if you go that route there is little point in having a <code>class Stock</code> anymore.

In this part of your code:

MID

for(auto o : stock_observers[stock_name])
{
    o-&gt;notify(stock_name);
}


You are actually making a copy of each observer. It is almost always better to use a reference when iterating through a container:

for(auto &amp;o : stock_observers[stock_name])
{
    o-&gt;notify(stock_name);
}


POST

SUBMITTED

let current_location

PRE

MID

current_location

POST

SUBMITTED

used for

PRE

MID

for

POST

SUBMITTED

self = Level.level2(avaiableBalls: 20, difficulty: .medium, totalScore: 0)
        case .level3 :
            self = Level.level3(avaiableBalls: 20, difficulty: .hard, totalScore: 0)

        }
    }


    //--------------------------------------------------------------------------------

    //MARK:-   Get  Methdos

    //--------------------------------------------------------------------------------




    func getTotalScore () -&gt; Int {
        switch self {
        case .level1(_,_, let totalScore) :
            return totalScore
        case .level2(_,_, let totalScore) :
            return totalScore

        case .level3(_,_ ,let totalScore):
            return

PRE

See <a href="https://softwareengineering.stackexchange.com/questions/304077/swift-functions-vs-computed-properties">Swift functions vs computed properties</a>
on  Software Engineering for a detailed discussion.

The above applies to all of your <code>getXXX</code> methods.

The <code>getTotalScore()</code> function can be simplified to

MID

func getTotalScore() -&gt; Int {
    switch self {
    case .level1(_, _, let totalScore),
         .level2(_, _, let totalScore),
         .level3(_, _, let totalScore):
        return totalScore
    }
}


since all cases bind the same variable. The same applies to the following
getter methods.

The <code>let</code> preceding the wildcard pattern in

    case .level1(  let _, let  difficulty,   _):


POST

is not needed, and causes a compiler warning.

The explicit conversion to <code>Float</code> in

SUBMITTED

variables
   var

PRE

MID

var

POST

SUBMITTED

userEntry = calculatorOperations

PRE

MID

calculatorOperations

POST

SUBMITTED

int(input

PRE

MID

input()

POST

The only things on the top level of your script should be a <a href="https://stackoverflow.com/q/6908143/96588">shebang line</a> like <code>#!/usr/bin/env python3</code>, imports, class/function definitions, and <a href="https://stackoverflow.com/q/419163/96588">the following</a>:

SUBMITTED

import { Auth } from 'aws-amplify';

const signIn = (
  username,
  password,
  successCallback,
  errorCallback,
) =&gt; {
  Auth.signIn(username, password)
    .then(user =&gt; successCallback(user))
    .catch(err =&gt; errorCallback(err));
};

export default signIn

PRE

I think the test is ok. Remember what you're testing is this

MID

const signIn = (
  username,
  password,
  successCallback,
  errorCallback,
) =&gt; {
  Auth.signIn(username, password)
    .then(user =&gt; successCallback(user))
    .catch(err =&gt; errorCallback(err));
};


POST

and NOT <code>Auth</code>. Here Auth is just a dependency so you will stub its functionality. Considering that its interface is Promise-based, you need to test both cases - therefore having a test that verifies your expected (promise solved) and the one with the error is correct.

There are some changes I would add, though. For instance, rather than creating my own <code>successCallback</code> and <code>errorCallback</code> I would use <a href="https://jestjs.io/docs/en/jest-object.html#jestfnimplementation" rel="nofollow noreferrer">mock functions</a>, that would allow me to have further information

SUBMITTED

by Astar

PRE

MID

Astar

Your <code>Point</code> class is specifically made for the A* algorithm. It then makes sense have it part of the namespace of the <code>Astar</code> class. Just move it inside the latter:

class Astar {
    public:
    class Point {
        ...
    };

    ...
};


However, the class <code>Astar</code> is problematic in itself:

Your class <code>Astar</code> is both the map and the methods to perform the A* algorithm. In a real application, the map is some datastructure used by many algorithms, and you want the A* algorithm to work on that datastructure. So it is much more natural to have a <code>class Map</code>, and a function <code>Astar(...)</code> that takes a <code>Map</code>, and the start and endpoints as arguments, and returns the resulting path.

Your class requires you to do things in three stages:

Astar

POST

SUBMITTED

return unsortedList;
    }

    private static void SwapUpwards(List&lt;long&gt; list, int indexToSwap)
    {
        long temporalValueHolder = list[indexToSwap];
        list[indexToSwap] = list[indexToSwap + 1];
        list[indexToSwap + 1] = temporalValueHolder;
    }

    private static void SwapDownwards(List&lt;long&gt; list, int indexToSwap)
    {
        long temporalValueHolder = list[indexToSwap - 1];
        list[indexToSwap - 1] = list[indexToSwap];
        list[indexToSwap] = temporalValueHolder

PRE

These methods seem superfluous:

MID

  private static void SwapUpwards(List&lt;long&gt; list, int indexToSwap)
  {
    long temporalValueHolder = list[indexToSwap];
    list[indexToSwap] = list[indexToSwap + 1];
    list[indexToSwap + 1] = temporalValueHolder;
  }

  private static void SwapDownwards(List&lt;long&gt; list, int indexToSwap)
  {
    long temporalValueHolder = list[indexToSwap - 1];
    list[indexToSwap - 1] = list[indexToSwap];
    list[indexToSwap] = temporalValueHolder;
  }


as it's just a matter of calling a general <code>Swap</code> function with the right indices.

In my opinion it is wrong to have a static method that takes a list of data, sort it and return a reference to it:

public static List&lt;long&gt; SortAscending(List&lt;long&gt; unsortedList)
{
  ...
  return unsortedList;
}


POST

I would expect the input argument list to be left untouched and that the method returns a new sorted list. The <code>IEnumerable&lt;T&gt;.OrderBy()</code> works like that and on the other hand <code>List&lt;T&gt;.Sort()</code> sorts the current instance, and returns <code>void</code>.

I would choose either to return void and sort the argument list or return a sorted copy of the original list.

It is always a good idea to be precise and descriptive when it comes to naming of variables and methods, and it is always a question of habits and conventions. In my opinion your naming of the variables in these algorithms is too "verbose" and they make two rather uncomplicated algorithms look more complicated than necessary. 

Below I've refactored the algorithms in respect to naming, DRY-principle, and I have tried to generalize them as generic extension methods:

SUBMITTED

m_Title;
    GLFWimage m_Icon[1];
    int m_Width, m_Height

PRE

This makes it clear that you are providing a GLFW window, and it avoids conflicts with other libraries that might expose a class with the same name. It will also provide a nice home for any other classes that you might need to add, if your goal is to provide full coverage of GLFW's functions.

Instead of:

MID

int m_Width, m_Height;


Just write:

int m_Width;
int m_Height;


It generally is easier to read and to modify. Also, if things belong together, such as:

int m_PosX, m_PosY;


POST

Maybe they should be put into their own class or struct, like:

SUBMITTED

userInput,menu

PRE

However, there is an even better way:

MID

menu

POST

Manually specifying all four pointers is cumbersome, and it is easy to confuse the four directions. It is also not necessary to store four pointers, there is quite a bit of redundancy in them. It is better to write a constructor that just takes one pointer called <code>parent</code>, and have the class <code>menu</code> have a vector of pointers to child menus, like so:

SUBMITTED

el) {
  this

PRE

Don't add what is not needed. You define an object <code>makeSticky</code> and give it 13 exposed (public) properties. When you instantiate it you immediately drop the reference so that the only code that can access the object, is its self, making all the properties and supporting code redundant..

By the looks you only ever create this object in one place, so there really is no need for it to be named in the global scope. And as the object is not referenced elsewhere it can exist as just a closure over the <code>onScroll</code> listener.

When writing you should be constantly aware of what is needed and by what.

MID

this

POST

As only the <code>onScroll</code> event listener needs access to the elements all the following examples use closure to maintain the reference. There is no named object for what you called <code>makeSticky</code>

Short and simple

SUBMITTED

in range

PRE

MID

range

POST

SUBMITTED

n");
}
void mergeSort(int

PRE

MID

int mergeSort()

void mergeSort(int *, int, int)

POST

SUBMITTED

regNum;

book

PRE

Each <code>book</code> has its own <code>Scanner</code>, as does <code>books</code>, every <code>student</code>, and <code>students</code>, and the <code>Library</code>.  This is <em>A Really Bad Idea</em>™.  A <code>Scanner</code> can buffer many, many characters that it has read from the underlying input stream but not presented to the caller.  Having more than one <code>Scanner</code> can lead to strange behaviour, where it looks like the input is getting lost, or arriving in the wrong order.  Having 103 scanners (one for each of the 50 <code>book</code> instances, one for each of the 50 <code>student</code> instances, plus one each for the <code>books</code>, <code>students</code>, and <code>Library</code> instances) will make scanner input issues virtually impossible to debug.

Create only one <code>Scanner</code>, in the <code>Library</code> class, and pass that instance to any method that needs to perform any reading.

MID

book

POST

The <code>book</code> class is a data model.  It should just store information; it should not perform any I/O operations on the Console.  Doing so prevents it from being used in a GUI application.  If we remove the I/O, it could be used in a Console application or a GUI application without modification.  Here is the <code>Book</code> class without any I/O:

SUBMITTED

ranges: list

PRE

MID

list

POST

SUBMITTED

minute condition

PRE

MID

condition

POST

As for <code>findPair</code> you declare <code>std::string pair_Values</code> assign many times values, but never use it.

I have probably forgotten things and I haven't analyzed the logic of the program too much. I think you should turn to the few links I posted to improve your skills. Also, you should learn how to use the standard library, the different types and algorithms. Try to compile with all warnings and pedantic enabled, <a href="https://akrzemi1.wordpress.com/2018/01/24/help-the-compiler-warn-you/" rel="nofollow noreferrer">help the compiler to helping you</a>.

SUBMITTED

c = getchar

PRE

MID

getchar

POST

SUBMITTED

dirtyrects.append(screenrect)

            # Changing brush size:
            if event.button == 4 and r &lt; 100:
                r += 1
                dirtyrects.append(screenrect)
            elif event.button == 5 and r &gt; 2:
                r -= 1
                dirtyrects.append(screenrect)

        if event

PRE

This:

MID

if event.button == 4 and r &lt; 100:
    r += 1
elif event.button == 5 and r &gt; 2:
    r -= 1


is unclear for me. To understand what those <code>4</code> and <code>5</code> mean I had to go to documentation. What you could do is to use <a href="https://docs.python.org/3/library/enum.html#enum.IntEnum" rel="nofollow noreferrer"><code>enum.IntEnum</code></a>. And it would be something like this:

from enum import IntEnum
...
class MouseWheel(IntEnum):
    UP = 4
    DOWN = 5
...
if event.button == MouseWheel.UP and brush_size &lt; max_size:
    brush_size += size_delta
elif event.button == MouseWheel.DOWN and brush_size &gt; min_size:
    brush_size -= size_delta


POST

Finally, you use lots of <code>tuple</code>s for mouse position or sizes of rectangles. I think it's worth to check out <a href="https://www.pygame.org/docs/ref/math.html?highlight=vector#pygame.math.Vector2" rel="nofollow noreferrer"><code>pg.Vector2</code></a>.

SUBMITTED

nonborder_edge_count;
            }
        };
        auto is_over_satisfied = [border_edge_count, nonborder_edge_count, is_border_index](node&amp; n) {
            if (is_border_index(n.index)) {
                return n.filled_count &gt; border_edge_count;
            } else {
                return n.filled_count &gt; nonborder_edge_count;
            }
        };
        auto node_cmp = [is_border_index, border_edge_count, nonborder_edge_count](const node&amp; lhs, const node&amp; rhs) {
            bool is_lhs_border = is_border_index(lhs.index);
            bool is_rhs_border =  is_border_index(rhs.index);
            auto required_lhs = is_lhs_border ? border_edge_count : nonborder_edge_count;
            auto required_rhs = is_rhs_border ? border_edge_count : nonborder_edge_count;
            return lhs.filled_count * required_rhs &gt; rhs.filled_count * required_lhs;
        };


        std::vector&lt;node&gt; nodes(node_count);
        const std::size_t nonborder_count = nodes.size() - border_count;
        const std::size_t

PRE

Nit: You spell it <code>oversatisfied</code> in the error message, but <code>over_satisfied</code> (two words) in the function name. Pick a spelling and stick to it! (I recommend <code>oversatisfied</code>, one word.)

MID

    auto node_cmp = [is_border_index, border_edge_count, nonborder_edge_count](const node&amp; lhs, const node&amp; rhs) {
        bool is_lhs_border = is_border_index(lhs.index);
        bool is_rhs_border =  is_border_index(rhs.index);
        auto required_lhs = is_lhs_border ? border_edge_count : nonborder_edge_count;
        auto required_rhs = is_rhs_border ? border_edge_count : nonborder_edge_count;
        return lhs.filled_count * required_rhs &gt; rhs.filled_count * required_lhs;
    };


Because this lambda is only ever used in one place, you can move its definition in-line. And because it doesn't escape upward from the current scope, you don't need it to capture anything by-copy. Lambdas that are used as callbacks (but do not escape upward) should always capture <code>[&amp;]</code> and nothing else. So:

    std::sort(head, nodes.end(), [&amp;](const node&amp; lhs, const node&amp; rhs) {
        bool is_lhs_border = is_border_index(lhs.index);
        bool is_rhs_border =  is_border_index(rhs.index);
        auto required_lhs = is_lhs_border ? border_edge_count : nonborder_edge_count;
        auto required_rhs = is_rhs_border ? border_edge_count : nonborder_edge_count;
        return lhs.filled_count * required_rhs &gt; rhs.filled_count * required_lhs;
    });


Finally, we can remove some error-prone code duplication by factoring out the "key function." I haven't really thought this through, but I think the following is equivalent to what you had. (It's tricky because you were multiplying parts of <code>lhs</code> with parts of <code>rhs</code>. I'm not intuitively convinced that the function you had defined a consistent ordering at all!)

    auto key = [&amp;](const node&amp; n) {
        return n.filled_count * (is_border_index(n.index) ? nonborder_edge_count : border_edge_count);
    };
    std::sort(head, nodes.end(), [&amp;](const node&amp; lhs, const node&amp; rhs) {
        return key(lhs) &gt; key(rhs);
    });


Alternatively, pull out each sort-predicate and give it a descriptive name. For example, instead of

    std::sort(nodes.begin(), nodes.end(), [](const node&amp; lhs, const node&amp; rhs) {
        return lhs.index &lt; rhs.index;
    });


I might write

    auto by_index = [](const node&amp; lhs, const node&amp; rhs) { return lhs.index &lt; rhs.index; };
    // ...
    std::sort(nodes.begin(), nodes.end(), by_index);


POST

Rigorously following this style can force you to clarify your thinking process. When you sort using the predicate above — the one with the multiplication involving <em>both</em> <code>lhs</code> and <code>rhs</code> — what are you sorting <em>by</em>? If you can't name it, you probably don't understand it.

SUBMITTED

ConcurrentLinkedList() {
        _end = _root = new

PRE

MID

_root + _end

POST

SUBMITTED

Console.ReadLine();
        }
    } while (repeat.ToLower().Contains("yes

PRE

you use <code>repeat.ToLower()</code> every time you use <code>repeat</code> so why not lower it once:

MID

repeat = Console.ReadLine()?.ToLower();


POST

When it comes to the overall structure you should think about splitting the code into meaningful methods. The program has three major parts:

and because you allow the user to enter more than one text it must run in a loop like:

SUBMITTED

print('Player one enter your name')
    p1 = input()
    print('Player two enter your name')
    p2 = input()
    print('Computer Player? [Y/N]')
    c1 = input()

print(p1, "Guess a Number between 1 and 100")
p1Guess = int(input())
if playerAmount == 1 and c1 != "y":
    while p1Guess != numToGuess:
        p1NumOfGuess += 1

        if p1Guess &lt; numToGuess:
            print("Guess is to Low!""\n""Guess Again")
            p1Guess = int(input())

        elif p1Guess &gt; numToGuess:
            print("Guess is to High!""\n""Guess Again")
            p1Guess = int(input())

    print("Congrats", p1Guess, "is correct!")
    print(p1, 'took', p1NumOfGuess, 'guesses to guess

PRE

This removes 3 copies of the "Player 1 game" code, 1 copy of the "Player 2 game" code, 1 copy of the "Computer game" code.

However, "Output score" will become more complex, as we will need to distinguish between the combinations of players when we compute who wins.  Still, it looks like a significant reduction in code is possible.

The guessing code for player 1 follows.  The code for player two and the computer is similar.

MID

p1Guess = int(input())
while p1Guess != numToGuess:
    p1NumOfGuess += 1

    if p1Guess &lt; numToGuess:
        print("Guess is to Low!""\n""Guess Again")
        p1Guess = int(input())

    elif p1Guess &gt; numToGuess:
        print("Guess is to High!""\n""Guess Again")
        p1Guess = int(input())

print("Congrats", p1Guess, "is correct!")


Here, I see 3 places where a guess is input <code>p1Guess = int(input())</code>.  The first is outside the loop, which is why you have the awkward initialization to <code>1</code> at the start of the code.  We can improve this code by starting the count at 0, inputting the guess at exactly one point in the code, and incrementing the count when the guess occurs.

numToGuess = random.randint(1, 100)
print(p1, "Guess a Number between 1 and 100")

p1NumOfGuess = 0

while True:
    p1Guess = int(input())
    p1NumOfGuess += 1

    if p1Guess &lt; numToGuess:
        print("Guess is too Low!\nGuess Again")

    elif p1Guess &gt; numToGuess:
        print("Guess is too High!\nGuess Again")

    else:
        print("Congrats", p1Guess, "is correct!")
        break


Player two game code would look similar, but contained in an <code>if playerAmount == 2:</code> block.

The computer game code would also look similar, but with the <code>preLow</code> and <code>prevHigh</code> variables.

if c1 == 'y':

    numToGuess = random.randint(1, 100)

    print("Computer is guessing")

    prevLow = 1
    prevHigh = 100
    c1NumOfGuess = 0

    while True:
        c1Guess = random.randint(prevLow, prevHigh)
        c1NumOfGuess += 1
        time.sleep(1.25)

        if c1Guess &lt; numToGuess:
            print(c1Guess, "\nGuess is too Low!\nGuess Again")
            prevLow = c1Guess + 1    # Slight boost to the computer AI

        elif c1Guess &gt; numToGuess:
            print(c1Guess, "\nGuess is too High!\nGuess Again")
            prevHigh = c1Guess - 1   # Slight boost to the computer AI

        else:
            print("Congrats", c1Guess, "is correct!")
            break


POST

Scoring.  First, you are printing out the number of guesses for each player.  Like the above, you always print out player one's guess count, but only need to print out player two's and the computer's if they actually played. 

SUBMITTED

_bv);
          maximize

PRE

MID

maximize

POST

SUBMITTED

Vec3 { float

PRE

MID

float

Whilst the current use-case requires <code>float</code>, we might want to convert to a template in future, so that we could use with <code>double</code> or <code>long double</code>.  We can ease that by defining a type alias, so there's less work to change when we do so:

using value_type = float;


POST

If we implement unary <code>operator-()</code> for <code>FreeVector</code>, we can use that to implement subtraction in terms of addition (without loss of efficiency).

Instead of writing <code>std::sqrt(x * x + y * y + z * z)</code>, we could use <code>std::hypot()</code> instead for an algorithm that remains stable for very large and very small values.  Since C++17, there's an overload that takes all three inputs:

SUBMITTED

m

PRE

MID

m

POST

SUBMITTED

e);
    compArrayIndex++;
  } else {
    if

PRE

MID

else if

} else { if (currentArray) {

} else if (currentArray) {

POST

SUBMITTED

t_hashtable     *hashtable_alloc_table

PRE

In <code>hashtable_alloc_table()</code>, the argument is called <code>size</code>, but the units aren't clear. My assumption on reading the declaration was that it was going to be in bytes. But it's actually the number of entries to hold. As such, I would name it <code>numEntries</code> rather than <code>size</code> because <code>size</code> is ambiguous.

The difference between <code>hashtable_dealloc_table()</code> and <code>hashtable_destroy_table()</code> is surprising given their names. It seems like <code>hashtable_dealloc_table()</code> should be renamed to <code>hashtable_shrink_table()</code> or something more in line with what it's doing.

The name <code>hashtable_check_load_factor()</code> is also misleading. I wouldn't expect a function which is named &quot;check &quot; to change anything. I would call it something like <code>hashtable_set_appropriate_load_factor()</code> or something like that so that a caller knows that it may change the hash table.

Finally, what does the prefix <code>ft</code> stand for? It's not at all clear from the code you posted. A comment about its meaning somewhere might be appropriate.

MID

hashtable_alloc_table()

POST

There's a memory leak in 'hashtable_alloc_table()<code>. If the table is allocated, but the bucket list isn't, it returns </code>NULL`, but it never frees the table. That memory  is now considered in-use by the OS making it unavailable to be re-used.

Why have the caller pass in a pointer to a pointer to <code>hashtable_realloc_table()</code>, and then return a pointer to a hash table? You should do one or the other. A pointer  to a pointer allows you to change the value of the pointer the caller uses, so you don't need to also return the new one. You can simply delete the old one and replace it with the new one.

I think you have too much info in your function comments. Why should I care which functions you call from that function? I shouldn't need to know that info. I shouldn't need to know which headers include the functions that any given function depends on. They should simply be included at the top of the file (which they aren't here).

The problem with comments is that they can get out of date with the code. That has happened with your <code>hashtable_realloc_table()</code> function. It says that it &quot;Grows the hash table by half&quot;, but it actually doubles the hash table size. Perhaps it used to only grow it by half, but now it doubles it?

I have no idea what &quot;search tags&quot; are in this context, and it seems unnecessary. I either already know what to search for or I don't. If I search for the function name, I'll find the function definition, so I don't need the tag.

You say:

<em>Note: I implement my own standard library functions</em>

<b>Oh <i>Heck</i> no!</b> The original implementors of the standard library <a href="https://en.wikipedia.org/wiki/C_standard_library#Concepts,_problems_and_workarounds" rel="nofollow noreferrer">made  all kinds of mistakes in how they designed</a> the standard library functions. Your implementations likely have all those same mistakes plus a whole bunch more due to the fact that you're a beginner at this. It's an interesting exercise to learn the language, but you shouldn't use them in real code.

SUBMITTED

module DayOnePartTwo where

    import System.IO
    import Data.Maybe

    inputFileName = "input.txt"

    input :: String -&gt; [Integer]
    input contents = toNum (cleanNumbers (splitNumbers contents))
        where 
            cleanNumbers strs = map removeLeadingPlus strs
            splitNumbers string = words string
            toNum numbers = map read numbers
            removeLeadingPlus str = if str !! 0 == '+' then tail str else str

    accumulate :: [Integer] -&gt; [Integer]
    accumulate list = accumulator list 0
        where
            accumulator :: Num a =&gt; [a] -&gt; a -&gt; [a]
            accumulator (x:xs) state = (x + state) : accumulator xs (x + state)
            accumulator [] state = []

    duplicate :: [Integer] -&gt; Maybe Integer
    duplicate list = dup list [0]
        where
            dup (x:xs) visited =
                if elem x visited
                    then Just x
                    else dup xs (x:visited)
            dup [] _ = Nothing

    firstCyclicDuplicate :: [Integer] -&gt; Maybe Integer
    firstCyclicDuplicate list = duplicate (accumulate cycledList)
        where
            cycledList = cycle list

    main :: IO ()
    main = do
        contents &lt;- readFile inputFileName
        case (firstCyclicDuplicate (input contents)) of
            Just a -&gt; print (show a)
            Nothing -&gt; print "There is no first duplicate

PRE

MID

module DayOnePartTwo where

import Data.Set (Set)
import qualified Data.Set as S

inputFileName = "input.txt"

input :: String -&gt; [Integer]
input = map (read . removeLeadingPlus) . lines
  where
    removeLeadingPlus ('+':s) = s
    removeLeadingPlus s = s

freqs :: [Integer] -&gt; [Integer]
freqs = scanl (+) 0

firstDuplicate :: [Integer] -&gt; Maybe Integer
firstDuplicate list = dup list S.empty
  where
    dup (x:xs) visited =
      if x `S.member` visited
        then Just x
        else dup xs (S.insert x visited)
    -- This will never be reached on the cycled list
    dup [] _ = Nothing

firstCyclicDuplicate :: [Integer] -&gt; Maybe Integer
firstCyclicDuplicate = firstDuplicate . freqs . cycle

main :: IO ()
main = do
  contents &lt;- input &lt;$&gt; readFile inputFileName
  case firstCyclicDuplicate contents of
    Just a -&gt; print a
    Nothing -&gt; print "There is no first duplicate"


POST

SUBMITTED

lt;int, int&gt; frequencyMap;
  for (int i = 0; i &lt; n; i++) {
    auto mapIt

PRE

MID

for (int i = 0; i &lt; n; i++) {


POST

This is great if your for loop is two lines long. But if the loop grows and becomes more complex then searching for all instances of <code>i</code> becomes a pain because of all the false positives.

Believe me just because your loop only covers two lines today, in ten years after thousands of bug fixes it will not look as neat. So give me something that is easy to search for in the code base.

I know a lot of people like using <code>i</code> as a loop variable. But this is a hold over from <code>Foortran</code>. Please use longer identifiers it will not cost you that much and the maintainer will not hunt you down with an axe.

SUBMITTED

yyyy");
            else

PRE

MID

else

POST

SUBMITTED

BigDecimal getRiskSurcharge() {
        final int unsupportedLocationRisk = 502;
        final int startMinimumLocationRisk = 100;
        final int endMinimumRangeLocationRisk = 299;
        final int startMaximumLocationRisk = 300;
        final int endMaximumRangeLocationRisk = 501;

        if(this.getRiskValue() &gt;= unsupportedLocationRisk)
            return Risk.getUnIdentifiedRiskSurcharge();

        if(this.getRiskValue() &lt; startMinimumLocationRisk)
            return MINIMUM_LOCATION_RISK_SURCHARGE;
        if(Risk.isWithinRange(this.getRiskValue(), startMinimumLocationRisk, endMinimumRangeLocationRisk))
            return MEDIUM_LOCATION_RISK_SURCHARGE;
        if(Risk.isWithinRange(this.getRiskValue(), startMaximumLocationRisk, endMaximumRangeLocationRisk))
            return MAXIMUM_LOCATION_RISK_SURCHARGE;

        return Risk.getDefaultRiskSurcharge

PRE

Your model classes are also doing the calculating and that hurts.

I've been trying to understand the code for a while now and that's the main point I keep coming up with.

MID

@Override
public BigDecimal getRiskSurcharge() {
    if(this.userRiskValue &gt; 200)
        return Risk.getUnIdentifiedRiskSurcharge();

    final int minAcceptableBlackSpots = 3;
    final int maxAcceptableBlackSpots = 12;

    if(Risk.isWithinRange(this.noOfBlackSpots, minAcceptableBlackSpots, maxAcceptableBlackSpots))
        return Risk.getDefaultRiskSurcharge(); 

    return Risk.getUnIdentifiedRiskSurcharge();
}


This does not belong in a Banana.

This is your business logic. It goes in the processor or parts thereof.

When I look at the Processor itself, then I also see something strange: 

public BigDecimal calculateSingleProductPremiumForUser() {
    BigDecimal userRiskSurcharge = user.getRiskSurcharge();
    if(Risk.getUnIdentifiedRiskSurcharge().compareTo(userRiskSurcharge)==0)
        return Risk.getUnIdentifiedRiskSurcharge();

    this.product.setRiskValue(this.user.getRiskValue());
    BigDecimal productRiskSurcharge =this.product.getRiskSurcharge();
    if(Risk.getUnIdentifiedRiskSurcharge().compareTo(productRiskSurcharge)==0)
        return Risk.getUnIdentifiedRiskSurcharge();

    if(Risk.getDefaultRiskSurcharge().compareTo(productRiskSurcharge)==0)
        return this.product.getSubTotalPremium();

    BigDecimal totalPremium = this.product.getSubTotalPremium().multiply(this.product.getRiskSurcharge()).multiply(user.getRiskSurcharge());
    return totalPremium;
}


POST

Given a User (which was provided via the constructor) and a Product (which may be null)...

Actually, let's stop there for a moment.

Why can product be null?

Here's one of your tests, with the code of functions inlined.

SUBMITTED

toString

PRE

Since <code>elements</code> is never reassigned, it would be good to make it <code>final</code>,
so that you cannot reassign by mistake.

MID

toString

POST

Keep in mind that <code>toString</code> is not intended for "pretty-printing".

And for printing the content of the heap,
this implementation doesn't look useful to me.
With the <code>null</code> values removed,
the structure of the heap is not visible,
and without the structure, the ordering of the elements is meaningless,
which can be misleading.

For printing the content of the heap I would suggest adding a dedicated method,
keep the <code>null</code>s, and print values of the first <code>size</code> elements.

SUBMITTED

defn lazily-find-prime-factors [n]
  (letfn [(rec [remaining remaining-primes]
            (when-let [small-prime (and (&gt; remaining 1)
                                        (smallest-factor-of? remaining remaining-primes))]
              (lazy-seq
                (cons small-prime
                      (rec (long (/ remaining small-prime))
                           (drop-while #(not= % small-prime) remaining-primes))))))]
    (rec n (primes

PRE

... reads wrongly. I've called it <code>divides-by?</code>.

I end up with ... 

MID

(defn lazily-find-prime-factors [n]
  (letfn [(rec [remaining remaining-primes]
            (when (&gt; remaining 1)
              (let [rp (drop-while #(not (divides-by? remaining %)) remaining-primes)
                    small-prime (first rp)]
                (lazy-seq (cons small-prime
                            (rec (quot remaining small-prime) rp))))))]
   (rec n (primes))))


POST

Factoring the problem this way, you can easily plug in an efficient way of generating primes. 

SUBMITTED

foreach (var parentFolder in Model)
{
Stack&lt;Folder&gt; folderStack = new Stack&lt;Folder&gt;();
folderStack.Push(parentFolder);
var currentFolder = folderStack.Pop();
int dummyCounter = 1;

//Parent folder
@Html.Partial("_Folder", parentFolder);

&lt;div class="collapse" id="@currentFolder.Id"&gt;

    @if (currentFolder.FoldersContained != 0)
    {
        do
        {
            //Prevents a copy of the parent folder 
            //otherwise, this display nested folders
            if (dummyCounter != 1)
            {
                @Html.Partial("_Folder", currentFolder);
            }

            &lt;div class="collapse" id="@currentFolder.Id"&gt;
                @if (currentFolder.FoldersContained &gt; 0)
                {
                    for (int i = currentFolder.FoldersContained; i &gt; 0; i--)
                    {
                        //Pushes all nested directories into my stack
                        //in reverse inorder to display the top directory
                        folderStack.Push(currentFolder.Folders[i - 1]);
                        dummyCounter++;
                    }
                }

                @if (currentFolder.FilesContained != 0)
                {
                    // Should they contain any files, display them
                    foreach (var file in currentFolder.Files)
                    {
                        @Html.Partial("_File", file);
                    }
                }
            &lt;/div&gt;

            //Ends the while loop
            if (folderStack.Count == 0)
            {
                dummyCounter = 0;
            }

            //Prepares the next nested folder object
            if (folderStack.Count != 0)
            {
                currentFolder = folderStack.Pop();
            }

        // I make use of a dummy counter inorder to break the loop
        // should there no longer be any nested directories and files
        // left to display
        } while (dummyCounter != 0);
    }

    &lt

PRE

like so  

MID

@foreach (var parentFolder in Model)
{

    Stack&lt;Folder&gt; folderStack = new Stack&lt;Folder&gt;();
    folderStack.Push(parentFolder);

    @while (folderStack.Count &gt; 0)
    {

        var currentFolder = folderStack.Pop();
        @Html.Partial("_Folder", currentFolder);

        &lt;div class="collapse" id="@currentFolder.Id"&gt;

            @for (int i = currentFolder.FoldersContained; i &gt; 0; i--)
            {
                //Pushes all nested directories into my stack
                //in reverse inorder to display the top directory
                folderStack.Push(currentFolder.Folders[i - 1]);
            }

            // Should they contain any files, display them
            @foreach (var file in currentFolder.Files)
            {
                @Html.Partial("_File", file);
            }

        &lt;/div&gt;

    }
}


POST

I know that this isn't exactly the same as you had before (the most outer <code>&lt;div class="collapse" id="@currentFolder.Id"&gt;</code> is missing) but it is much clearer and easier to read. If you need this <code>div</code>'s I would suggest to just use a separate method to process the contained folders and files of the parentFolders. 

SUBMITTED

int

PRE

MID

int

POST

SUBMITTED

include &lt;stdlib.h&gt;
#include &lt;ncurses.h&gt;
#include &lt;stdint.h&gt;
#include &lt;inttypes.h&gt;
#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;
#include &lt;limits.h&gt;

#define DECSTR_UINT64_MAX_LENGTH 20

int my_strto64(uint64_t *dest, const char *input_str);

int main(void) {
    char tmp_str[DECSTR_UINT64_MAX_LENGTH + 1]; // for input prior to parsing (+1 for NUL)
    uint64_t height, width, length;
    // length + 1 (NUL character)
    char* total_string = calloc(DECSTR_UINT64_MAX_LENGTH + 1, 1);

    if (!total_string) {
        errno = ENOMEM;
        perror("Unable to allocate memory");
        return errno;
    }

    initscr();
    printw("--- Volume Calculator --\n");
    printw("Enter length: ");
    getnstr(tmp_str, DECSTR_UINT64_MAX_LENGTH);
    if(!my_strto64(&amp;length, tmp_str)) {
        errno = EIO;
        perror("Unable to scan length");
        return errno;
    }

    printw("Enter width: ");
    getnstr(tmp_str, DECSTR_UINT64_MAX_LENGTH);
    if(!my_strto64(&amp;width, tmp_str)) {
        errno = EIO;
        perror("Unable to scan length");
        return errno;
    }

    printw("Enter height: ");
    getnstr(tmp_str, DECSTR_UINT64_MAX_LENGTH);
    if(!my_strto64(&amp;height, tmp_str)) {
        errno = EIO;
        perror("Unable to scan length");
        return errno;
    }

    int return_value = sprintf(total_string, "Total: %" PRIu64, height * length * width);
    // sprintf returns a negative value if it fails, so check it
    if (return_value &lt; 0) {
        errno = EIO;
        perror("Cannot multiply height * length * width");
        return errno;
    }
    printw(total_string);

    free(total_string);

    refresh();
    getch();
    endwin();
    return 0;
}

/**
 * Converts input_str to uint64_t -&gt; returns 0 on success
 * Adapted from: https://codereview.stackexchange.com/a/206773/78786
 */
int my_strto64(uint64_t *dest, const char *input_str) {
  char *endptr;
  errno = 0;
  unsigned long long parsed_long_long = strtoull(input_str, &amp;endptr, 10);
  #if ULLONG_MAX &gt; UINT64_MAX
  if (y &gt; UINT64_MAX) {
    uint64_t *dest = UINT64_MAX;
    errno = ERANGE;
    return errno;
  }
  #endif
  *dest = (uint64_t) parsed_long_long;
  if (errno == ERANGE) {
    return errno;
  }

  // `strtou...()` function wraps with `-`
  // lets return an error if its negative
  if (*dest &amp;&amp; strchr(input_str, '-')) {
    *dest = 0;
    errno = ERANGE;
    return errno; // negative, we don't want it
  }

  if (input_str == endptr) {
    errno = EDOM;
    return errno; // unsuccessful at converting, still *char
  }

  while (isspace((unsigned char) *endptr)) endptr++;

  if (*endptr) {
    errno = EIO;
    return errno; // contains invalid characters
  }

  return (int) parsed_long_long

PRE

<code>unsigned long long</code> is guaranteed to hold at least 64 bits.  If you are using <code>strtoull()</code>, then limiting yourself to <code>uint64_t</code> is just asking for trouble with no benefit.  In fact, your conditional code in <code>#if ULLONG_MAX &gt; UINT64_MAX</code> doesn't even compile: there is no such variable <code>y</code>.

<strong>What does the return value of <code>my_strto64()</code> represent?</strong>  Sometimes, it's an error code.  But if there was no error, then it's the <code>parsed_long_long</code>‽  And the <code>parsed_long_long</code> is cast as an <code>int</code> for some reason?  That doesn't make sense at all.

In the <code>main()</code> function, if any of the calls to <code>my_strto64()</code> fails, then you terminate the program without calling <code>endwin()</code>, <strong>leaving the terminal in a bad state</strong>.

Realistically, <code>sprintf()</code> is not going to fail in a way that would result in a negative return value.  What could possibly go wrong with writing some string to a buffer that has already been allocated?  If it's buffer overflow — and <strong>you do have a buffer overflow problem</strong>, because your <code>total_string</code> doesn't have enough space to contain <code>"Total: "</code> —, then it's likely to either segfault or fail silently.  (To guard against the segfault, you could use <code>snprintf()</code>, but a full buffer would result in a <em>positive</em>, not negative, return value.)  If it's integer overflow from the multiplication, then it won't detect it either, since the multiplication is simply done modulo 2<sup>64</sup>.  (Unlike <code>sprintf()</code>, <code>printf()</code> might fail, if it tries to write to <code>STDOUT</code> and it is closed.  I suppose that <code>printw()</code> could fail too, but you never check for those errors — and I wouldn't bother either.)

Labelling the output as a "total" is a bit weird to me, since it implies that it's a sum rather than a product of the inputs.  (Airline luggage rules often place a limit on the length + width + height of an item, for example.)

It is customary to put <code>main()</code> at the end, to avoid needing to write forward declarations.

I suggest putting the <code>#include</code>s in alphabetical order.

The code for reading the three dimensions is <strong>repetitive</strong>.  Furthermore, it looks like you have a <strong>copy-and-paste</strong> error, since all three error messages are the same.  You should define a helper function.

Using <code>calloc()</code> to allocate a string of a short, limited length is not worth the trouble.  Putting it on the stack would be fine.  But I wouldn't bother with composing <code>total_string</code> at all — just have <code>printw()</code> format the string for you.

MID

#include &lt;ctype.h&gt;
#include &lt;errno.h&gt;
#include &lt;inttypes.h&gt;
#include &lt;limits.h&gt;
#include &lt;ncurses.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

// Generous estimate of the maximum number of digits
// https://stackoverflow.com/a/10536254
#define ULL_DIGITS (3 * sizeof(unsigned long long))

/**
 * Prints a prompt then reads an unsigned long long, using ncurses.
 * Returns 1 on success.  Returns 0 on failure, with errno set to
 * ERANGE, EDOM, or EIO.
 */
int ask_ull(unsigned long long* result, const char *prompt) {
    char buf[ULL_DIGITS + 1];
    char *endptr;
    printw("%s", prompt);
    getnstr(buf, ULL_DIGITS);
    *result = strtoull(buf, &amp;endptr, 10);
    if (errno == ERANGE) {                      // Overflow or underflow
        return 0;
    }
    if (endptr == buf || strchr(buf, '-')) {    // Unsuccessful conversion
        errno = EDOM;
        return 0;
    }
    while (isspace(*endptr)) endptr++;
    if (*endptr) {                              // Trailing junk
        errno = EIO;
        return 0;
    }
    errno = 0;
    return 1;
}

int main(void) {
    unsigned long long height, width, length;
    char *errmsg = NULL;

    initscr();
    printw("--- Volume Calculator --\n");

    if (!errmsg &amp;&amp; !ask_ull(&amp;length, "Enter length: ")) {
        errmsg = "Unable to scan length";
    }
    if (!errmsg &amp;&amp; !ask_ull(&amp;width, "Enter width: ")) {
        errmsg = "Unable to scan width";
    }
    if (!errmsg &amp;&amp; !ask_ull(&amp;height, "Enter height: ")) {
        errmsg = "Unable to scan height";
    }
    if (errmsg) {
        refresh();
        endwin();
        perror(errmsg);
        return 1;
    }

    unsigned long long volume = length * width * height;
    printw("Volume: %llu", volume);

    refresh();
    getch();
    endwin();
}


POST

SUBMITTED

game, if

PRE

MID

if

POST

However, the line is strange for another reason: it doesn't follow your usual indentation. Let's fix that:

SUBMITTED

badCharacterShifts = BuildBadCharacterShifts

PRE

MID

BuildBadCharacterShifts

POST

SUBMITTED

Rows() int {
    return b.rows
}

func (b *board) Columns() int {
    return b.columns
}

func (b *board) PrettyPrint() {
    for i := range b.state {
        for j := range b.state[i] {
            print(" " + strconv.Itoa(b.state[i][j]) + "")
        }
        println()
    }
}

func nextStateForCell

PRE

MID

for i := range b.state {
    for j := range b.state[i] {
        print(" " + strconv.Itoa(b.state[i][j]) + "")
    }
    println()
}


Becomes:

for i := range b.state {
    for j := range b.state[i] {
        fmt.Printf(" %d ", b.state[i][j])
    }

    fmt.Println()
}


POST

Notice that you also avoid <code>strconv.Itoa()</code>.

SUBMITTED

int n

PRE

To expand a bit on what Rick and t3chb0t already said, here are some specific things that hurt the readability of your code:

MID

n

POST

SUBMITTED

TIC_TAC_TOE_020120180815

#include

PRE

This is definitely much improved over the previous version.  Good job!  There may still some things that might be improved.

MID

#include

The <code>#include &lt;vector&gt;</code> line is not necessary and can be safely removed.

#include

POST

Because <code>main</code> refers to <code>std::runtime_error</code> it should have <code>#include &lt;stdexcept&gt;</code>.

The <code>std::find</code> used in <code>board_full</code> is not bad, and as a practical matter, no human will ever notice the difference between it and a faster mechanism, but the simpler method is to simply keep a turn counter.  If the number of turns is 9, then either someone just won or it's a tie.  That would reduce the code to this:

SUBMITTED

c] */
                        goto

PRE

This won't work without further modification to the details of the loop, but for help on that, see the next suggestion.

The logic of this code could be expressed as a state machine.  If that were done, one could process the stream &quot;on the fly&quot; character at a time with little difficulty.

MID

goto

POST

Generally speaking, the use of <code>goto</code> is not recommended.  Using it as you have, for breaking out nested loops is about the only accepted use.  See <a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Res-goto" rel="nofollow noreferrer">ES.76</a> for details.  In this case, however, you can avoid it entirely as shown in the next suggestion.

The use of vectors of vectors of strings is not a very efficient structure for this program.  I would suggest that using an <code>unordered_map</code> would be a better choice and would allow you change the convoluted triple loop at the end of the program to this:

SUBMITTED

include "queue.h"
#if !defined bool
typedef unsigned char bool;
#endif

extern int queue_init(queue_t* q

PRE

Instead of:

MID

#if !defined bool
typedef unsigned char bool;
#endif


POST

just do

SUBMITTED

new Regex(@"Host: (((?&lt;hostName&gt;.+?):(?&lt;port&gt;\d+?))|(?&lt;hostName&gt;.+?))\s+",
                RegexOptions.Compiled);
    public TrafficMonitor

PRE

New pattern:

MID

@"Host: (?&lt;hostName&gt;[^:\s]+)(:(?&lt;port&gt;\d+))?"


Here is a cheap and cheerful demo: <a href="https://regex101.com/r/NqSJ8L/1/" rel="nofollow noreferrer">https://regex101.com/r/NqSJ8L/1/</a>

Note, my above pattern could be massaged a few different ways.  For instance, you might use <code>^</code> and an <code>m</code> pattern modifier to anchor the pattern to the start of the line of text.  Again, I don't program in C, so I don't know if there are incapatabilities with certain pattern entities.

Or instead of a negated character class, you can list the valid character for a hostname:

@"Host: (?&lt;hostName&gt;[\w.-]+)(:(?&lt;port&gt;\d+))?"


P.s. It just occurred to me that my optional pattern will not always deliver a named capture group for the port, so if you don't want to write code to check that the port capture group is generated, here is OhMyGoodness's commented pattern without the trailing whitespace matching.  <code>(?&lt;= )</code> is a lookbehind. <code>(?: )</code> is a non-capturing group.

Host: (?&lt;hostName&gt;[\w.-]+):?(?&lt;port&gt;(?:(?&lt;=:)\d+)?)


POST

SUBMITTED

append(ch);
  }

  bool operator==(const kbasic_string&amp; other)
  {
    return std::equal(begin

PRE

...oh, I see, your <code>data_</code> is a <code>char[23]</code>, not a <code>char *</code>. Well, okay. I would strongly recommend making it a <code>union</code> of <code>char[23]</code> and <code>char *</code> so that you can copy the pointer member without weird type-punning tricks.

Pedantic nit: Setting all-bits-zero is not technically the same thing as setting to <code>nullptr</code> — the in-memory representation of <code>nullptr</code> need not be all-bits-zero (even though, in practice, it will be).

Also, notice that to be <em>allocator-aware</em> you will have to store a pointer of type <code>std::allocator_traits&lt;Allocator&gt;::pointer</code>, which you <em>definitely</em> cannot assume is all-bits-zero when it's null! For example, <code>boost::interprocess::offset_ptr&lt;char&gt;</code> is not all-bits-zero when it's null.

MID

bool operator==(const kbasic_string&amp; other)


Here and throughout, you forgot the trailing <code>const</code>. These days I recommend making every operator an "ADL friend" non-member:

friend bool operator==(const kbasic_string&amp; other, const kbasic_string&amp; other) {
    return std::equal(begin(), end(), other.begin(), other.end());
}


POST

Then it's really obvious if you forget one of the two <code>const</code>s.

SUBMITTED

nextNode);

        if (head == myCurrentNode

PRE

MID

head == myCurrentNode

POST

SUBMITTED

start = self._start
        self

PRE

MID

self._start

POST

SUBMITTED

delay)
  }
}

window

PRE

MID

window

POST

SUBMITTED

Do Work

PRE

This comment suggests that the code isn't yet finished (and therefore not ready for review).

MID

   // Do Work.


POST

Moreover, it suggests that the loop will only ever execute a single, fixed block of code, which makes it very inflexible.  Instead, we should allow the caller to provide the work to be done:

SUBMITTED

if(/^Host

PRE

MID

Host

POST

SUBMITTED

flatmap_detail::sort_together

PRE

MID

sort_together

POST

In the majority of cases (size >= 3), two tests are performed: <code>right - left == 2</code> and <code>right - left &gt;= 3</code>.  Test for <code>&gt;= 3</code> first.

Instead of <code>if (...) { /* nothing to do */ } else</code>, use the negation operator:

SUBMITTED

local local_repo

PRE

MID

$local_repo

POST

SUBMITTED

out memory
    data_obj.incoming_message = &quot;&quot;
    data_obj.shared_secret1 = 0
    data_obj.shared_secret2 = 0
    data_obj.total_length = 0
    data_obj.final_swap1 = 0
    data_obj.final_swap2 = 0
    data_obj.pre_data = &quot;&quot;
    data_obj.post_data = &quot;&quot;
    data_obj.multiple1 = 0
    data_obj.multiple2 = 0
    data_obj.end_arr1 = 0
    data_obj.end_arr2

PRE

That is a lot of code, and I don't have a clue what is should be doing. But then neither does the machine you run it on.

It is full of repeated and redundant code.

Removing comments and whitespaces trimmed 200+ lines.

Compacting code by removing needless line breaks, using ternary operators, using functions to do repeated code, removing switch statement in favour of array lookups, I was down to 600 lines and there was a lot left to cut out.

You basically have more than half the content (1200 lines in the question snippet) that contributes nothing to the functionality. I estimate that the whole thing can be written in less than 400 lines, be easier to read and maintain, and run more efficiently.

Don't declare length variables in <code>for</code> loops, that optimization became history a decade ago.

Use <code>for of</code> loops in favour of <code>for ; ;</code> loops

Remove useless code. You have labels and variable declarations that are never used.

JavaScript requires semicolons, use them unless you know every edge case where ASI can catch you out. if you don't know what ASI is then use semicolons!

Some bad (evil) coder one day missed the old spaghetti days when <code>goto</code> was all the rage. But <code>goto</code> had such a bad reputation nobody would accept its use anymore. So he came up with <code>continue</code> and <code>labels</code> and thus <code>goto 10</code> became <code>continue label</code>

<code>continue</code> is a hack, a <code>goto</code> in disguise, a hard to see break in flow. I have written a zillion lines of code and have never needed to use <code>continue</code> or declare a label in released code.

If a function is more than a page long, its too long.

Use <code>const</code> for variable that do not (and thus should not) change.

Removing code via comments is a bad habit. Good code does not have any code inside comments. (Granted there is reason during testing and development to temp out code with comments, but when done it should be removed)

JavaScript uses <code>camelCase</code> and if you write JS so should you.

Sign that an array is in order. If you have variables named <code>end_arr1</code>, <code>end_arr2</code>, <code>end_arr3</code> it's a sure sign that it should be an array.

The following code

MID

data_obj.shared_secret1 = 0
data_obj.shared_secret2 = 0
data_obj.final_swap1 = 0
data_obj.final_swap2 = 0
data_obj.multiple1 = 0
data_obj.multiple2 = 0
data_obj.mac1 = 0
data_obj.mac2 = 0


POST

is repeated again and again. So much code can be removed if you used an array and indexed the 1,2

SUBMITTED

sum = n1v + n2v + alpha;

            decimal f = sum / (decimal)10;
            alpha = (int

PRE

method.

At the very least, rename <code>Run</code> to <code>add</code>, and do not <code>CreateNumber</code>s in it, but pass them as parameters.

Since it is guaranteed that every node contains a <em>digit</em>, the sum may never exceed 19. This means, among other things, that there is no need for <code>decimal</code>. Everything can be done with primitive types, e.g.

MID

    alpha = sum &gt; 10;
    sum -= alpha * 10;


POST

As a side note, the entity you call <code>alpha</code> is traditionally called <code>carry</code>.

The <code>do {} while()</code> approach seems to create more problems than it solves. An immediate manifestation is duplication of <code>n1 != null</code> tests. Consider

SUBMITTED

sorted(sorted

PRE

MID

sorted

Now I have the feeling that the sorting behaviour of Python already does what you want. No need to extend it. In fact, sorting tuples in Python already uses multiple stages in that it sort on the first element first, then on the second element, then on the third, if any, and so on:

&gt;&gt;&gt; sorted([(1, 2, 3), (4, 5, 6), (1, 1, 1), (2, 2, 2), (4, 4, 4), (2, 1, 2), (2, 1, 0)])
[(1, 1, 1), (1, 2, 3), (2, 1, 0), (2, 1, 2), (2, 2, 2), (4, 4, 4), (4, 5, 6)]


POST

So you can leverage this behaviour to implement yours: just have the key argument of <code>sorted</code> return a tuple of all the keys for each item, and let Python sort those tuples:

SUBMITTED

EntireRow.Copy Sheets("OpRows_Mo_copy").Cells(1, 1).End(xlUp)(1)

'~~&gt; End 1

'~~&gt

PRE

Get rid of <code>.End(xlUp)(1)</code> after <code>.Cells(1,1)</code>. It's not accomplishing anything. 

MID

Sheets("OpRows_Mo_copy").Cells(1, 1).End(xlUp)(1)

Sheets("OpRows_Mo_copy").Cells(1, 1)

POST

Indent code inside blocks. After using <code>For</code>, <code>For Each</code>, <code>Do While</code>, <code>With</code>, etc., your next lines shouldn't be spaced with the same left margin.

SUBMITTED

gt;keys[keycode] = is_down; }
    void set_mouse_state(int button, bool is_down) { this-&gt;mouseB = is_down; }

    friend class Engine;
};

#endif

PRE

Both <code>message</code> and <code>filepath</code> could be passed by <code>const std::string &amp;</code> instead.  

In the following code:

MID

void set_mouse_state(int button, bool is_down) { this-&gt;mouseB = is_down; }


POST

the <code>button</code> parameter is never used and could be eliminated.

SUBMITTED

GameSetup(&amp;game);

    while (game.win == 0) {

        if (game.turn == 0) {

            PlayerOneMove(&amp;game);
            // RandomComputerMoveTwo(&amp;game);

            game.turns++;
            game.turn = 1;
        }

        else {

            RandomComputerMove(&amp;game);

            game.turns++;
            game.turn = 0;
        }

        DrawUpdatedGrid(&amp;game);

        GameEventWon(&amp;game);
        GameEventDrawn(&amp;game

PRE

My advice: Prefer expressive code over comments, because over the lifetime of a program (with bugfixes, refactorings and new features) comments and code tend to get out of sync.

You could refactor

MID

if (game.turn == 0) {
    PlayerOneMove(&amp;game);
    game.turns++;
    game.turn = 1;
}
else {
    RandomComputerMove(&amp;game);
    game.turns++;
    game.turn = 0;
}


to

if (game.turn == 0)
    PlayerOneMove(&amp;game);
else
    RandomComputerMove(&amp;game);
game.turns++;
game.turn = !game.turn;


POST

Currently you handle all errors locally by calling <code>exit(EXIT_FAILURE);</code>. That works well for this program and keeps the error handling code small.<br>
For larger programs you might prefer returning error codes and handling the errors in the main loop because it gets harder to reason about a program with many functions that might call <code>exit()</code>.

I like your example where <code>1 1</code> places a <code>Z</code> on the board. IMHO something like <code>1 2</code> would be a little bit more helpful because it shows that the order is <code>&lt;row&gt; &lt;column&gt;</code>.

I don't see <a href="https://en.wikipedia.org/wiki/Camel_case" rel="nofollow noreferrer">PascalCase</a> (<code>GameEventDrawn()</code>) very often for function names in C. Usually snake_case or lowerCamelCase are used.  

Last not least I want to repeat myself:<br>
I really like how readable your program is.  

SUBMITTED

export tmpdir=("$_TMPDIR$path")

if ssh

PRE

MID

tmpdir=("$_TMPDIR$path")

tmpdir="$_TMPDIR$path"

POST

SUBMITTED

gt;count

PRE

MID

count

POST

SUBMITTED

main

PRE

MID

main

POST

SUBMITTED

blank:]]*\)server_names_hash_bucket_size

PRE

MID

server_names_hash_bucket_size

POST

SUBMITTED

validation failed
    mov var5, rax                        ; save a reference to the file handle for later (taking advantage of the unused parameter slot 5)
    jmp readFileHeader                   ; skip to read file header
readFileBody:
    xor eax, eax                         ; TODO: something useful with the number

PRE

Honestly, the biggest use of <code>LEA</code> in assembly code is as a fancy way to do general-purpose  integer arithmetic on non-address values, since it can perform addition with multiple operands, add <em>and</em> scale (by limited powers of two), simulate a three-operand instruction, and not clobber the flags. You will need it for scaled loads of addresses, but again, there, you're using its fancy address-calculation machinery, not simply to load an offset.

<strong>Use the non-volatile registers</strong> (<code>RBX</code>, <code>RBP</code>, <code>RDI</code>, <code>RSI</code>, and <code>R12</code> through <code>R15</code>) <strong>to store temporary values that you need to persist across function calls.</strong> The calling convention requires the contents of these registers to be persisted across calls, so anything you have in them will be safe. This abundance of registers on x64 allows you to avoid storing to the stack, and gain a bit more speed. So, replace:

MID

mov var5, rax                        ; save a reference to the file handle for later (taking advantage of the unused parameter slot 5)


POST

with something like:

SUBMITTED

y") {
                printf

PRE

Or better yet...

MID

printf

POST

SUBMITTED

Defining Main Game Functions, variables, etc.
board = [0,1,2,
         3,4,5,
         6,7,8]
win_con = [[0,1,2],[3,4,5],[6,7,8],
            [0,3,6],[1,4,7],[2,5,8],
            [0,4,8],[2,4,6]] # possible 3-in-a-rows
def show():
    print(board[0],'|',board[1],'|',board[2])
    print('----------')
    print(board[3],'|',board[4],'|',board[5])
    print('----------')
    print(board[6],'|',board[7],'|',board[8])
def x_move(i):
    if board[i] == 'X' or board[i] == 'O':
        return print('Already taken!')
    else:
        del board[i]
        board.insert(i,'X')
def o_move(i):
    if board[i] == 'X' or board[i] == 'O':
        return print('Already taken!')
    else:
        del board[i]
        board.insert(i,'O')    
# Main Game Loop
while True:
    turn_num = 1
    board = [0,1,2,3,4,5,6,7,8]
    print('Welcome to Tic-Tac-Toe!')
    print('AI not implemented yet

PRE

You probably forgot to test for this, but there's a bug in your program.

MID

def x_move(i):
    if board[i] == 'X' or board[i] == 'O':
        return print('Already taken!')
    else:
        del board[i]
        board.insert(i,'X')
def o_move(i):
    if board[i] == 'X' or board[i] == 'O':
        return print('Already taken!')
    else:
        del board[i]
        board.insert(i,'O')


For starters, you should move this into a single function which takes the player as argument. This way a single function can be used for both players and this will save you from having to fix the bug twice. Code duplication is bad.

An obvious, not necessarily pretty, solution:

def any_move(i, player_character):
    if not isinstance(board[i], int):
        return print('Already taken!')
    else:
        del board[i]
        board.insert(i, player_character)


POST

This checks whether the value picked on the board is an integer. If it's not, it has already been taken by either X, O or whatever player characters you're using at that moment.

But the real problem is this will skip a turn on invalid input. If I pick 4 with X in one turn and pick the same tile with O a turn later, O will be missing out a turn. I imagine there should be a loop in there checking whether valid input has been inserted yet. If not, stay in the loop. If valid input is inserted, make the actual move.

I'm talking about valid input here, not just whether the input is 0 - 8. Your program will crash if I enter something invalid, like <code>b</code> or <code>11</code>. The first is not an integer and the second is out of range. It crashes on no input (just hit enter) as well. You should at least capture those exceptions.

SUBMITTED

_repo.SaveAll

PRE

MID

SaveAll()

POST

You're not catching any exception, if anything happens with the repository then API calls will fail with an internal server error.

You parse the current user ID in many functions, move it out to a separate function. Also do not use <code>Int32.Parse()</code> without specifying the culture you want to use (probably <code>CultureInfo.InvariantCulture</code>).

Do not use <code>UserParams</code> both in your repository and in your controller. It <em>smells</em> because:

ALWAYS validate and translate request parameters (and the easiest way is to have two separate objects). For example <code>userParams.Gender</code> is directly exposed to your repository as an unvalidated string.

<code>UpdateUser()</code> (and <code>LikeUser()</code>) does not actually need the user ID as parameter. Do not require useless and redundant data from the client (which must be validated) when you already have it server-side.

Do not compare strings using <code>==</code> unless you exactly know what it means. In this case an even simpler and faster ordinal comparison is enough however...

Do not store the gender as a string. If your app is limited to binary genders (at birth) then you may use an <code>enum</code>, however...

<em>Gender</em> is much more <em>complex</em> than a simple binary identity:

In short: do not use an hard-coded list and do not assume gender equals sexual orientation.

If your app will be successful then you definitely want to avoid to search the <code>likes</code> table (which will grow much faster than the <code>users</code> table) for an entry and to retrieve it only to return <em>Bad request</em>. Best case scenario is to have a simpler function to determine if the entry exists instead of reading, transmitting and mapping the entry itself. See also the next section...

I'm generally against the indiscriminate use of the Repository pattern. It's an invaluable tool but the price you pay in complexity to use it (properly) must be justified. I do not see the <em>big picture</em> here but you should seriously consider if directly using your ORM is <em>enough</em>. From what I see you really need a domain model, much more than a repository.

You have an instance field <code>_repo</code>, you do not show that code but I do not see any synchronization mechanism and I do not see how you dispose its resources when controller is re-created. Generally, in your controllers, you should avoid instance fields as much as possible.

Your API should never ever work directly with the repository to perform any business logic. It should interact with an high-level model (or a Service layer on the top of the Data layer exposed by your ORM). For example I'd imagine the <em>Like</em> feature like this:

SUBMITTED

export class SuppressInfoPipe implements PipeTransform {

  transform(valueToSupress: string, unSuppressedCount?: number): string {


    let suppressedOutput = '';

    const valueToRemainUnsuppressed =
    valueToSupress.substring(valueToSupress.length - unSuppressedCount, valueToSupress.length);

    let astariskLength = valueToSupress.length - unSuppressedCount;

    for ( let i = 0; i &lt; astariskLength; i++) {
     suppressedOutput = suppressedOutput.concat('*');
    }
    suppressedOutput = suppressedOutput.concat(valueToRemainUnsuppressed);

    return suppressedOutput

PRE

I would avoid the for loop to generate the "suppressed string".

My approach would be:

MID

export class SuppressInfoPipe implements PipeTransform {

  transform(valueToSupress: string, unSuppressedCount = 0): string {
    const suppressedCount = valueToSupress.length - unSuppressedCount;
    const valueToRemainUnsuppressed =
    valueToSupress.substring(suppressedCount, valueToSupress.length);

    return Array(suppressedCount + 1).join('*') + valueToRemainUnsuppressed; // suppressedCount + 1: since join will a string of length "suppressedCount"
  }
}


POST

In this case:

SUBMITTED

line, text);
  }

  @Override
  public void undo() {
    this.textPad

PRE

MID

@Override
public void undo() {

}


To have a empty method is totally valid, but it is better to leave it with a comment

@Override
public void undo() {
    // nothing to do here
}


POST

The benefits are that as a reader, I know that you are aware that you are not implementing it, and that you will know in the future that you have not forgotten the implementation.

SUBMITTED

NoS)
    ListOfScores = []
    ProbsOfScores = []
    for

PRE

In python we prefer to phrase that as <code>score += 1</code>.

The name <code>calc_exp</code> surprisingly turns out to relate to expectations,
rather than <code>math.exp</code> or exponentials.

This is a bit cumbersome:

MID

ListOfScores = []
ProbsOfScores = []


POST

Better to store a single list of (score, prob) tuples.
It would simplify some manipulations farther down in the function,
including allowing you to finish with <code>return sum( ... )</code>.

Consider writing code that depicts how a given configuration of matchsticks turned out, with
markings of the 1-, 2-, &amp; 3-cell regions.
This would facilitate manual checking of your results for a couple of particular configurations.

In a similar vein, unit tests using very small number of matchsticks wouldn't hurt.

Run <a href="http://flake8.pycqa.org/en/latest/" rel="nofollow noreferrer"><code>flake8</code></a>.
Follow its instructions.
This will make your code more easily understood by people who interact with it.

SUBMITTED

extends Block

PRE

MID

Block

Block

POST

SUBMITTED

command =input

PRE

MID

input

POST

SUBMITTED

map.erase

PRE

MID

erase()

POST

When I've wanted to provide something like the <code>exists()</code> here, I've made it a standalone template function that can work with many kinds of container:

SUBMITTED

shared.delegate

PRE

MID

delegate

POST

SUBMITTED

Math.floor(Math.random() * 7) + 3;

        for (let i = 0; i &lt; 17; i++) {
            if (i

PRE

Or better yet, have an array of Players. Try to code your game so that it does not matter how many players there are. (E.g iterate through the list of players).

Your colours could be made into an ENUM, or a class with score, colorName, colorCode.

I'd suggest declaring some variables at the top, to make maintenance easier.
Such as key div elements (hiScoreTable). (Or even just the ids of the elements).
Images.

Try to avoid 'maigc numbers' by using named variables. For example, what is '17' here?:

MID

for (let i = 0; i &lt; 17; i++) 


POST

Avoiding 'magicNumbers' also decreases code duplication and makes maintenance easier. For example, to increase player speed currently we'd have to change it in at least 2 places. 

SUBMITTED

temp++)
    {
        if(temp&gt;15)
        {
        H=H-0.015;
        }
        else
        {
        H=H+0.015;
        }
        //M

PRE

instead?

You're also <a href="http://www.pcg-random.org/posts/cpp-seeding-surprises.html" rel="noreferrer">seeding your PRNG wrong</a>, but seeding it correctly is a huge headache in C++17, so never mind that.

MID

        if(temp&gt;15)
        {
        H=H-0.015;
        }


POST

Please indent your code correctly. You can use the <code>clang-format</code> command-line tool to automatically indent everything, or if you use a graphical IDE it almost certainly has an "Indent" option somewhere in the menus.

That's enough for one day. As I said above, I advise you to fix as much as possible (that is, fix <em>everything</em> I talked about here, and then fix everything else you can think of, too) and then repost.

After you fix everything, but before you repost, <em>read your code from top to bottom one more time!</em> Find two more things that need fixing, and fix them. <em>Then</em> repost.

SUBMITTED

LINKEDLIST_GENERATE

PRE

I have only questions, but maybe some of these are useful.

MID

LINKEDLIST_GENERATE

POST

SUBMITTED

height" : 22,
          "name" : "edit_sale"
        }
      ],
      "y" : 0,
      "width" : 600,
      "type" : "group",
      "name" : "fb_post_5"
    }
  ]
};

$(document).ready(function() {

    // below code will upload image onclick mask image

    $('.container').click(function(e) {
        // filtering out non-canvas clicks
        if (e.target.tagName !== 'CANVAS

PRE

Then that can be referenced later in the code - e.g.

MID

// below code will upload image onclick mask image

containerElement.click(function(e) {
    // filtering out non-canvas clicks


POST

and 

SUBMITTED

if (filePath.Equals(""))
                {
                    Console.WriteLine("Please specify file path");
                    filePath = Console.ReadLine();
                }

                if (remoteIPFilter.Length == 0)
                {
                    Console.WriteLine("IPv4 Filters (seperated by space

PRE

MID

Console.WriteLine(&quot;Please specify file path&quot;);
filePath = Console.ReadLine();


POST

-&gt; append the following method to have some leverage on user input.

SUBMITTED

def __repr__

PRE

First, we detach the min from the left child, then we return this min and the tree without the min.

MID

__repr__

POST

SUBMITTED

Exit
                    )" &lt;&lt; "\n\t\t\t\t--&gt; ";
}

// get

PRE

I have a few suggestions:

MID

\n\t\t\t\t

std::cout &lt;&lt; "\n\t\t\t\t--&gt; Please enter your ID: ";
getInput(id);
account = findAccount(id);


POST

SUBMITTED

int array_get

PRE

I know <code>free</code> accepts <code>NULL</code>, but that's not always the best route.  I would <code>assert(a)</code>.  Other examples of cleanup functions that don't have to do null checks are <code>pthread_mutex_destroy</code> and <code>fclose</code>.  In general in C, there is a philosophy that the programmer is right and the computer will do what s/he says or die trying.  So if the programmer says array_cleanup, then do your darnest to cleanup the array.

<code>if (a-&gt;contents)</code> is superfluous as free checks that anyway.

I know what you mean by the init/cleanup naming convention, but I prefer init/destroy (as in pthread_mutex_[init|destroy]) or create/destroy.  cleanup doesn't imply destroy to me -- I may want to cleanup a memory arena for example, but that doesn't mean I'm done using it.

MID

array_get

POST

The array could be const.  If not, I would expect the return the value to be something mutable like a ptr to a value.

<code>index</code> should be <code>size_t const</code>.

It's completely horrible to return -1.  What if the element I stored is -1?  Are you saying I cannot store -1, but I should pass an int?  This needs to change.  One option is errno.  Another option is returning the element by ptr.

The <code>NULL</code> checks... again, I would assert.

<code>index &gt; a-&gt;capacity - 1</code> should be <code>!(index &lt; a-&gt;capacity)</code> IMO.  In my personal style, I like to say <code>if (!(...))</code> when checking if something went wrong.  That way, <code>(...)</code> is the condition I want to be true.  This is just a personal preference though.  Also, it's bad practice to compare different types, so be sure to make them both <code>size_t</code>.

You could make the capacity check an assertion too.  If you make both of these checks into assertions, then the whole function will turn into just one instruction when compiled without assertions.  This means you'll be quicker.  Also, you won't have those nasty <code>return -1</code>s.

SUBMITTED

def parseContent(self, rdbFilePath, content):
    finalContent = self.removeComments(content)
    includeFileSearch = re.compile(r'(?P&lt;tag&gt;(\s)*include+(\s*)\"(\s*)(?P&lt;file&gt;[a-zA-Z0-9\.\_/]*)\")')
    for includes in includeFileSearch.finditer(finalContent):
        finalContent = re.sub(includes.group('tag'),self.parseIncludes(rdbFilePath, includes.group('file')), finalContent)
    return finalContent

def parseIncludes(self, rdbFilePath, file):
    path = rdbFilePath + "/" + file
    f = open(path)
    pathDir = os.path.dirname(path)
    includedFileContent = self.parseContent(pathDir, f.read())
    return includedFileContent

PRE

<code>parseContent()</code> calls both <code>re.finditer()</code> and <code>re.sub()</code>, which is inefficient, because the <code>re.sub()</code> has to find the insertion point that <code>re.finditer()</code> had already found. What you want is just <a href="https://docs.python.org/3/library/re.html#re.sub" rel="nofollow noreferrer"><code>re.sub()</code></a>:

<em>repl</em> can be a string or a function… If <em>repl</em> is a function, it is called for every non-overlapping occurrence of <em>pattern</em>. The function takes a single <a href="https://docs.python.org/3/library/re.html#match-objects" rel="nofollow noreferrer">match object</a> argument, and returns the replacement string.

Going further, you should make just one substitution pass that handles both comments and includes. (You didn't show us the <code>removeComments()</code> code, so you'll have to adapt the regex yourself.)

The double-quotes in the regex have no special significance, and do not need to be escaped with backslashes. Also, the dot and the underscore characters do not need to be escaped within a character class.

MID

DIRECTIVE_RE = re.compile(r'(?P&lt;comment&gt;#.*)|(?P&lt;include&gt;(\s)*include+(\s*)"(\s*)(?P&lt;file&gt;[a-zA-Z0-9._/]*)")')

def process_content(self, rdb_file_path, content):
    def directive_handler(match):
        if match.group('comment'):
            return ''
        elif match.group('include'):
            path = os.path.join(rdb_file_path, match.group('file'))
            with open(path) as f:
                return self.process_content(rdb_file_path, f.read())
    return DIRECTIVE_RE.sub(directive_handler, content)


POST

<code>open()</code> should almost always be called using a <code>with</code> block to ensure that the filehandle gets closed automatically.

Note that I have used <a href="https://docs.python.org/3/library/os.path.html#os.path.join" rel="nofollow noreferrer"><code>os.path.join()</code></a> as a portable alternative to <code>+ "/" +</code>.

SUBMITTED

function sortArrayByParity2(A) {
  const odd = [];
  const even = [];
  for (const a of A) {
    if (a % 2 === 0) {
      even.push(a);
    } else {
      odd.push(a);
    }
  }
  return [...even, ...odd

PRE

Swap the conditions. 

You have <code>if(a % 2 === 0) { /*even*/ } else { /*odd*/ }</code> ...

can be <code>if(a % 2) { /*odd*/ } else { /*even*/ }</code>

Compact code. Try to avoid sprawling code. It may not matter for small segments of code, but source code can very long and reading code there spans pages is not as easy as having it all in one view.

Before a newline it is either <code>}</code> or <code>;</code>. There are two exceptions. The <code>}</code> that closes an object literal should have a closing <code>;</code> eg <code>const a = {};</code>. And multi line statements and expressions.

You do a lot of code examples, many of them are rather trivial. Of late many of your posts contain bugs or incomplete code (may be a sign of boredom? or a lack of challenge (engagement)) . I do not believe in the classical closed book assessment examination, it does not reflect the real world. However a good memory of the field makes you a more productive coder.

There are many subtle tricks in JavaScript that can catch you out if unaware. Testing your knowledge improves your understanding of the language making you a better coder.

This is a example <a href="http://davidshariff.com/js-quiz/" rel="nofollow noreferrer">JavaScript Web Development Quiz</a> picked at random from a web search <code>"javascript quiz"</code> 

It is good practice to do one of these every now and then.

<sub><sup>I did not get 100% </sup></sub>

Compacting the function. 

MID

function sortByParity(arr) {
    const odd = [], even = [];
    for (const val of arr) {
        if (val % 2) { odd.push(val) }
        else { even.push(val) }
    }
    return [...even, ...odd];
}


The second functional example was so slow I had to push the other best time down to the timer resolution cutoff 0.2ms or it would have taken forever to complete the test.

The functions as tested

function sortByParity_I1(A) {
    const odd = [], even = [];
    for (const a of A) {
        if (a % 2 === 0) { even.push(a) }
        else { odd.push(a) }
    }
    return [...even, ...odd];
}
const sortByParity_F2 = A =&gt; A.reduce((acc, x) =&gt; x % 2 === 0 ? [x, ...acc] : [...acc, x], []);
const sortByParity_F1 = A =&gt; A.reduce((acc, x) =&gt; {
        if (x % 2 === 0) { acc.unshift(x) }
        else { acc.push(x) }
        return acc;
    }, []);


POST

Mean time per call to the function in 1/1,000,000 second. OPS is operations per second. % is relative performance of best.

For array of 1000 random integers

SUBMITTED

ASCII.

#endif  
        if ( i

PRE

MID

if (i % 1 != 0) {


POST

This condition always evaluates to true.

SUBMITTED

join(y))
    T = list(set(Q

PRE

MID

T = set(Q)

POST

SUBMITTED

lt;size_t&gt; tail;
public:
    explicit PCQueue(size_t s) : size(s), contents(new T[s]), head(0), tail(0) {}

    //num of elements in ringbuffer (size - room

PRE

When you create the <code>content</code> with <code>contents(new T[s])</code> you are allocating and initializing all the elements in that array using the default constructor.

In addition to this if <code>T</code> is very expensive you have just used a lot of effort to create the items that may never be used (or you wasted resources creating the objects that are just going to be destroyed when overwritten).

I would consider changing this to <code>std::vector&lt;T&gt;</code>. That way you don't create any un-required objects when first created.

This is fine:

MID

    explicit PCQueue(size_t s) : size(s), contents(new T[s]), head(0), tail(0) {}


But you can make it more readable. Remember the point of code is to make the code maintainable.

    explicit PCQueue(size_t s)
        : size(s)
        , contents(new T[s])
        , head(0)
        , tail(0)
    {}


Is this the real definition of the function?

    //num of elements in ringbuffer (size - room())
    size_t count() {
        return (tail + size - head) % size;
    }


I would rename this function to reflect what the function is actually returning. I would also change the formula so it is easy to read. I would call this <code>availableSpace()</code>. The formula is: <code>size - (head - tail)</code>.

This would be better named <code>freeSpace()</code>.

    //num of free spaces in ringbuffer (size - count())
    size_t room() {
        return (head + size - tail) % size;
    }


POST

You pass the parameter by value.

SUBMITTED

import os, sys, zipfile, fnmatch, glob, sys, time, datetime, smtplib, logging
from datetime import date
from datetime import time
from datetime import

PRE

MID

import os, sys, zipfile, fnmatch, glob, sys, time, datetime, smtplib, logging


is a prime example why you <a href="https://www.python.org/dev/peps/pep-0008/#imports" rel="nofollow noreferrer">should not cram all your imports on a single line</a>. Why? If you have a closer look, you will see that there is a double import of <code>sys</code>.

It is also good practice to group imports by "topic", i.e. imports that have similar purposes. Something like

import os
import glob
import zipfile
import logging

import datetime
from datetime import date, datetime

import smtplib
from email import encoders
from email.mime.text import MIMEText
from email.mime.base import MIMEBase
from email.mime.multipart import MIMEMultipart


POST

As you can see some of your imports also got lost on the way. Basically it was my IDE (Visual Studio Code) telling me that they're not used in your program. At the moment I'm under Windows so I cannot test run your code, so take that with a grain of caution.

Another common practice is to wrap the parts of the code that are supposed to be run as script, with an <a href="https://docs.python.org/3/library/__main__.html" rel="nofollow noreferrer"><code>if name == "__main__":</code></a> clause. In order to do that, you should collect all the loose function falls immediately done after the function definition into that block.

SUBMITTED

binaryDigit = parseInt

PRE

You should use the directive <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode" rel="nofollow noreferrer"><code>&quot;use strict&quot;</code></a> that will place the JavaScript context into strict mode. This will throw errors for some common bad practices.

Always declare variables as <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const" rel="nofollow noreferrer"><code>const</code></a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var" rel="nofollow noreferrer"><code>var</code></a>, or <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let" rel="nofollow noreferrer"><code>let</code></a>. If you are in strict mode you will get an error if you don't.

Don't use alerts or prompts as there is no way to know if they are actually displayed (clients can turn them off) and they are very annoying.

The key event properties <a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode" rel="nofollow noreferrer"><code>KeyboardEvent.keyCode</code></a> and <a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/charCode" rel="nofollow noreferrer"><code>KeyboardEvent.charCode</code></a> have been depreciated and you should not use them. Use <a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code" rel="nofollow noreferrer"><code>KeyboardEvent.code</code></a> or <a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key" rel="nofollow noreferrer"><code>KeyboardEvent.key</code></a> instead

Rather than filter the input via the keybpoard events, listen to the input's <code>keyup</code> and <code>change</code> events, removing bad characters automatically. Use a CSS rule to unhide a warning and a JavaScript <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout" rel="nofollow noreferrer">setTimeout</a> to hide it again

Filtering keyboard events means you need to check many keys that are valid (left, right, backspace, delete, etc...) which is just unneeded complexity.

Don't wait for the user to click &quot;Convert to Decimal&quot;, display the output automatically. This makes it a lot friendlier to use.

JavaScript can convert binary strings to decimal for you using <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt" rel="nofollow noreferrer"><code>parseInt</code></a>. The second argument is the radix (AKA base) of the number that is being parsed.

If you are just setting text (no HTML) use the elements <a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent" rel="nofollow noreferrer">textContent</a> rather than <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML" rel="nofollow noreferrer">innerHTML</a>

The rewrite is following the points you have set-out in your question. I have not implemented how your code differs from these points.

The rewrite uses

MID

parseInt

POST

SUBMITTED

ValidationTests()
    {
        ValidatableBuilder

PRE

MID

ValidatableBuilder

POST

SUBMITTED

pop_size, cell_size, mutation_rate, a_p, boa_split="aft"
                    )
            print("{} generations are done. Cells are extinct.".format(gen))

        if gen % 100 == 0 and

PRE

Numpy can be extremely fast, nigh on as fast as C or other low level languages (because it uses C!). But this is on the condition that the slow stuff is actually done in Numpy. By which I mean, you can't keep looping through lists and dictionaries then do select actions in Numpy, you have to stick to Numpy arrays and element-wise operations.

I will give some comments on style then return to that.

First, there are zero comments throughout your entire code. I recommend both <code>"""docstrings"""</code> at the start of your functions and short <code># Comments</code> between lines where code is a little confusing.

f-strings are a python 3.6+ feature which greatly improve readability. They are used in place of .format() and string concatenation. For example:

MID

print(f'{gen} generations are done. Cells are extinct.')


POST

You spread a lot of code over several lines when really, longer lines would be cleaner. You don't have very-highly nested code so the lines won't even be that long.

Good uses of <code>yield</code>. This is something new programmers often skip over and it's good to see it being used to effect here.

Your imports are clean, minimal and well separated from the rest of the code.

Some of the naming could use some work to help clarity. Just name your keys <code>enzyme</code> and <code>parasite</code>, rather than <code>e</code> and <code>p</code>. What <em>is</em> <code>a_p</code>? Try not to use built-in function names as argument names (<code>pop</code>) as it can cause issues and be confusing. Here, it is clearly short for population but be careful with it. Use <code>snake_case</code> for naming lower-cased objects <code>ratherthanthis</code>. 

You are frequently returning a huge number of values. If you're always printing 0s to the file you don't need them to be returned, just write them to the file every time, then write the rest of the return values. Some things like <code>gen</code> should be kept track of externally, rather than it being returned every time. If something is static, you probably don't need to feed it into a function then spit it back out unchewed.

Multi-line strings can be achieved with triple quotes:

SUBMITTED

main(){
  int iMax = sizeof(strs) / sizeof(strs[0]); // number of test values

  int i; // test number = index of the array 

  for (i = 0; i &lt; iMax; ++i)  // check all test values
    FormatString(strs[i]);



  return

PRE

MID

int main(){
  int iMax = sizeof(strs) / sizeof(strs[0]); // number of test values

  int i; // test number = index of the array 


Again do not omit the braces

  for (i = 0; i &lt; iMax; ++i)  // check all test values
    FormatString(strs[i]);



  return 0;

}


POST

SUBMITTED

method="",list_method

PRE

MID

list_method=[]

POST

SUBMITTED

private:
        const

PRE

Now anywhere you need degrees, instead of <code>deg_255</code>, just use <code>255.0_deg</code> and all of those constants go away.

MID

const

There are several places, such as <code>Ball::isActive()</code> which simply report back something about the underlying object without altering it.  Those should be <code>const</code> like this:

bool Ball:isActive() const { return mIsActive; }


POST

The <code>Level</code> file contains code that creates a <code>vector</code> of <code>Brick</code> objects like this:

SUBMITTED

foreach (var

PRE

MID

var

POST

Your biggest bottleneck is the sequential loop of 7000 users. You could use the <a href="https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/task-parallel-library-tpl" rel="nofollow noreferrer">TPL</a> to maximize performance.

SUBMITTED

i = 0; i &lt; words.length; i++) {
    for (let j = 0; j &lt; words.length; j++) {
      if (i !== j) {
        if (isPalindrome(words[i] + words[j])) { index.push([i

PRE

Why is one <code>var</code> and one <code>const</code>?

MID

      if (i !== j) {
        if (isPalindrome(words[i] + words[j])) { index.push([i, j]); }
      }      


I would prefer a single condition instead of an extra layer of indentation:

      if (i !== j &amp;&amp; isPalindrome(words[i] + words[j])) {
        index.push([i, j]);
      }


POST

SUBMITTED

running=[]):
    for (index,item

PRE

The use of whitespace is a little bit inconsistent. I would make the following changes based on the <a href="https://www.python.org/dev/peps/pep-0008/" rel="nofollow noreferrer">python style guide</a>:

MID

(index,item)

(index, item)

POST

SUBMITTED

random.getrandbits(len(password

PRE

Don’t roll your own encryption.  It takes a team of experts to develop new secure encryption methods, and even they can get it wrong from time to time.

Huge hole in your DIY encryption:

If I use a 2-character password, I might naïvely expect I’d have <span class="math-container">\$62^2\$</span> possible passwords that I can encrypt the data with.  I’d be really shocked when it turns out there are only 4.

MID

random.getrandbits(len(password))


POST

generates 2 random bits, for <span class="math-container">\$2^2\$</span> possible values to multiply <code>to_num(data)</code> by.  Only 4 possibilities is a lot easier to attack than <span class="math-container">\$62^2\$</span> different possibilities!

And one of those possibilities ... all bits zero ... destroys all the data you want to encode.  So we’re down to actually only 3 possible numbers to test to reverse the encryption.

Any encryption mechanism worth its salt uses a salt (initial random data) to prevent the same message with the same password from being encrypted as the same text.

Code improvements: use generator expressions.  Eg)

SUBMITTED

if len(blocked) &lt

PRE

Without leaking the better algorithm, I'll highlight one area where this code can be dramatically improved.

You are ignoring a pair of important facts:

MID

len(blocked)

blocked[i][j]

POST

<a href="https://en.wikipedia.org/wiki/Pigeonhole_principle" rel="nofollow noreferrer">Pigeonhole principle</a>: if you have more holes than pigeons, some holes will be empty.  On your grid, you have at least 999800 rows that will be empty, and at least 999800 columns that will be empty.  Using a BFS wave that traverses the grid space can result in taking a lot of steps which can be optimized away.

SUBMITTED

baseEntityWithX:[NSNumber

PRE

MID

NSNumber

POST

If you don’t need object behaviors, then feel free to use <code>double</code>, especially where doing something computationally intensive.

when do I use <code>int</code> vs <code>NSInteger</code> ...

Generally prefer <code>NSInteger</code> over <code>int</code>, unless there’s some reason that you need to specify the <code>int</code> type explicitly. See <a href="https://stackoverflow.com/a/4445199/1271826">https://stackoverflow.com/a/4445199/1271826</a>.

... vs <code>NSNumber</code>

See <code>double</code>/<code>NSNumber</code> discussion.

can I hide methods from super class as <code>RotationalVector</code> can do <code>[RotationalVector vector3]</code> but I would like for it to be only able to use <code>[RotationalVector rotationalVector]</code>

In general, we tend to want to follow the “<a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle" rel="nofollow noreferrer">Liskov substitution principle</a>”, (LSP) where anywhere you used the base class you should be able to use a subclass. The notion of “hiding” some behavior of the parent is contrary to this notion.

And before you go down the road of “well, instead of hiding, I can just change the behavior of the parent’s method,” that would violate the “<a href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle" rel="nofollow noreferrer">Open-closed principle</a>”, another guiding design principle.

within an instance method whats the difference between <code>_x</code>, <code>[self x]</code> and <code>self.x</code>

<code>self.x</code> is simply syntactic sugar for <code>[self x]</code>. As discussed above, you’d tend to use the former for properties.

Re <code>_x</code>, that is bypassing the accessor methods (getters/setters) and interacting with the instance variable (ivar) directly. That’s in contrast to <code>self.x</code> (and <code>[self x]</code>), which are interacting with the accessor methods (getters and setters), which is a higher level of abstraction. In general, the <code>self.x</code> pattern offers better future-proofing of your code (e.g. if you decide to implement custom getters and setters at some future date, it saves you from pouring through your code for when you bypassed the accessor methods and interacted directly with the ivar). 

You just want to avoid using <code>self.x</code> pattern inside the getters/setters for <code>x</code> (or else you can end up with infinite recursion). And, arguably, you should avoid it inside your initializer method, too. 

would it be a good idea to only include <code>init</code> methods in the .m file?

The implementation of the <code>init</code> methods (as do the implementations of all methods) belong in <code>.m</code> file. The declaration of the <code>init</code> methods belongs in the <code>.h</code> file if you choose to expose that initializer to other classes. Think of the <code>.h</code> as your “public interface” for your class and the <code>.m</code> is for implementations (and any private interfaces).

am I using proper return types for init and factory method?

I’d suggest using <code>instancetype</code> in both cases for consistency’s sake, though the compiler is smart enough to infer <code>instancetype</code> when the method starts with <code>init</code>. But definitely use <code>instancetype</code> for your class methods, especially if you might subclass this class in the future.

SUBMITTED

Entity\Product

PRE

MID

Product

POST

SUBMITTED

class Luhn:

    DOUBLE_LUT = (0, 2, 4, 6, 8, 1, 3, 5, 7, 9)
    # CHECK_DIGIT_LUT = tuple(str(10 - i) for i in range(10))
    CHECK_DIGIT_LUT = ("0", "9", "8", "7", "6", "5", "4", "3", "2", "1")
    # STR_TO_INT_LUT = {str(i): i for i in range(10)}
    STR_TO_INT_LUT = {
        '0': 0, '1': 1, '2': 2, '3': 3, '4': 4,
        '5': 5, '6': 6, '7': 7, '8': 8, '9': 9
    }

    @classmethod
    def calculate_lut1(cls, input_):
        """Calculate the check digit using Luhn's algorithm"""
        sum_ = 0
        for i, digit in enumerate(reversed(input_)):
            digit = int(digit)
            sum_ += digit if i % 2 else cls.DOUBLE_LUT[digit]
        return str(10 - sum_ % 10)

    @classmethod
    def calculate_lut12(cls, input_):
        """Calculate the check digit using Luhn's algorithm"""
        sum_ = 0
        for i, digit in enumerate(reversed(input_)):
            digit = cls.STR_TO_INT_LUT[digit]
            sum_ += digit if i % 2 else cls.DOUBLE_LUT[digit]
        return cls.CHECK_DIGIT_LUT[sum_

PRE

And so this is the fastest I could get:

MID

import itertools


class Luhn:
    CHECK_DIGIT_LUT = ("0", "9", "8", "7", "6", "5", "4", "3", "2", "1")
    SUM_MOD10_LUT = [
        {str(j): (i + j) % 10 for j in range(10)}
        for i in range(10)
    ]
    SUM_DOUBLE_MOD10_LUT = [
        {str(j): (i + (0, 2, 4, 6, 8, 1, 3, 5, 7, 9)[j]) % 10 for j in range(10)}
        for i in range(10)
    ]

    @classmethod
    def calculate_lut_overkill(cls, input_):
        """Calculate the check digit using Luhn's algorithm"""
        sum_ = 0
        for digit, table in zip(
            reversed(input_),
            itertools.cycle([
                cls.SUM_DOUBLE_MOD10_LUT,
                cls.SUM_MOD10_LUT,
            ]),
        ):
            sum_ = table[sum_][digit]
        return cls.CHECK_DIGIT_LUT[sum_]


POST

My timings were:

SUBMITTED

BlockingQueue(const BlockingQueue&amp; other)
   {
      auto lock{std::scoped_lock(other.mutex_)};
      queue_ = other.queue_;
   }
   /*5*/ BlockingQueue(BlockingQueue&amp;&amp; other) noexcept(
       std::is_nothrow_move_constructible_v&lt;BlockingQueue&gt;)
   {
      auto lock{std::scoped_lock(other.mutex_)};
      queue_ = std::move(other.queue_);
   }
   /*6*/ template&lt;class Alloc, class = std::enable_if_t&lt;std::uses_allocator_v&lt;Container, Alloc&gt;&gt;&gt;
   explicit BlockingQueue(const Alloc&amp; alloc) noexcept(
       std::is_nothrow_constructible_v&lt;Container, const Alloc&amp;&gt;)
       : queue_{alloc}
   {
   }
   /*7*/ template&lt;class

PRE

MID

   /*9*/ template&lt;class Alloc, class = std::enable_if_t&lt;std::uses_allocator_v&lt;Container, Alloc&gt;&gt;&gt;
   BlockingQueue(const BlockingQueue&amp; other, const Alloc&amp; alloc) : queue_(alloc)
   {
      auto lock{std::scoped_lock(other.mutex_)};
      queue_ = other.queue_;
   }


This doesn't look quite right. <code>queue_ = other.queue;</code> may cause the allocator from <code>other.queue</code> to be used, <a href="https://en.cppreference.com/w/cpp/container/deque/operator%3D" rel="nofollow noreferrer">depending on the allocator traits</a>.

To ensure correct behavior, we probably need to use the relevant <code>Container</code> constructor instead:

   /*9*/ template&lt;class Alloc, class = std::enable_if_t&lt;std::uses_allocator_v&lt;Container, Alloc&gt;&gt;&gt;
   BlockingQueue(const BlockingQueue&amp; other, const Alloc&amp; alloc)
   {
      auto lock{std::scoped_lock(other.mutex_)};
      queue_ = Container(other.queue_, alloc);
   }


(And the same for <code>/*10*/</code>).

[[nodiscard]] auto size() const noexcept(noexcept(std::declval&lt;Container&amp;&gt;().size()))
[[nodiscard]] auto clear_count()
... etc.


POST

We could use <code>size_type</code> rather than <code>auto</code>.

SUBMITTED

unchecked")
    public void sortEmployees() throws LoginException

PRE

How efficient is it to sort entities on the repository? This is something calling code should bother with, not the repository.

MID

  public void sortEmployees() { /* .. */ }


POST

SUBMITTED

return ReadArg

PRE

MID

ReadArg

POST

SUBMITTED

ComputerBytez {
namespace Socket {
namespace Protocol {
    int TCP = Platform::Protocol::TCP

PRE

Use <a href="https://en.cppreference.com/w/cpp/language/enum" rel="nofollow noreferrer"><code>enum</code></a> or even better, <code>enum class</code>, where appropriate. For example, instead of:

MID

namespace Protocol {
    int TCP = IPPROTO_TCP;
};


Write:

enum class Protocol: int {
    TCP = IPPROTO_TCP,
};


POST

This is will allow the compiler to be much stricter in checking that you don't accidentily pass a value that is not one of the valid enum choices. The only drawback is that sometimes you have to explicitly cast such a variable back to the underlying integer type.

SUBMITTED

remove_unusable_files();
        if (max_files == 0 || files.size() + 1 &lt; max_files) {
            files.insert(std::pair&lt;std::string,
                    std::shared_ptr&lt;File&gt;&gt;(id, std::make_shared&lt

PRE

MID

std::map&lt;std::string, std::shared_ptr&lt;File&gt;&gt; files;


The file ownership is not shared with anything, so we have no reason to use a <code>shared_ptr</code>.

    std::string files_path;


It turns out we are setting the <code>path</code> member of <code>File</code> to this same value for every single file! That's a huge amount of unnecessary duplication.

void FilesManager::operator+=(const add_data &amp;data) {
    add(std::get&lt;0&gt;(data), std::get&lt;1&gt;(data));
}

File &amp;FilesManager::operator[](const std::string &amp;id) {
    return get(id);
}

void FilesManager::operator-=(const std::string &amp;id) {
    remove(id);
}


POST

We're duplicating code here, and also adding complexity with the <code>add_data</code> struct. Generally in C++ we should avoid overloading operators, unless it's for very common and unambiguous mathematical operations.

We would expect const versions of <code>get()</code> and <code>operator[]</code>. The behavior of adding a missing file is very surprising for a <code>get()</code> function.

SUBMITTED

lt;Person

PRE

MID

Person

Person

POST

SUBMITTED

include "robot

PRE

I see a number of things that may help you improve your program.

MID

#include

POST

The code uses <code>std::vector</code> and <code>std::string</code> which means that it should <code>#include &lt;vector&gt;</code> and <code>&lt;string&gt;</code>.  It was not difficult to infer, but it helps reviewers if the code is complete.

SUBMITTED

n", tinfo.total);  \
        printf

PRE

<code>+= 1</code> is more idiomatically written as <code>++</code>:

MID

    ++tinfo.total;


POST

Similarly, write <code>-= 1</code> using <code>--</code>.

We'd like the unit-test program to exit with success status only if all tests succeeded.  If any fail, we want to know (e.g. to stop the build at that point).  I suggest creating the test function with an <code>int</code> return type to support this, and ending with <code>return tinfo.aborted || tinfo.failed</code>.

The behaviour when <code>CMC_TEST_ABORT()</code> is used is strange.  It's the only code that's setting <code>tinfo.aborted</code>, so we could move the <code>if (tinfo.aborted)</code> block directly into that code.  OTOH, we shouldn't be printing the elapsed time in that case, as we've skipped the <code>TIMER_STOP(timer);</code> and <code>TIMER_CALC(timer);</code> lines.

Finally, I know it's not really up for review, but I couldn't resist making observations on the <code>gcd()</code> function used for testing:

There's no need for a specific <code>p==0</code> test - the flow without the test already does the right thing (but the <code>q==0</code> test <em>is</em> required, as it's used as divisor in the <code>%</code> operation).

We can reduce duplication, by moving <code>p % q</code> into the test:

SUBMITTED

CmdMpuSerialNumber : CommandBase

PRE

MID

CommandBase

POST

SUBMITTED

if(typeof

PRE

MID

typeof

typeof(foo) === "foo"

typeof foo  === "foo"

POST

SUBMITTED

int j

PRE

MID

j

POST

SUBMITTED

buffer which should be faster than std::vector&lt;uint8_t&gt; when resizing a lot because it does not do byte initialization when resizing
class uint8_fast_buffer
{
public:
    uint8_fast_buffer(const size_t initial_size)
    {
        if(initial_size == 0)
        {
            // .. i don't really like the idea of buf being nullptr, this avoids that issue

PRE

MID

// buffer which should be faster than std::vector&lt;uint8_t&gt; when resizing a lot because it does not do byte initialization when resizing


POST

This comment line is really long. You should wrap the text so that there is no horizontal scrollbar anymore.

SUBMITTED

StringCsv

PRE

MID

StringCsv

POST

SUBMITTED

mutex);
        pthread_cond_destroy(&amp;mControlBlock-&gt;cond);

        bi::shared_memory_object::remove(mRegion.c_str());
    }
}

bool ipn::Notifier::wait()
{
    timespec time;
    timespec_get(&amp;time, TIME_UTC);

    // Wait 50ms
    time.tv_nsec += 50000000;
    time.tv_sec += time.tv_nsec / 1000000000;
    time.tv_nsec %= 1000000000;

    int n = pthread_cond_timedwait(&amp;mControlBlock-&gt;cond, &amp;mControlBlock-&gt;mutex, &amp;time);

    if (n == 0)
    {
        std::cerr &lt;&lt; "Notified" &lt;&lt; std::endl;
        return true;
    }
    else
    {
        if (n == ETIMEDOUT)
        {
            std::cerr &lt;&lt; "Timed out" &lt;&lt; std::endl;
            return false;
        }

        else if (n == EINVAL)
        {
            std::cerr &lt;&lt; "Invalid value specified";
            return false;
        }

        else
        {
            std::cerr &lt;&lt; "Other error" &lt;&lt; std::endl;
            return false;
        }
    }
}

ipn::Notifier::~Notifier()
{
    detach();
}
void ipn::Notifier::setCallback(const std::function&lt;void()&gt; &amp; callback)
{
    mCallback = callback

PRE

You have a rather long if-else ladder. I think this can be simpler written as:

MID

  switch (n) {
    case 0:
      std::cerr &lt;&lt; &quot;Notified&quot; &lt;&lt; std::endl;
      return true;
    case ETIMEDOUT:
      std::cerr &lt;&lt; &quot;Timed out&quot; &lt;&lt; std::endl;
      return false;
    case EINVAL:
      std::cerr &lt;&lt; &quot;Invalid value specified&quot;;
      return false;
    default:
      std::cerr &lt;&lt; &quot;Other error&quot; &lt;&lt; std::endl;
      return false;
  }


POST

The n==0 case (original code) is also at the different level of nesting that is confusing, even if it seems to me that the nesting does not have effect.

SUBMITTED

int rc = 0;
  virtual ~refcount

PRE

You didn't post a complete header file (no include-guard/<code>#pragma once</code>), so it's unclear whether you also omitted a <code>namespace Taylor {</code> somewhere in there. But you should definitely use a namespace around a name as common as <code>ref</code>.

MID

  virtual ~refcount() { }


POST

Nit: You could use <code>= default;</code> instead of <code>{ }</code> here, and you might get slightly better codegen on some compilers. (Virtual destructors are never actually "trivial," unfortunately, but getting the compiler to write this quasi-trivial code for you can't hurt.)

I notice that <code>refcount-&gt;rc</code> is <code>public</code>, not <code>private</code>. Was that a design decision?

It occurs to me that the proper name for what you're calling <code>refcount</code> is actually <code>refcounted</code>. The <strong>refcount</strong>, physically, is the data member <code>rc</code>. A type which derives from your base class is a <strong>refcounted</strong> type.

SUBMITTED

animalHandler.addDog

PRE

MID

addDog()

POST

SUBMITTED

for Player

PRE

MID

Player

POST

SUBMITTED

getChild(String

PRE

MID

String

POST

SUBMITTED

rs := ""

    for

PRE

Your first variant is unnecessary detailed and hard to read:

MID

for

for

POST

SUBMITTED

import random; import time; import threading; import sys; import psutil; from colorama import init; from termcolor import colored

while True: # Contains all variables and hunger decrease
    def show_faster(str):
        for char in str:
            time.sleep(0.1)
            sys

PRE

<strong>Wow! What a project!</strong>

I had tons of fun working on this! There are a lot of things to like about your code. Instead of going over the general improvements I made, I'm going to explain each part that I changed and why I changed it. 

<em>Note: I did not touch the</em> <code>threading</code> * and other hunger behavior because I am not confident enough with my ability to improve that. Another answer can possible touch on that.*

Here we go!

<strong>Import Statements</strong>

MID

import random; import time; import threading; import sys; import psutil; from colorama import init; from termcolor import colored


According to <a href="https://www.python.org/dev/peps/pep-0008/" rel="nofollow noreferrer">PEP-8</a>, this is unconventional. All imports should be on their own line, and ordered alphabetically, with the <code>from .. import ..</code> statements being ordered after.

import psutil
import random
import sys
import time
import threading
from colorama import init
from termcolor import colored


POST

<strong>Job Selection</strong>

Your method to choose a job was a whole <strong>332</strong> lines long! That's a lot of code to just select what your profession is. Using a simple <a href="https://www.w3schools.com/python/python_dictionaries.asp" rel="nofollow noreferrer">dict</a>, we can use the names of the jobs as <code>values</code>, and have each <code>abcde</code> option as the <code>key</code>. Using this method, I was about to shrink the method down to <strong>23</strong> lines, <strong>309</strong> lines shorter!

<strong>Global Variables</strong>

Q: <em>Should you use global variables in your program?</em>

A: <strong>90% of the time, <em>NO.</em></strong>

It's anyones guess what the right answer is. Using global variables has a plethora of nasty things that can affect your program. <a href="http://wiki.c2.com/?GlobalVariablesAreBad" rel="nofollow noreferrer">This document</a> can explain the negative effects of using global variables better than I ever will be.

<strong>Method Docstrings</strong>

You should include docstrings on the first line of every method you write. This will help documentation identify what your method is supposed to do.

<strong>Variable/Method Naming</strong>

You should use <code>snake_case</code> and not <code>camelCase</code> or <code>nonexistentcase</code> when naming variables in python.

<strong>Main Guard</strong>

When running code outside a method/class, it's always good to use a main guard. This is a <a href="https://stackoverflow.com/questions/19578308/what-is-the-benefit-of-using-main-method-in-python">StackOverflow question</a> that helps explain the benefit/use of the guard. An excerpt from the accepted answer:

Having a main guard clause in a module allows you to both run code in the module directly and also use procedures and classes in the module from other modules. Without the main guard clause, the code to start your script would get run when the module is imported.

<strong>Objects</strong>

In your code, you have variables like so:

SUBMITTED

documentType) == false

PRE

MID

== false

POST

SUBMITTED

e', 'f

PRE

MID

f""

POST

SUBMITTED

One"
// 0 -&gt; "Zero"
int main() {
    int input;
    while (1) {
        std::cout &lt;&lt; "Input: ";
        std::cin &gt;&gt; input;

        if (input == 0) {
            std::cout &lt;&lt; "Zero" &lt;&lt; "\n";
            continue;
        }

        std::vector&lt;std::string&gt; result;
        if (input &lt; 0) {
            input *= -1;
            result.push_back("Negative");
        }

        for (int i = 0; i &lt

PRE

Compile with <code>-Wall -Wextra -pedantic-errors</code>.  Warnings are preferable to runtime problems.  Sometimes I also compile with <code>-ftrapv</code> to avoid signed overflow.

You are doing much of the work inside <code>main</code>.  This violates the one responsibility principle.  Consider extracting a function <code>to_English</code> to do the actual work.  Also, your program becomes clueless after reaching EOF or invalid input.  A better <code>main</code> function looks like:

MID

int main()
{
    for (int num; std::cout &lt;&lt; "Input: ", std::cin &gt;&gt; num;)
        std::cout &lt;&lt; to_English(num) &lt;&lt; "\n";
}


POST

In this case, the input process is simple, so I put it in the loop condition.  You may want to extract as a separate <code>get_number</code> function for more sophisticated input.

You do not need to store the strings in vectors.  Just concatenate them in place.

SUBMITTED

inThere) {
          return r
        }
      }
      if

PRE

You are accessing a global scoped object <code>data</code> try to avoid such access by passing the array as a argument

Avoid undue complication. 

MID

if (inThere)

} else if (inThere)

POST

SUBMITTED

upper boundary and the lower one.
    for i in range(upper_boundary, lower_boundary

PRE

<code>range(start, end)</code> goes from the <code>start</code> value, inclusive, to the <code>end</code> value, exclusive.  So

MID

for i in range(upper_boundary, lower_boundary, -1):


POST

will not include <code>lower_boundary</code> in the values which will be tested, so you will be ignoring products where <code>i</code> would be <code>10</code> (two digit case) and <code>100</code> (three digit case).

Similarly, <code>for j in range(i, lower_boundary, -1)</code> will ignore products where <code>j</code> would be <code>10</code> and <code>100</code>.

The solution is to use <code>range(..., lower_boundary - 1, -1)</code>.

Why is <code>n == 1</code> special cased, to return <code>9</code>?  Why don’t you trust the algorithm to return the correct value?  Oh, right, <code>9*1</code> wouldn’t be tested, because <code>lower_boundary = 1</code>, and got excluded due to the bug above.

Perhaps you should have examined this special case closer.

You compute <code>i*j</code> up to 3 times each loop.  You should compute it once, and store it in a variable, such as <code>prod</code>.

SUBMITTED

QString dlgAboutDialog

PRE

MID

QString

POST

SUBMITTED

there is an admissable heuristic calculable for the type [T]
 */
abstract class AStarNode&lt;T&gt;(val data: T?,
                            var from: AStarNode&lt;T&gt;? = null,
                            var g: Int = Int.MAX_VALUE,
                            var f: Int = Int.MAX_VALUE) : Comparable&lt;AStarNode&lt;T&gt;&gt; {

    /**
     * Returns a [Collection] of neighbour nodes
     * In the case of euclidean nodes this is simply the connected nodes on the graph
     * In the

PRE

This is quite a lot to analyze, so I will focus only few examples on semantics, best practices and language features.

Some of your parameter and field names are way too short.

MID

abstract class AStarNode&lt;T&gt;(val data: T?,
                            var from: AStarNode&lt;T&gt;? = null,
                            var g: Int = Int.MAX_VALUE,
                            var f: Int = Int.MAX_VALUE) : Comparable&lt;AStarNode&lt;T&gt;&gt; {


POST

<code>g</code>, <code>f</code>

SUBMITTED

private typealias RVM = RotateViewModel
private typealias CVM = CropViewModel
class CropFragment: BaseFragmentInOut&lt;CVM, RVM&gt;
(CVM::class.java, RVM::class.java

PRE

after replacing the Class with KClass in the activity, you can use the kotlin ones instead of the java-ones.

then you can use:

MID

private typealias RVM = RotateViewModel
private typealias CVM = CropViewModel
class CropFragment: BaseFragmentInOut&lt;CVM, RVM&gt;(CVM::class, RVM::class) {
    ...
}


POST

In your second example, you tell me you must do everything in the Cropfragment.
This isn't true as your Basefragment can have those fields and the parent can set them.

SUBMITTED

string&amp; name)
{
    ifstream filename(name +".txt");
    if(!filename)
        return false;
    else
        return true

PRE

As a side note,

MID

    if (!filename) {
        return false;
    } else {
        return true;
    }


is a very long way to say

    return filename;


POST

Ditto for <code>IsLoggedIn</code>.

Be consistent with the return values. Some of the branches do return, some does not. As yet another side note, traditionally returning 0 means success.

SUBMITTED

import argparse

PRE

MID

argparse

POST

SUBMITTED

get_days(date1, date2):
    day_diff = (date1 - date2).days + 1
    days = [str(start_date + dt.timedelta(d)) for d in range(day_diff)]
    dates = "('" + "'),('".join(days) + "')"
    return dates

PRE

With the list comprehension you are filling a whole list with your values, and then you are sending that list to <code>join</code>.

Instead of a generating a list and then sending it, you can send a <strong>generator</strong> instead: similar to the list comprehension, but generates the values <em>on-demand</em>. With your old approach, if you had 10000 dates you would have them all at a list; with a generator it generates one at a time, so at least you will be consuming less memory.

With a generator, you would directly do:

MID

dates = "('" + "'),('".join(str(start_date + dt.timedelta(d)) for d in range(day_diff)) + "')"


POST

On a side note, the parameter names <code>date1, date2</code> are not very explicit; it should be clear from the names which is the start and which is the end date. 

SUBMITTED

play();
      System.out.print("Play again? (Y / N): ");
      run = input.nextLine().equalsIgnoreCase("Y") ? true : false;
    }
  }

  private static void showDescription() {
    System.out.println("You have to guess a number between " + lowerRange + " and " + upperRange + ".");
    System.out.println("You have " + tries + " tries.");
  }

  private static void play() {
    int randomNumber = generateRandomNumber(lowerRange, upperRange

PRE

You have <code>showDescription</code> directly printing out the message. Avoid printing in arbitrary functions whenever possible. It's much better to have things return Strings, then print at the call site as needed. I'd change that function to:

MID

private static String produceDescription() {
    return "You have to guess a number between " + lowerRange + " and " + upperRange + ".\n"
           + "You have " + tries + " tries.");
}

. . .

System.out.println(produceDescription());


POST

Why? Two highly-related reasons:

Whenever possible, functions should <em>return</em> the data that they produce. Can you guarantee that for a function like this you will <em>always</em> want to directly print that data? Let the caller decide how they want to use the data that the function produces. Forcing the data to be printed makes the function less useful in the long term. As an example...

If you ever decide to adapt this program to use a full GUI, you're directly printing and will need to modify every function that is calling <code>println</code>. The less functions you have that are using data in a specific way, the easier it will be to alter your program later.

I would not make everything <code>static</code> here. Again, what if in the future you wanted to run two games at the same time (like if you created a server that allows people to connect to it and play)? I'd get rid of <code>static</code> everywhere, and make everything plain instance methods/properties, then just instantiate a instance of the game in <code>main</code>.

<code>Main</code> is a poor name for this class. Ideally, it should be a description of what the object accomplishes. What if you ever imported this class so it can be used elsewhere? A class called <code>Main</code> doesn't make it immediately obvious what it is used for. I'd change the name to something like <code>NumberGuessingGame</code>.

SUBMITTED

GetAll().Where(x =&gt; x.InspectionTypeId == 1).ToListAsync();
        if (preInspectionCount.Count

PRE

MID

.Where(x =&gt; x.InspectionTypeId == 1)

POST

SUBMITTED

message)
{
    string accent("ÀÁÂÃÄÅàáâãäåÒÓÔÕÖØòóôõöøÈÉÊËèéêëÌÍÎÏìíîïÙÚÛÜùúûüÿÑñÇç");
    string sansAccent("AAAAAAaaaaaaOOOOOOooooooEEEEeeeeIIIIiiiiUUUUuuuuyNnCc");
    int i=0,j=0,k

PRE

Is it really that important to have the <code>MSWindowsFixedSizeDialogHint</code> flag set? Also, you don't actually fix the size of the window in this case. The Qt documentation also advises against using this flag, since it apparently doesn't behave nice in multi-monitor setups.

Even better would be to set a size constraint on the layout, as mentioned in <a href="https://doc.qt.io/qt-5/qwidget.html#setFixedSize" rel="nofollow noreferrer">the documentation for setFixedSize()</a>.

MID

string accent("ÀÁÂÃÄÅàáâãäåÒÓÔÕÖØòóôõöøÈÉÊËèéêëÌÍÎÏìíîïÙÚÛÜùúûüÿÑñÇç");
string sansAccent("AAAAAAaaaaaaOOOOOOooooooEEEEeeeeIIIIiiiiUUUUuuuuyNnCc");


POST

There it looks like you are just mapping every character to one which looks similar but without accents. However, in many languages, accents have a big impact on the sound, for example in German, "ä" sounds more like "eh" than "a". Even in French, "ç" sounds like "s" while where it is used, a "c" would have sounded like a "k".

You already apologized for using French variable and function names in the code. And from experience, I know many French developers prefer using French names in source code, so it's a culture thing that's probably hard to change. However, it has two drawbacks. First, it makes it harder to collaborate with non-French speaking persons on the same code. Second, since you are using C++ which uses English names for keywords, and the Qt library with is using English names as well, you are getting a horrible mix of languages in your code. For example:

SUBMITTED

const convertedObject

PRE

MID

const

POST

SUBMITTED

dpArr = {} #empty list for DP

def findMinSpaces(k, piStr, favNumArr):
    curr = ''
    ans = 0
    N = len(piStr)
    if( k == N):
        return 0
    for i in range(k, N):
        print(curr)
        curr += piStr[i]
        if(curr in favNumArr and i != N-1):
            if(curr not in dpArr):
                ans += 1 + findMinSpaces(i+1, piStr, favNumArr)
                dpArr[curr] = ans
            else:
                print("from dpArr")
                return dpArr[curr]    
    print(dpArr)
    return ans            


def minSpaces(piStr, favNumArr):
    return findMinSpaces(0, piStr, favNumArr)
print(minSpaces

PRE

'''
The Problem can be thought as string pattern matching, Where output will be minimum no of spaces in bigger string(piStr) to match maximum no of strings from list of smaller strings(favNumArr).
To solve this, we take one var "ans" to store no spaces and one variable "curr" to store the current pattern.
Now we iterate through the piStr and whenever we encounter(ith pos) that curr pattern is in favNumArr, we use recursion and call findMinSpaces for i+1 and increment ans with 1.
There is no need to use DP if we return from the loop with first occurrence of match and hence the loop will not run after it return value of recursion call.
The last return statement is to counter when i == N-1 when we reach the end of piStr.
The time complexity for this solution is O(n)
Any suggestion for further enhancement or if  breaks any edge case is open.'''

MID

def findMinSpaces(k, piStr, favNumArr):
    curr = ''
    ans = 0
    N = len(piStr)
    if( k == N):
        return 0
    for i in range(k, N):
        print(curr)
        curr += piStr[i]
        if(curr in favNumArr and i != N-1):
            ans += 1 + findMinSpaces(i+1, piStr, favNumArr)
            return ans
    return ans            

def minSpaces(piStr, favNumArr):
    return findMinSpaces(0, piStr, favNumArr)

print(minSpaces('',['3149v','40x9','15926535c897','1c4','932c3','84626c43383279','4c793']))


POST

SUBMITTED

missing

if __name__ == "__main__":
  filename, packet_size

PRE

Since you actually want to take action in case <code>idx</code> has the value <code>None</code>, you should likely also do that <code>if idx is None:</code>. This is also in-line with the <a href="https://www.python.org/dev/peps/pep-0008/#programming-recommendations" rel="nofollow noreferrer">Programming Recommendations</a> section of PEP8, which recommends to compare singleton values (like <code>None</code>) using <code>is</code>. The intent of <code>return not missing</code> can also be made more clear simply by doing <code>return True</code>. This also allows you to narrow down the scope of <code>missing</code> since it will only ever be needed if you pass this initial check.

The rest of the code is IMHO mostly as straightforward as it gets, so there are only a few minor points that may improve the readability of your code. First, you can get rid of the <code>continue</code> if you use <code>if ...: elif ...: else:</code> instead of <code>if ...: if ...: else:</code>. If you stick with your current branch structure, putting a blank line after the first <code>if</code> statement can make it clearer that this is actually a seperate block that is not to be seen as part of the later "condition chain". Regarding the <code>else</code> branch: I think here is a opportunity to stop the loop early. If I'm not mistaken, there is no chance <code>missing</code> will ever become <code>False</code> again once you have set it to <code>True</code>. So if you don't need to have all the discontinued sequence numbers to be printed to stdout, a simple <code>break</code> there would allow the loop to end the first time you entered the <code>else</code> branch. In that case <code>missing</code> could also be omitted altogether to be replaced by <code>return True</code> in the <code>else</code> branch and by <code>return False</code> at the end of the function.

MID

if __name__ == "__main__":

POST

Using <code>if __name__ == "__main__":</code> is considered good practice in Python to clearly mark what code is supposed to be run if the file is used as a script. Often, programmers go even further and wrap the code that is surrounded by <code>if __name__ == "__main__":</code> into a <code>main()</code> function. That way no variables pollute the global namespace if you run the script in an interactive Python interpreter.

SUBMITTED

arg)
#define STRINGIFY_(arg) #arg
#define ID(arg

PRE

gets me <code>myProject-mySub-1.01.c: No such file or directory</code>.  So <code>-E</code> has spaces and <code>#include</code> doesn't.

Clang is at least consistent.  With Clang 10, <code>#include</code> has spaces: <code>fatal error: 'myProject - mySub - 1.01.c' file not found</code> And Clang 10 and <code>-E</code> also has spaces <code>myProject - mySub - 1.01.c</code>.

In my opinion, Clang's behavior makes the most sense.  Suppose you wanted a space -- how else could you do that?

MID

#define ID(arg) arg


This is a common trick.  I think it's a good idea although it looks a little ugly when you have to use it in so many spots.

#define STRINGIFY(arg) STRINGIFY_(arg)
#define STRINGIFY_(arg) #arg


POST

This is fine, but I think it'd be clearer to define <code>STRINGIFY</code> below the helper macro it uses.

Can you get away with something like:

SUBMITTED

SSH  on ${SSH_SERVER_NAME}:${DEPLOY_DIR}"
                        //TODO: rename backup file
                        sh "ssh ${SSH_USERNAME}@${SSH_SERVER_NAME} tar -cvpzf ${BACKUP_FNAME} ${DEPLOY_DIR}/* "
                        sh "ssh ${SSH_USERNAME}@${SSH_SERVER_NAME} rm -R -f ${DEPLOY_DIR}/*"
                        sh "scp -rpC ${SOURCE_DIR}/* ${SSH_USERNAME}@${SSH_SERVER_NAME}:${DEPLOY_DIR}"
                        //TODO

PRE

I have found an inherent flaw in the backup and copy part. Namely 

MID

sh "ssh ${SSH_USERNAME}@${SSH_SERVER_NAME} tar -cvpzf ${BACKUP_FNAME} ${DEPLOY_DIR}/*"
sh "ssh ${SSH_USERNAME}@${SSH_SERVER_NAME} rm -R -f ${DEPLOY_DIR}/*"


Which both exand the asterisk on the local mashine, and  <a href="https://stackoverflow.com/questions/22222838/shell-script-calling-ssh-how-to-interpret-wildcard-on-remote-server">https://stackoverflow.com/questions/22222838/shell-script-calling-ssh-how-to-interpret-wildcard-on-remote-server</a> 

The solution for tar is simple: 

sh "ssh ${SSH_USERNAME}@${SSH_SERVER_NAME} tar -cvpzf ${BACKUP_FNAME} ${DEPLOY_DIR}"


POST

The solution for rm is more difficult.
I have considered the <a href="https://wiki.jenkins.io/display/JENKINS/SSH+Steps+Plugin" rel="nofollow noreferrer">ssh steps plugin</a>, but I would like some more surety of whether it would work before I try it...

Right now I am looking into <code>rsync</code> with the <code>--DELETE</code> flag set.

SUBMITTED

pragma once

#include &lt;parser/node/parse_node.hpp&gt;

namespace ql::parser {
    class ParseWithDescriptorNode : public ParseNode {
    protected:
        std::string_view m_InnerBody;
    public:
        ParseWithDescriptorNode(std::string&amp;&amp; body, std::string_view const&amp; innerBody, std::vector&lt;std::string&gt;&amp;&amp; tokens, ParentRef const&amp; parent)
                : ParseNode(std::move(body), std::move(tokens), parent), m_InnerBody(innerBody

PRE

<code>AbstractNode</code> must have a virtual destructor (if we have child classes, we'll be deleting them from a pointer to the base class).

It doesn't look like we require shared ownership of nodes, so we don't need to use <code>std::shared_ptr</code>. The parent node owns its children, and children have a non-owning pointer to the parent.

We can therefore use <code>unique_ptr</code> for storing the children, and a raw pointer to refer to the parent. This makes the code quite a bit simpler.

For "sink" arguments (function arguments that we want to copy and store internally), it's best to take them by value. The current code requires r-value references, <a href="http://blogs.microsoft.co.il/sasha/2014/08/21/c-sink-parameter-passing/" rel="nofollow noreferrer">which would force the user to do a copy themselves outside the class</a> if they don't want to move something, which is very awkward.

So we should be doing:

MID

    ParseWithDescriptorNode(std::string body, std::string_view innerBody, std::vector&lt;std::string&gt; tokens, ParentRef parent)
            : ParseNode(std::move(body), std::move(tokens), std::move(parent)), m_InnerBody(std::move(innerBody)) {
    }


(There's no point moving the <code>string_view</code>, but it's consistent, and there's no real downside).

Since we specify exact types here:

    using NodeFactory = std::function&lt;std::shared_ptr&lt;ParseWithDescriptorNode&gt;(std::string&amp;&amp;, std::string_view const&amp;, std::vector&lt;std::string&gt;&amp;&amp;, AbstractNode::ParentRef)&gt;;


It's kinda weird to use a generic lambda here:

        m_NamesToNodes.emplace(nodeName, [](auto&amp;&amp; block, auto const&amp; body, auto&amp;&amp; tokens, auto parent) {
            auto node = std::make_shared&lt;TNode&gt;(std::forward&lt;decltype(block)&gt;(block), body, std::forward&lt;decltype(tokens)&gt;(tokens), parent);
            node-&gt;parse();
            return node;
        });


POST

I guess the generic lambda is to get perfect forwarding working, but it's a bit confusing.

As above, the specification of <code>std::string&amp;&amp;</code> and <code>std::vector&lt;std::string&gt;&amp;&amp;</code> unnecessarily require r-value references, which isn't ideal.

SUBMITTED

from collections import deque
def algorithm(G, source_node, target_node, pusher, cutoff=5):
    queue = deque([[source_node]] if source_node in G else deque())
    while len(queue):
        path = queue.popleft()
        if len(path) == cutoff:  # no sense to keep this path, it not gonna fit the limit
            continue
        adjacency_nodes = G[path[-1]]  # all the neighbours from the latest node in this path
        if not len(adjacency_nodes):  # deadend reached: you can't get any further from this node and it doesn't fit the requirement, so just forgetting it
            continue
        for adjacency_node in adjacency_nodes:
            extended_path = path.copy() + [adjacency_node]  # might some smart linked list do any better here?
            if adjacency_node == target_node:
                pusher(extended_path)  # wow! found one! does not make sense

PRE

It seems wasteful to add a path to the queue only to discard it because it is too long.  It would be better to check the length before making a copy of the path and adding it to the queue.  Moreover, if <code>len(path) == is cutoff - 1</code> the only possible solution is if <code>target_node</code> is in <code>adjacency_nodes</code>.  So, something like this might be faster:

MID

from collections import deque

def algorithm(G, source_node, target_node, pusher, cutoff=5):

    if source_node not in G:
        return

    queue = deque([[source_node]])

    while queue:
        path = queue.popleft()

        adjacency_nodes = G[path[-1]]

        if not adjacency_nodes:
            continue

        if len(path) == cutoff - 1:
            if target_node in adjacency_nodes:
                pusher(path[:] + [target_node])

        elif len(path) &lt; cutoff - 1:
            queue.extend(path[:] + [node] for node in adjacency_nodes)


POST

If you are trying to optimize for speed, use the profiler in the standard library to see where the algorithm is spending time.

The algorithm is basically a breadth first search of the graph.  Because there is a depth cutoff, a depth first search might be faster because there isn't the overhead of copying the path and keeping the queue of paths to search.  But the only way to know is to implement it and see.

Lastly, the <a href="https://networkx.github.io/documentation/stable/reference/algorithms/generated/networkx.algorithms.simple_paths.all_simple_paths.html#networkx.algorithms.simple_paths.all_simple_paths" rel="nofollow noreferrer">networkx library</a> provides <code>all_simple_paths(G, source, target, cutoff=None)</code> which is a generator of all simple paths from <code>source</code> to <code>target</code> with a maximum length <code>cuttoff</code>. FYI, networkx uses a DFS search (<a href="https://networkx.github.io/documentation/stable/_modules/networkx/algorithms/simple_paths.html#all_simple_paths" rel="nofollow noreferrer">source code</a>).

SUBMITTED

FilesSet.Clone() as int[]);
            Hashes.Add

PRE

There's a problem with <code>Commit</code>: matching hash codes do not mean that two objects are equal ('pigeonhole principle'). For example, both <code>[1, 0]</code> and <code>[0, 31]</code> have hash code 31. You can only be sure that objects are not equal when their hash codes don't match - the inverse is not true.

Also, are you sure that reusing arrays is worth the effort? If <code>filesCount</code> is small, then the savings are small as well, and if <code>filesCount</code> is large, then the likelyhood that a specific state has occurred before is probably very small.

One alternative is to divide the state into multiple smaller arrays. This limits the impact of individual changes: you only need to copy a 'sub-array' (and create a new 'array-of-arrays'), instead of copying the full state. This also increases the likelyhood that a particular sub-array has occurred before, although I do not think that is something you need to be concerned about.

In Git terms, this is similar to using multiple files instead of a single large file. Committing changes to a single file only creates a new blob for the modified file and a new tree object that references the new blob (and older blobs for unmodified files).

Another alternative is to store a change-set for each value, using a binary search to find the value for a particular commit number. This can save a lot of space, but it'll make checkouts slower. Whether that trade-off is worth it depends on the intended use of this class.

MID

Clone() as int[]

POST

SUBMITTED

A = [3, 8, 9, 7, 6]
K

PRE

MID

K

POST

SUBMITTED

col = col + 1

    def check_status(self):
        if self.coords == []:
            return True
        else:
            return False

PRE

Avoid <code>is True</code>.  For example, <code>while flag is True:</code>.  Use <code>while flag:</code>

Avoid <code>if condition: return True else: return False</code>.  Use, <code>return condition</code>.  For example:

MID

    if ship_counters == 0:
        return True
    else:
        return False


should be:

    return ship_counters == 0


POST

Avoid <code>for idx in range(len(item)): blah(item[idx])</code>.  Use <code>for val in item: blah(val)</code>.

For example:

SUBMITTED

VARCHAR(100),
          pass VARCHAR(100),
          PRIMARY KEY(uid) );');
  if( ! $stmt ){ die("Error creating users table"); }

  $stmt = $pdo-&gt;query("INSERT

PRE

I would limit my review to db.php file only.

First of all, I see you made use of some of my advises already, probably visited some of my articles. Sadly, not all recommendations are followed, but that's OK, we'll review them.

The connection part is simply OK, nothing to review

Regarding the structure, I would say this file is a bit bloated. And contain a code belongs to different, so to say, <em>layers of responsibility</em>.  Such parts  as the connection and a pdo() function have a global responsibility. they could be used in any project and even in any part of every project.

Whereas other functions are quite specific and totally useless in any other project part. Also, the connection credentials are project-specific.

It order to make your design modular and reusable, I would

is frowned upon. it adds magic. You see a function call but have no idea where does it take the database connection from. It is always good to have all resources used by a function to be explicitly set.

Your current approach is simply redundant. In reality, you will never see an error message like &quot;Error creating users table&quot; - PDO will throw an exception and and halt the script execution prior that. So, all such code snippets

MID

if( ! $stmt ){ die(&quot;Error creating users table&quot;); }


POST

are rather useless and need to be removed.

Somewhere you are using it and somewhere not. It would be a good idea to make it consistent.

Let's rewrite save_doodle() function based on the tree recent recommendations:

SUBMITTED

currentGender = personSex;
            }
            if(!personSex.type.equals(currentGender.type)){
                currentGenderSemaphore.acquire();
                currentGender = personSex

PRE

Thread1 then proceeds, assuming there is still somebody in the bathroom:

MID

if (!personSex.type.equals(currentGender.type)) {


POST

But since <code>currentGender</code> has been set to null by Thread 2 when it left.... Bang.

SUBMITTED

crypt(encrypt

PRE

Some suggestions:

MID

encrypt

POST

SUBMITTED

psix, pseven, peight, pnine]

    hands += 1
    if hands == 1:
        break

PRE

<strong>Useless code:</strong>

MID

 hands += 1
 if hands == 1:
    break


POST

should be just <code>break</code> (given that the while loop is not already useless)

<strong>Code structure suggestions:</strong> Finally a better way to do this(which is an assignment left to you) if you insist on working on something with that level of difficulty, I suggest making the following functions:
A) a deck builder B) A poker hand scoring function C)A hand assessor/analyzer/comparison function and you might break these functions down to smaller functions and you go from there.

SUBMITTED

const AuthorsInfo

PRE

MID

AuthorsInfo

POST

SUBMITTED

double this[int i, int j] {
            get {
                return data[i, j];
            }
            private set {
                data[i, j] = value;
            }
        }

        public static int Precision {
            get;
            set;
        }

        static DMatrix() {
            Precision = 2;
        }

        public DMatrix(int n) {
            if (n &lt; 1) {
                throw new Exception($"Cannot create matrix," +
                                    $" N should be greater or equal to 1.\n\tN = {n}");
            }

            NbRows = NbCols = n;
            Fill(0);
        }

        public

PRE

I like that your braces and indentation is beautifully consistent. But, this is C#, and your Java is showing ;-) - Kudos for the mostly-consistent <code>PascalCase</code> type and member names, but it's the K&amp;R same-line <code>{</code> opening brace that clashes with the typical Allman next-line <code>{</code> opening brace standard most people would <em>expect</em> of C# code:

MID

public DMatrix(int n)
{
    if (n &lt; 1)
    {
        throw new Exception($"Cannot create matrix," +
                            $" N should be greater or equal to 1.\n\tN = {n}");
    }

    NbRows = NbCols = n;
    Fill(0);
}


POST

I would write auto-properties on a single line:

SUBMITTED

class Node

PRE

MID

Node

POST

But having a <code>vector&lt;vector&lt;motion_planner::Node&gt; &gt; grid</code> in the first place is a bit overkill. It meant you had to touch <em>every cell of the grid</em>, no matter how big the world or how small the area needed by the current query, so it does not scale well. That can be avoided:

SUBMITTED

section],
                category_class.title(),
                "Product URLs",
            ]
        )
        if cache_contents:
            if folder_name not in os.listdir(
                self.path + "Amazon/"
            ):
                os.mkdir(folder_name)
        os.chdir(folder_name)
        for category_name, category_url in names_urls:
            if print_progress:
                print(
                    f"Processing category {category_name

PRE

Perhaps, instead of printing, you could look into <a href="https://docs.python.org/3.5/library/logging.html" rel="nofollow noreferrer">logging</a>. You could then set the
logging level, avoid these ifs all over the place, and the <code>print_progress</code> argument become irrelevant.

Now that these two operations are decoupled, we can think of integrating the logging with the operation, and remove this test, as
what it effectively does it check that the user had the rights to modify this file, where an error would have been thrown earlier.
There also a code-path which is not tested: what happens if the files have never been cached, and <code>use_cached_content</code> is <code>False</code>?
Then the test returns false, even though function returns an empty list (a I think it should?)

The following block is prone to errors:

MID

if cache_contents:
    if folder_name not in os.listdir(self.path + 'Amazon/'):
        os.mkdir(folder_name)
os.chdir(folder_name)


This is because the path we're really working with is <code>os.path.join(self.path, 'Amazon', folder_name)</code>, but then we're changing directory
to <code>folder_name only</code>.

path = os.path.join(self.path, 'Amazon', folder_name)
if cache_content:
    if not os.path.exists(path):
        os.mkdirs(path)
os.chdir(path)


POST

I myself am not keen on changing paths all the time, because I find it hard to keep track of where I am.
That's why I'd rather build the full path, create directories and work from where I am:

SUBMITTED

lastDigit == 3) {
      ordinalInd = "rd"
    } else

PRE

MID

ordinalInd = "rd"

POST

SUBMITTED

Image ImageToFixedSize(Image originalImage

PRE

MID

Image originalImage

POST

SUBMITTED

C++17 implementation of ZipIterator by Dario Pellegrini &lt;pellegrini.dario@gmail.com&gt;
// Still unsure about the licence, but something in the line of just providing attribution
// October

PRE

<code>endReached</code> is the <code>ZipIter</code> pointing just at <code>b.end()</code>, i.e. where the iteration should stop. But the check against <code>zip.end()</code> fails, since not all iterators have yet reached their corresponding end iterator.

And this is where undefined behavior happens: <code>++endReached</code> advances a past-the-end-iterator, and after that nothing can be trusted anymore.

How can this be fixed?

The most common approach is to use a sentinel value as end iterator so that any <code>ZipIter</code> compares <code>true</code> if any (instead of all) of its contained iterators matches the corresponding end iterator.

MID

// Still unsure about the licence, but something in the line of just providing attribution


POST

When posting the code on this site, you have already released it under the CC-BY-SA 4.0 license. You can of course release it under another license model (you're free to do so as the license holder).

I won't repeat much of <a href="/a/231546/75307">Toby Speight's answer</a>, but some additional notes:

SUBMITTED

Sub ProcessStyles

PRE

MID

ProcessStyles

POST

SUBMITTED

enable_if_t&lt;std::is_base_of_v

PRE

MID

std::is_base_of_v

std::is_same_v

std::enable_if_t

POST

SUBMITTED

func (s *Schedule) worker

PRE

MID

Schedule.worker

POST

SUBMITTED

params['comms_matrix_id'] = $comms_matrix_id;
            }

            if (isset($params['comms_matrix_id'])) {
                $params['comms_matrix_id_exemptions'] = $params['comms_matrix_id'];
                unset($params['comms_matrix_id']);
            }
            if (isset($params['service_id'])) {
                $params['service_id_exemptions'] = $params['service_id

PRE

Instead of putting comments above smaller blocks of code, convert those smaller blocks to private methods (we will change this later, for now keep them private methods of the same class to allow focus on other things). 

But I would suggest you first familiarize yourself with IoC and DI as it will help you write much better code. And SOLID principles could also do you good.

Then anyway, to identify good blocks to replace by methods, you can: 

1) look if some blocks look same or similar to some other blocks, like this:

MID

if (isset($params['comms_matrix_id'])) {
  $params['comms_matrix_id_exemptions'] = $params['comms_matrix_id'];
  unset($params['comms_matrix_id']);
}


POST

or here:

SUBMITTED

all-pages

PRE

The code to get <code>$total</code> variable a good example of a cargo cult code.

MID

$all

POST

Finally, <a href="https://phpdelusions.net/pdo#fetchcolumn" rel="nofollow noreferrer">PDO supports different fetch types</a>, there is no point in using fetchAll() in <code>countComments</code>().  So the code should be just

SUBMITTED

bits 16
org 0x100

section

PRE

In the face of all else the assembler assumes a 16bit flat binary, so all that is required is;

~$ nasm ?.asm -o?.com

Although not wrong, but even <strong>bits 16</strong> is redundant. In operating system development you might <strong>use32</strong> or <strong>use64</strong> to utilize those instruction sets, but it would still be a flat binary file. Otherwise, the only thing that makes this type of executable unique is;

MID

    org 0x100


POST

This establishes the entry point, so a label like <strong>main</strong> is unnecessary unless it is required to branch back to the beginning of the application.

As to the question I asked in your original post, knowing what resources you have to deal with is monumentally important. DOS provides a lot of utility that can be found <a href="http://www.ctyme.com/intr/int.htm" rel="nofollow noreferrer">here</a>, therefore this

SUBMITTED

Now

  Application.ScreenUpdating = False
  Application.Calculation = xlCalculationManual

  datablock = Sheets("DataBlock").Range("Table1")
  selectedUnits = RangeToArray(Sheets("Tables").Range("SelectedCC"))
  ReDim selectKey(1 To UBound(datablock))
  ReDim selectFlag(1 To UBound(datablock))

  For x = LBound(datablock) To UBound(datablock)  ' loops thru the datablock
    If Contains(selectedUnits

PRE

Out of 6 references to the <code>datablock</code> variable, 5 are passing it as an argument to <code>LBound</code> or <code>UBound</code>; the other is reading a specific value in the table, and is probably indeed more efficient as an in-memory array read - but the <code>LBound</code>/<code>UBound</code> stuff shouldn't need to be re-computed 5 times.

MID

ReDim selectKey(1 To UBound(datablock))
ReDim selectFlag(1 To UBound(datablock))

For x = LBound(datablock) To UBound(datablock) ' loops thru the datablock


POST

Because the array came from <code>Range.Value</code>, it's <em>necessarily</em> a 1-based, 2D variant array: the <code>LBound</code> will always be <code>1</code>. You've hard-coded that <code>1</code> in 2 places, and computing it for the <code>For x</code> loop - that's inconsistent, but it's good practice to never assume what array bounds are when looping, so kudos for that.

I'd declare a local.

SUBMITTED

numbers[count - 1] * numbers[0])

print(computedNumbers

PRE

If the given <code>numbers</code> array is empty then the first loop will do nothing, but

MID

computedNumbers.append(numbers[count - 1] * numbers[0])


POST

aborts with a runtime exception. The correct result in this case would be to set <code>computedNumbers</code> to an empty array as well.

This

SUBMITTED

class FlightSearchManager {

    private val _flightSearchRequestModelLiveData : MutableLiveData&lt;FlightSearchRequestModel&gt; = MutableLiveData()
    val flightSearchRequestModelLiveData : LiveData&lt;FlightSearchRequestModel&gt

PRE

It is seen as code smell, when your method has too many parameters, so I would recommend to reduce the number of those in <code>fun updateFlightSearchRequestModel</code>.

You could create a single function for every parameter change. Of course it means more lines to write, but is cleaner, straight forward and not as error-prone to side effects since you don't change ~20 things in one method.

I would guess that you coded with something like <em>C#</em> before, because of the usage of underscores <code>_</code> in variable names. Please try to follow the appropreate convetion for this language (Kotlin), as well as in Java:

Local variables, instance variables, and class variables are also written in lowerCamelCase. Variable names should not start with underscore (_) or dollar sign ($) characters, even though both are allowed. This is in contrast to other coding conventions that state that underscores should be used to prefix all instance variables.

Constants: 

Constants should be written in uppercase characters separated by underscores. Constant names may also contain digits if appropriate, but not as the first character.

<a href="https://en.wikipedia.org/wiki/Naming_convention_(programming)" rel="nofollow noreferrer">Source</a>

Fields like this:

MID

private val _flightSearchRequestModelLiveData : MutableLiveData&lt;FlightSearchRequestModel&gt; = MutableLiveData()


would become:

private val flightSearchRequestModelLiveData : MutableLiveData&lt;FlightSearchRequestModel&gt; = MutableLiveData()


POST

Functions like this

SUBMITTED

var collision

PRE

MID

collision

POST

SUBMITTED

merge_sort(right_half)

    i = 0
    j = 0
    k = 0

    while

PRE

Everything I'm going to talk about is in the <code>merge_sort</code> function

MID

i = 0
j = 0
k = 0


POST

Can be defined as

<code>i = j = k = 0</code>

You should always leave spaces between operators as per <a href="https://www.python.org/dev/peps/pep-0008/" rel="nofollow noreferrer">PEP 8</a> rules

<code>i&lt;len(left_half)</code> should be <code>i &lt; len(left_half)</code>

Use <code>x += y</code> instead of <code>x = x + y</code>

<em>In my opinion</em>, I think using short and concise names such as <code>mid</code> or <code>middle</code> instead of <code>middle_index</code> would be better. If you don't wish to, you can leave it as it!

Use <a href="https://www.python.org/dev/peps/pep-0484/" rel="nofollow noreferrer">type hints</a>

Add <a href="https://www.python.org/dev/peps/pep-0257/" rel="nofollow noreferrer">docstrings</a>

Your function only takes into account the <code>left_half</code> of the array, and ignores what's left in the <code>right_half</code>

For example, if <code>nums</code> array was <code>[3, 9, 0]</code>, The array would be <code>[0, 3, 0]</code>

This would happen as

<code>merge_sort([3])</code> which won't change the <code>left_half</code>
<code>merge_sort([9, 0])</code> which would make the <code>right_half</code> as <code>[0, 9]</code>

Then, 

SUBMITTED

Field:=11, Criteria1:=workingArea

        namesColumn.SpecialCells(xlCellTypeVisible).Copy 'copies

PRE

Only visible rows of filtered data are copied.  There is no need to use <code>SpecialCells(xlCellTypeVisible)</code> when copying filtered data.    

MID

namesColumn.SpecialCells(xlCellTypeVisible).Copy


POST

I like the use of the constants <code>Const numberOfRowsBeforeRecords = 1</code> bit using it in conjunction with "C2" defeats the purpose.  Mainly

SUBMITTED

import subprocess

PRE

doesn't provide any <em>"exit"</em> condition. When the control flow will get into this <code>except</code> block and call the current function <code>first_picture()</code> again - that doesn't mean that all subsequent statements below (from previous context) won't be executed.<br>You would need to either enclose all statements after that block into <strong><code>else:</code></strong> block to make them execute on successful image opening or put <strong><code>return</code></strong> statement right below <code>first_picture()</code> call. 

<strong>But</strong> instead, what should be noticed beforehand is that both <code>get_first_picture</code> and <code>change_desktop</code> functions share the same common behavior that covers the following set of actions:

MID

subprocess

POST

The time delay is also has a common amount - <code>40</code> (In your <code>set_display_and_start_browser</code> function <code>time.sleep(20)</code> + <code>time.sleep(20)</code>, are indirectly added).<br><br>
That definitely calls for <strong><em>Extract function</em></strong> technique - the common/repeated behavior is extracted into a separate function, say <strong><code>set_desktop_background</code></strong>:

SUBMITTED

setCheckable(true);
    connect(mGuessWumpusAction, &amp;QAction::triggered, 
            this, &amp;Room::toggleGuessWumpus);

    mGuessBatAction = new QAction{tr("Has &amp;Bat

PRE

And now all three <code>connect</code> calls can use the same slot:

MID

connect(mGuessWumpusAction, &amp;QAction::triggered, this, &amp;Room::selfUpdate);


POST

The <code>QAction</code> will take care of the appearance and the boolean variable and all that is left is to change from checking the eliminated boolean variables to the states of the checkboxes like this: 

SUBMITTED

wiegandNum = new

PRE

Here are a number of ideas that may help you improve your program.

The <code>Serial.println();</code> call from within <code>getWeigand</code> really shouldn't be there.  It's better if the function does just one thing, and that is to calculate and return the number.

The code calls <code>new</code> but there isn't any matching <code>delete</code> which means that the program leaks memory.  It's better to make sure all memory is freed, but better still, see the next suggestion.

MID

new

POST

SUBMITTED

map drawline [maxheight,maxheight-1..1]
    in unlines ((map ($ calculatedcounts) linefunctions) ++ ["==========","0123456789"])

histogramcount :: [Integer] -&gt

PRE

There's no particular reason to name <code>linefunctions</code>, and if you write:

MID

map ($ calculatedcounts) (map drawline [maxheight,maxheight-1..1])


a pair of maps like this simplifies to a single map:

map (\height -&gt; drawline height calculatedcounts) [maxheigh,maxheight-1..1]


which might be more clearly written as a list comprehension anyway:

[drawline h calculatedcounts | h &lt;- [maxheight,maxheight-1..1]]


POST

giving:

SUBMITTED

package triangle

import (
    "sort"
    "math"
)

type Kind int

const (
    NaT = 1 // not a triangle
    Equ = 2 // equilateral
    Iso = 3 // isosceles
    Sca = 4 // scalene
)

// KindForomSides checks if a triangle is equilateral, isosceles, or

PRE

few things to say,

the <code>Kind</code> constants can be declared using the <code>iota</code> keyword.

MID

// Triangle kinds
const (
    NaT = iota // not a triangle
    Equ        // equilateral
    Iso        // isosceles
    Sca        // scalene
)


Some comments are broken btw, the linters will complain. Do you use one ?
Using atom and the go-plus plugin, it lints out of the box. Something similar must exists for vscode, for example.

Also, the naming <code>triangle.IsTriangle</code> does look repetitive, it is preferably avoided.

The <code>KindFromSides</code> function can declare the return variable in the out signature parameter and set its default value to the default original else case. It is somewhat less complex, so somewhat preferred.

// KindFromSides checks if a triangle is equilateral, isosceles, or scalene
func KindFromSides(a,b,c float64) (k Kind) {
    k = Sca

    if !IsTriangle(a,b,c) {
        k = NaT
    } else if a == b &amp;&amp; a == c {
        k = Equ
    } else if a == b || a == c || b == c {
        k = Iso
    }
    return k
}


You can also re arrange the constants declaration so <code>Sca</code> is the zero value


// Triangle kinds
const (
    Sca = iota // scalene
    NaT        // not a triangle
    Equ        // equilateral
    Iso        // isosceles
)

// KindFromSides checks if a triangle is equilateral, isosceles, or scalene
func KindFromSides(sides []float64) (k Kind) {
    a := sides[0]
    b := sides[1]
    c := sides[2]

    if !IsTriangle(sides) {
        k = NaT
    } else if a == b &amp;&amp; a == c {
        k = Equ
    } else if a == b || a == c || b == c {
        k = Iso
    }
    return k
}


Although, imho, it is better written like this


// Triangle kinds
const (
    NaT = iota // not a triangle
    Equ        // equilateral
    Iso        // isosceles
    Sca        // scalene
)

// KindFromSides checks if a triangle is equilateral, isosceles, or scalene
func KindFromSides(sides []float64) (k Kind) {
    a := sides[0]
    b := sides[1]
    c := sides[2]

    if IsTriangle(sides) {
        k = Sca
        if a == b &amp;&amp; a == c {
            k = Equ
        } else if a == b || a == c || b == c {
            k = Iso
        }
    }
    return k
}


POST

The tests are OK, although you don't use any un-exported <code>triangle</code> symbol, so it should belong to the <code>triangle_test</code> package.

Now i ran the benchmark,

SUBMITTED

lt;assert

PRE

MID

assert()

POST

The <code>assert()</code> macro is meant for code quality control, and is typically only used for debug builds. By defining <code>NDEBUG</code> in production builds, <code>assert()</code> will turn into a no-op.

When checking the provided arguments, such as whether <code>atoi(argv[1]) &gt; 0</code>, just use a regular <code>if</code>-statement, print an error message and exit with a non-zero return code. Otherwise, the program will either abort with an unhelpful message if the assert is still working, or it will cause a segmentation fault later on if it's compiled out.

SUBMITTED

using System.Collections.Generic;
using System.Linq;
using Microsoft.AspNetCore.Builder;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.DependencyInjection;
using SocialAppApi.Models;
using SocialAppApi.Repositories;

namespace SocialAppApi.Seeders
{
    public class DatabaseSeeder
    {
        public static void SeedDatabase( ApplicationDbContext applicationDbContext )
        {
            applicationDbContext.Database.Migrate();

            if ( !applicationDbContext.Users.Any() )
            {
                User user1 = new User
                {
                    FirstName = "Bikram",
                    LastName = "Bhandari",
                };

                User user2 = new User
                {
                    FirstName = "Sabina",
                    LastName = "Lamichhane",
                };

                User user3 = new User
                {
                    FirstName = "Jack",
                    LastName = "Wonderland",
                };

                Post user1Post = new Post
                {
                    Content = "This post is about fires going on in NSW"
                };

                List&lt; Comment &gt; user1PostComments = new List&lt; Comment &gt;
                {
                    new Comment {Content = "So sad to see this"},
                    new Comment {Content = "Let's hope for a rain"},
                };

                //add user1 post
                user1.Posts = new List&lt; Post &gt; {user1Post};
**Is this right?**
                    user1Post.Comments = user1PostComments;
                    user1.Comments = user1PostComments;
**Those two lines above**

                //add user1 post comments
                applicationDbContext.Users.AddRange( user1, user2, user3 );

                applicationDbContext.SaveChanges

PRE

and the process would something like this : 

MID

var user1 = new User
{
    FirstName = "Bikram",
    LastName = "Bhandari",
};

var user2 = new User
{
    FirstName = "Sabina",
    LastName = "Lamichhane"
};

var user3 = new User
{
    FirstName = "Jack",
    LastName = "Wonderland"
};

var post1 = new Post
{
    User = user1,
    Content = "This post is about fires going on in NSW"
};


var comments = new List&lt;Comment&gt;
{
    new Comment
    {
        User = user1,
        Post = post1,
        Content = "So sad to see this"
    },
    new Comment
    {
        User = user1,
        Post = post1,
        Content = "Let's hope for a rain"
    }
};


applicationDbContext.Users.AddRange(new List&lt;User&gt; { user1, user2, user3 });

applicationDbContext.Posts.Add(post1);

applicationDbContext.Comments.AddRange(comments);

applicationDbContext.SaveChanges();


POST

The collection then can be used on your business logic where needed.

SUBMITTED

include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;streambuf&gt;
#include &lt;vector&gt;
#include &lt;string&gt;

#define ALL(c) (c).begin(), (c).end()

stringstream str_buffer;

string extract()
{
    streambuf&amp; buffer = *str_buffer.rdbuf();
    vector&lt;char&gt; sequence(str_buffer.tellp());
    buffer.sgetn(sequence.data(), str_buffer.tellp());

    str_buffer.seekp(0);
    buffer.pubseekpos(0);
    return string(ALL(sequence

PRE

Your function modifies the get/put position of the buffer.  I think this is a bug, and it makes benchmarks misleading.  Try calling <code>extract</code> twice in a row -- you'll get different results.  You set the put position after calling <code>sgetn</code> but you should have set the get position.  This should be intuitive.  After a read, you "undo" your reading.  Fix the bug with something like this:

MID

string extract() {
    streambuf&amp; buffer = *str_buffer.rdbuf();
    vector&lt;char&gt; sequence(str_buffer.tellp());
    auto g = str_buffer.tellg();
    buffer.sgetn(sequence.data(), str_buffer.tellp());
    str_buffer.seekg(g); // seekg to the original position
    // as far as I can work out, buffer.pubseekpos is not necessary here?
    return string(ALL(sequence));
}


Your function still does not compute the same thing as <code>str</code>.  <code>str</code> returns the entire buffer.  Your function returns from the input position to the output position.  These are different -- try calling <code>str_buffer.seekg(3)</code> before comparing the output of the two functions if you want to see for yourself.  You could <code>seekg(0)</code> before you call <code>sgetn</code>:

    auto g = str_buffer.tellg();
    str_buffer.seekg(0);
    buffer.sgetn(sequence.data(), str_buffer.tellp());
    str_buffer.seekg(g);


I think this implementation is now correct enough to benchmark.  I tried the updated version vs <code>str</code> on <a href="http://quick-bench.com" rel="nofollow noreferrer">http://quick-bench.com</a>.  I used clang-9 and libstdc++(GNU).  I tried a <code>stringstream</code> with 1000 characters and also 10,000 characters.

This implementation is about 130 times slower than <code>str</code> with no optimizations and with -O1/Clang, and it is and 3.5 times slower with -O2/Clang.

How can you speed up your function?  Well the easiest way is to use <code>str</code>!  But let's make some small improvements.  You copy the buffer into a <code>vector&lt;char&gt;</code> and then copy the vector into a string.  What if we only have one string?

string extractOneString() {
    std::string sequence;
    sequence.resize(str_buffer.tellp());
    auto g = str_buffer.tellg();
    str_buffer.seekg(0);
    str_buffer.rdbuf()-&gt;sgetn(sequence.data(), str_buffer.tellp());
    str_buffer.seekg(g);
    return sequence;
}


POST

Now the unoptimized version is 3.5 times slower -- just like the optimized version before.  As it turns out, the Clang's -O2 was already making this change for you.

Still, 3 times slower is not good.

This is maybe not obvious, but if you look at the assembly (perhaps using <a href="http://godbolt.org" rel="nofollow noreferrer">http://godbolt.org</a>), you'll notice that <code>resize</code> calls memset to set the new buffer to zero.  That's not necessary since you're about to overwrite the buffer anyway.  There's no easy way to get around this (unless you count using <code>str</code>).  I think this contributes to the 3x slowdown (not sure and I don't think it's worth confirming).

A few notes about your code:

Don't use <code>using namespace std</code>.  People have written about this in lots of places so I won't here.

The <code>ALL</code> macro is ugly and unnecessary.  If you cannot stand to write iterators, look into the new ranges library.

It's worth learning sooner rather than later not to spend time optimizing the wrong thing.  You wrote this code and then (I) measured it.  Next time, measure your code first and then decide whether it's worth changing.  This has the added advantage that you're already set up to measure the code post change.

I think it's also worth focusing on the basic semantics of your program before worrying too much about measured performance.  An experienced C++ dev would see right away that your <code>extract</code> function has a unnecessary copies and would most likely fix that before profiling.  Learning to avoid copies and other idioms will help you avoid having to measure every little thing.

SUBMITTED

include &lt

PRE

You already ran into this problem with <code>is_empty()</code>.

MID

#include

POST

In <code>wrap.h</code>, you <code>#include &lt;ghc/filesystem.hpp&gt;</code>, but nothing in that header file uses it. You should remove it, unless you plan to make the functions take <code>ghc::filesystem::path</code>'s as parameters instead of <code>std::string</code>s.

SUBMITTED

letters_remaining = check_guess_against_secret

PRE

MID

check_guess_against_secret

POST

SUBMITTED

Implements ITableAction

PRE

MID

ITableAction

POST

With those changes there will no longer be a need for <code>TableActions</code>. There will also be no <code>TableManagerActions</code> to save in the <code>Tables</code> collection, and therefore nothing in common between <code>Table</code> objects in the <code>Tables</code> collection except that they all live on the same worksheet. 

At this point I'd do away with the <code>Tables</code> class entirely - the <code>AddAllTablesInSheet</code> method can become a module function that takes a sheet as a parameter and spits out a simple collection of <code>Table</code> objects, or maybe passes them to a class that does the event listening and handling.

SUBMITTED

len(lista

PRE

For me, the problem starts with the nested loops showing no specification of <em>what is to be achieved</em>, not even a suggested abstraction (being the body of a function given a <em>name</em>).  

Observations:

MID

lista

lista[3][i-1]

lista[2][i] &gt;= listc[1][j]

POST

SUBMITTED

function bubbleSort

PRE

MID

bubbleSort

POST

SUBMITTED

decrypted&lt;/param&gt;
    /// &lt;param name="d"&gt;, HMAC of the ciphertext&lt;/param&gt;
    /// &lt;returns&gt;, the decrypted message&lt;/returns&gt;
    public static byte[] Decrypt(ECDiffieHellman recipient, byte[] rBar, byte[] em, byte[] d)
    {
        // Convert R̄ to an elliptic curve point R=(xR, yR)
        var r = new ECParameters
        {
            Curve = recipient.ExportParameters(false).Curve,
            Q =
            {
                X = rBar.Skip(1).Take(32).ToArray(),
                Y = rBar.Skip(33).Take(32).ToArray(),
            }
        };
        r.Validate();

        // , the plaintext
        byte[] m;
        using (var senderEcdh = ECDiffieHellman.Create(r))
        {
            // Use ANSI-X9.63-KDF to

PRE

MID

    public static byte[] Decrypt(ECDiffieHellman recipient, byte[] rBar, byte[] em, byte[] d)
    {
        // Convert R̄ to an elliptic curve point R=(xR, yR)
        var r = new ECParameters
        {
            Curve = recipient.ExportParameters(false).Curve,
            Q =
            {
                X = rBar.Skip(1).Take(32).ToArray(),
                Y = rBar.Skip(33).Take(32).ToArray(),
            }
        };


POST

SUBMITTED

int amount

PRE

MID

amount

POST

SUBMITTED

list.add

PRE

MID

add()

POST

SUBMITTED

strict"
let

PRE

MID

let

POST

SUBMITTED

instancetype)initByResolvingBookmarkData:(NSData *)bookmarkData 
                                    options:(NSURLBookmarkResolutionOptions)options 
                              relativeToURL:(NSURL *)relativeURL 
                        bookmarkDataIsStale:(BOOL *)isStale 
                                      error:(NSError * _Nullable *)error

PRE

As of macOS 10.10 the <code>NSURL</code> class has a 

MID

+ (instancetype)URLByResolvingAliasFileAtURL:(NSURL *)url 
                                     options:(NSURLBookmarkResolutionOptions)options 
                                       error:(NSError * _Nullable *)error;


POST

initializer, which both reads and resolves the bookmark data. The function then simplifies to (now with automatic reference counting):

SUBMITTED

Dim c

PRE

The block of code below has a few issues. They are listed as I saw them to illustrate how cleaning up code leads you to find further ways to clean it:

MID

c

c

POST

SUBMITTED

dat.groupby

PRE

Always give your identifier/variable/function a meaningful name.<br>Most of your identifiers/variables should be renamed to reflect the actual intention and purpose.<br> A short sample of better naming: 

MID

dat

POST

SUBMITTED

SocketUnknowError";
}

AbstractSocket

PRE

MID

AbstractSocket

POST

These functions are supposed to be used on sockets, so make this explicit: they should be member functions of <code>AbstractSocket</code>.

SUBMITTED

memFd == -1)
    {
        perror

PRE

MID

perror()

POST

SUBMITTED

new Todo(idCounter, todoDescription, false)]
    );
    setIdCounter(idCounter + 1);
    setTodoDescription('');
  }

  function markTodoItemComplete(id) {
    const todoListClone = todoList.slice();
    todoListClone[id - 1].complete = true;
    setTodoList(todoListClone);
  }

  return &lt;&gt;
    {todoList.map

PRE

MID

 function markTodoItemComplete(id) {
    const todoListClone = todoList.slice();
    todoListClone[id - 1].complete = true;
    setTodoList(todoListClone);
  }


This seems me not good practice, what you could have done is just getting id(key) of array and just set it to true.
like

 function markTodoItemComplete(id) {
    todoListClone[id].complete = true;
  }


POST

SUBMITTED

Invoke();
        delete

PRE

MID

delete

POST

SUBMITTED

file :
    while

PRE

Now this could be a cool little file reader project you have. But the thing is, that you've not really implemented much.

MID

while

POST

SUBMITTED

quot;title

PRE

MID

title

POST

SUBMITTED

gt; fizzBuzzOutputsRepo

PRE

MID

fizzBuzzOutputsRepo

POST

SUBMITTED

game

PRE

MID

game()

POST

My questions are: is <code>int game()</code> doing too many things that I should split further into smaller functions?

You can definitely split up <code>game()</code> into more functions. There is no hard rule for when to split up a function. There are some rules of thumb, like if a function is more than one screen big or more than say 30 lines. However, the best way is to find blocks of code that are either very generic and could be reused elsewhere (you already do that with <code>press_enter_to_continue()</code> and <code>clear_screen()</code>), or blocks of code that can stand on their own. For example, most of the code inside the outer <code>while</code>-loop in <code>game()</code> deals with handling a single game of hangman. You could move it to its own function, so the <code>while</code>-loop is reduced to:

SUBMITTED

NavigationItem

PRE

The negative side of the resulting implementation is the mixing of classes. Initially independent, independent <code>Navigationservice</code> and <code>ShellViewModel</code> begin to depend on <code>NavigationConfig</code> and use it not only for configuration, but also in normal work to create and retrieve a key. I mean the methods <code>ConvertToKey()</code>, <code>GetPageKey()</code> required in: <code>NavigationConfig.AddNavItem()</code>, <code>NavigationService.Configure()</code>, <code>NavigationService.NavigateTo()</code>, <code>ShellViewModel.OnItemInvoked()</code>, <code>ShellViewModel.IsMenuItemForPageType()</code>.

Not to say that it is difficult to track such connections, but it will take time.

I keep the principle of one place, but in terms of levels.

Previously, the configuration process was delayed until the <code>ShellViewModel.InitializeNavigation()</code> (calling <code>NavigationConfig</code>). The following changes occur. <code>NavigationConfig</code> has been removed. Registering valid pages and creating elements for <code>NavigationView</code> are different levels. They are not in the same place.

MID

NavigationItem

POST

SUBMITTED

header[i] == "prodcode")
                        prodCodeColumn = i;
                }
                if (catCodeColumn.HasValue == false || prodCodeColumn.HasValue == false

PRE

It Is impossible for header[i] to be equal to two different values at the same time. Use else if or switch.

Further if you are super paranoid you might want to check that catCodeColumn And prodCodeColumn Is not assigned more than once. That would mean there Is a duplicit column header (one that you care of).

MID

catCodeColumn.HasValue == false || prodCodeColumn.HasValue == false


The comparision to false Is redundant, use the negation operator "!".

!catCodeColumn.HasValue || !prodCodeColumn.HasValue


Or use de Morgans law

!(catCodeColumn.HasValue &amp;&amp; prodCodeColumn.HasValue)


POST

In case some column value contains a comma character (not talking about the quotes needed for it to work), your implementation Will fail to handle it. Of course only if the csv ever contains such values. Even if it should not, you say that users can modify it as they like. Time to get paranoid!

You should not log everything to Console inside the function.  Especially not if you caught an exception, mute it and return possibly half-built result. Instead throw a custom exception, possibly let it carry the half-built list. But dont return with incomplete result. And put the logging to Its own scope.

Other than that I think your approach Is quite reasonable. If you cannot hardcode or configure the columns offset ať compile time, you have to determine it dynamically... But ofc if you used a proper csv parser with additional features like header checking, the code would look quite different, probably shorter...

SUBMITTED

const content = [{
    "document": "/content/path/document1.pdf",
    "date": "2020-02-20"
  }, {
    "document": "/content/path/file.docx",
    "date": "2019-02-20"
  }, {
    "document": "/content/abc/document2.docx",
    "date": "2018-06-20"
  }, {
    "document": "/document/order/order.pdf",
    "date": "2020-06-20"
  }, {
    "document": "/content/order/update.pdf",
    "date": "2018-03-21"
  }, {
    "document": "/content/author/author.pdf",
    "date": "2017-03-21"
  }, {
    "document": "/content/path/dummy.pdf",
    "date": "2016-02-15"
  }, {
    "document": "/content/dummy/dummy.docx",
    "date": "2015-12-15"
}];

let lastNumberOfYears = 2;
let selectedYearArray

PRE

And, the output on my desktop computer was this:

MID

[
  { document: '/content/path/document1.pdf', date: '2020-02-20' },
  { document: '/document/order/order.pdf', date: '2020-06-20' },
  { document: '/content/path/file.docx', date: '2019-02-20' }
]
Benchmark took 602501 nanoseconds
[
  { document: '/content/path/file.docx', date: '2019-02-20' },
  { document: '/content/path/document1.pdf', date: '2020-02-20' },
  { document: '/document/order/order.pdf', date: '2020-06-20' }
]
Benchmark took 89100 nanoseconds


POST

Note a slightly different sort order of the results.  I didn't see in your description if a specific sort order of results was required or not.

SUBMITTED

public class BubbleSort implements SortingAlgorithm {
    private int delay = GUIComponents.delaySlider.getValue() * 1000;

    @Override

PRE

Welcome to CodeReview, your program is advanced for high school. I have some suggestions for you:

MID

private int delay = GUIComponents.delaySlider.getValue() * 1000;


You repetead this line all the classes implementing one different sorting method, you could use a constructor and pass this as a value like the class below:

public class BubbleSort implements SortingAlgorithm {

    private int delay;

    public BubbleSort(int delay) {
        this.delay = delay;
    }

    //other methods
}

//after in your code
int delay = GUIComponents.delaySlider.getValue() * 1000;
SortingAlgorithm bubble = new BubbleSort(delay);


POST

I don't know if you are aware about the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html" rel="nofollow noreferrer">Map</a> class, that maps keys to value, you could use in the following way:

SUBMITTED

cross_positions)
        all_positions

PRE

and use <code>.add(position)</code> to add <code>position</code> to the set when a move is successfully made.

You are doing too much work with <code>all_positions</code>:

MID

        all_positions = {1,2,3,4,5,6,7,8,9}


The keys of <code>self.board</code> are all of the positions.  So the above statement can be replaced with simply:

        all_positions = set(self.board)


POST

If you changed the keys to be 0 through 8, or 'A' through 'I', using <code>set(self.board)</code> would automatically construct the correct set; you wouldn't need to change the hard-coded <code>{1,2,3,4,5,6,7,8,9}</code> set to the correct values, so is a win for program maintenance.

But wait.  From <code>all_positions</code>, you subtract <code>nought_set</code> and <code>cross_set</code>.  This leaves all the <code>self.board</code> positions which still have the value <code>&quot; &quot;</code>.  There is an easier way:

SUBMITTED

can send message");
                return;
            }

            Conversation conversation = initiator.getConversationHashMap(receiver.getId());
            if (conversation == null) {
                conversation = new Conversation

PRE

<strong>Never</strong> keep running with invalid state. <em>Bad programmer</em>. Down (the application)! 

If you should not get into such a state: <code>throw new IllegalStateException("Only initiator can send message")</code>.

MID

if (conversation == null) {
    conversation = new Conversation(initiator, receiver);
}


POST

Ugh, don't do this. Either use an empty conversation and intialize in the object, or - if that's too expensive - lazily instantiate a conversation.

Note that this is resolved if you let the user keep track of their own conversation(s). A good design will lead you into fewer traps.

SUBMITTED

visitedVertices.contains(edge.getDestination())) {
                        int edgeWeightCumulative =
                                shortestPathMap.get(currentVertex) +
                                        edge.getEdgeWeight();
                        int edgeDestinationWeight =
                                shortestPathMap

PRE

You could mistake it with a function when scrolling over the code.

I don't like breaking code like so:

MID

                        int edgeWeightCumulative =
                                shortestPathMap.get(currentVertex) +
                                        edge.getEdgeWeight();


POST

It's harder to read. Usually you want to split what is logically splittable but not single statements.

<em>You have more places with strange breaks but I guess you wanted to do it for the post here. Just keep in mind to put a little bit more thoughts into breaks. I won't repeat for the other places.</em>

You don't have an empty line at the beginning of <code>DirectedGraphWithWeights</code> like in the other classes. Please decide for one thing and do it consistently.

Please add a space after keywords for control structures.

SUBMITTED

be combined.
# For example, combining "10-1" and "10-0" gives us "10--".
def combine(implicant_a, implicant_b):
    str_a, nums_a = implicant_a
    str_b, nums_b = implicant_b

    def combine_str

PRE

This:

MID

def combine(implicant_a, implicant_b):
    str_a, nums_a = implicant_a
    str_b, nums_b = implicant_b


should go in one of two directions:

def combine(str_a, nums_a, str_b, nums_b)

def combine(implicant_a, implicant_b):
    # Refer to implicant_a.str and implicant_a.nums


POST

This <code>combine</code> function also has a problematic return type - mixed boolean-or-combined-implicant. Returning <code>False</code> on failure is a C-ism. In Python, the saner thing to do is raise an exception, and then catch it (or not) in the calling code.

SUBMITTED

def click(object):
    [i,j] = object.values()

    if

PRE

also, parens are not necessary.

MID

[i,j] = object.values()


can be

i, j = object.values()


POST

That said: is <code>object</code> a <code>dict</code>? The order of values, after Python 2, is no longer non-deterministic, but (if I remember correctly) in insertion order. Generally it's a bad idea to rely on this order. You should rethink the way that these are stored and looked up. Can you rely on the key instead?

SUBMITTED

private double

PRE

MID

double

POST

SUBMITTED

X = _X;
        Y = _Y;
    }
    long long getX()
    {
        return X;
    }
    long long getY()
    {
        return Y;
    }

};

bool StringContainsInteger(const std::string &amp; str)
// true : if the string contains an integer number (possibly starting with a sign)
// false: if the string contains some other character(s)
{
    std::string::size_type str_len = str.length();
    if (str_len == 0) return false;

    bool sign_present = (str[0] == '-' || str[0] == '+');
    if (str_len == 1 &amp;&amp; sign_present) return false;

    for (std::string::size_type i = 0; i &lt; str_len; i++)
    {
        if (i == 0 &amp;&amp; sign_present) continue;
        if (! std::isdigit((unsigned char) str[i])) return false;
    }

    return true;
}


// https://stackoverflow.com/a/59663458/1997354
inline __attribute__((always_inline)) \
unsigned long MyXGetPixel(XImage * ximage, const int &amp; x, const int &amp; y)
{
    return (*ximage-&gt;f.get_pixel)(ximage, x, y);
}

void MyGetPixelColor(Display * my_display, const int &amp; x_coord, const int &amp; y_coord, XColor * pixel_color)
{
    XImage * screen_image = XGetImage(
        my_display,
        XRootWindow(my_display, XDefaultScreen(my_display)),
        x_coord, y_coord,
        1, 1,
        AllPlanes,
        XYPixmap
    );
    pixel_color-&gt;pixel = MyXGetPixel(screen_image, 0, 0);
    XFree(screen_image);
    XQueryColor

PRE

This function is also quite convoluted:

MID

bool StringContainsInteger(const std::string &amp; str)
// true : if the string contains an integer number (possibly starting with a sign)
// false: if the string contains some other character(s)
{
    std::string::size_type str_len = str.length();
    if (str_len == 0) return false;

    bool sign_present = (str[0] == '-' || str[0] == '+');
    if (str_len == 1 &amp;&amp; sign_present) return false;

    for (std::string::size_type i = 0; i &lt; str_len; i++)
    {
        if (i == 0 &amp;&amp; sign_present) continue;
        if (! std::isdigit((unsigned char) str[i])) return false;
    }

    return true;
}


which is basically just:

bool StringContainsInteger(std::string_view str)
{
    // C++20: str.starts_with('+') || str.starts_with('-')
    if (!str.empty() &amp;&amp; (str[0] == '+' || str[0] == '-')) {
        str.remove_prefix(1);
    }
    return std::all_of(str.begin(), str.end(),
                       [](unsigned char c) { return std::isdigit(c); });
}


POST

(note that <code>std::string_view</code> is preferable to <code>const std::string&amp;</code> if all you want is read the characters in the string).

SUBMITTED

initialize(struct compiler *comp, char *filename)
{
    static struct symbol symtable['z' - 'A'];
    static memtype sml[MEMSIZE];
    static char flag[MEMSIZE];
    size_t i;

    comp-&gt;symtable = symtable;
    comp-&gt;sml = sml;
    comp-&gt;flag = flag;
    comp-&gt;memsize = MEMSIZE;
    comp-&gt;file = filename;
    comp-&gt;ln = 1;
    comp-&gt;inscount = 0;
    comp-&gt;datacount = comp

PRE

and then all of the defaults assigned in a single statement.

This:

MID

static struct symbol symtable['z' - 'A'];
static memtype sml[MEMSIZE];
static char flag[MEMSIZE];

comp-&gt;symtable = symtable;
comp-&gt;sml = sml;
comp-&gt;flag = flag;


POST

is nasty. From the outside it <em>looks</em> like <code>compiler</code> is a re-entrant structure, but in actuality the memory is shared. A naive caller would pass in two different compiler instances, and then be surprised when data leaks from one to the other.

I would assume that this:

SUBMITTED

n-1);  
} 

int main() 
{ 
    struct Node* head = NULL; 

    push

PRE

In C++ we use <code>nullptr</code> rather than <code>NULL</code>.

MID

    struct Node* head = NULL; 


POST

The difference is that <code>nullptr</code> is correctly typed as a pointer, while NULL is a macro (bad) for an integer (bad type). Thus you can not incorrectly use <code>nullptr</code> while <code>NULL</code> can be abused.

In C++ we use the C++ streams <code>std::cout</code>.

SUBMITTED

EMailGenerationSystem;
    }
    public EmailTemplate getEmail(EmailGeneratorFactory factory){
        return factory.createEmail

PRE

Design patterns provide means to solve common problems. Every pattern has its purpose and allows to solve a particular problem (or more precisely, a class of problems with common aspects).

You should not ask yourself "Does my code follow a particular design pattern?". But rather "Does my code follow the right design pattern to solve a particular problem?"

Factory method pattern serves the purpose of decoupling interface implementation from its consumer.

Abstract factory pattern is actually very similar. You may even say that an abstract factory also follows factory method pattern. But the main difference is that abstract factory acts a bit like a pallete of similar objects to create. So in fact, it acts like multiple factory methods at the same time. These individual methods of abstract factory usualy return the same interfaces or subtypes, although I don't think it is strictly necesary.

Factory methods offer instantiation of a polymorphic object, where consumer is not interseted in aspects of the implementation.

Whereas abstract factory leaves the decision over the aspects of the created implementation to consumer which will decide based on the algorithm the consumer implements.

Now what's wrong with the implementation you showed us.

MID

public EmailTemplate getEmail(EmailGeneratorFactory factory){
    return factory.createEmail();
}


POST

Do you see the usefulness of this method? I don't. The caller must know the <code>EmailGeneratorFactory</code> instance, and it must know the instance of this singleton class. But nothing extra is done in addition to what can be done with the <code>EmailGeneratorFactory</code> alone. Calling <code>factory.createEmail()</code> can be done directly.

Since <code>EMailGenerationSystem</code> class does not offer anything else, it is useless as a whole. I suspect that the author of the article you've linked did not understand it himself. And this code is not supposed to be a generic part of the pattern, but rather your application code, where somehow you have got an instance of the factory and do some work with it at some point of logic in your app.

Now, I already mentioned in comments that I see factory methods twice, and no abstract factory at all, in your code.

Let me write just one factory method.

Please excuse any ommited public modifiers, etc, as I am not used to Java.

SUBMITTED

Tuple[int, str]) -&gt; None:
        """
        Saving the picture content
        :param new_pictures: Tuple[int, str]
        :return: None
        """

        number, link = new_pictures
        with open(self.folder / f'Image{number}.jpg', 'wb') as f:
            content_of_picture = self.http_base.get(link).content
            f.write(content_of_picture)

    def

PRE

<code>urllib.parse.urljoin</code> could use a <code>from urllib.parse import urljoin</code>.

You pass this into <code>submit</code> - <code>urllib.parse.urljoin(link, '?__a=1')</code> - and then fetch <code>url.split()[0]</code>. Why call <code>split</code> at all? Does the original string actually have spaces in it? If so, that should be taken care of before it's passed into <code>submit</code>. Also, don't call <code>urljoin</code> for a query parameter - instead, pass that QP into <code>get</code>'s <code>params</code> argument.

Regarding this:

MID

    with open(self.folder / f'Image{number}.jpg', 'wb') as f:
        content_of_picture = self.http_base.get(link).content
        f.write(content_of_picture)


POST

The problem with using <code>content</code> is that it loads everything into memory before being able to write it to a file. Instead, pass <code>stream=True</code> to <code>get</code>, and then pass <code>response.raw</code> to <code>shutil.copyfileobj</code>.

SUBMITTED

__typename")}')

    def download_video(self, new_videos: Tuple[int, str]) -&gt; None:
        """
        Saving the video content
        :param new_videos: Tuple[int,str]
        :return: None
        """
        number, link = new_videos

        with open(self.folder / f'Video{number}.mp4', 'wb') as f:
            content_of_video = self.http_base.get(link, stream=True).raw
            shutil.copyfileobj(content_of_video, f)

    def

PRE

doesn't ever use <code>self</code>, which is a big clue that it doesn't belong as an instance method. You should just make it a <code>@staticmethod</code>. The only reason I don't recommend it moving to global scope is that it still has knowledge of the Instagram data format, with its reference to <code>graphql</code>.

The loop in <code>get_fields</code> can be replaced with a call to <code>functools.reduce(dict.get, keys, media)</code>. Also, <code>keys</code> - even though it is a variadic argument - can still receive a type hint, and should be <code>Iterable[str]</code>. <code>nodes</code> itself, if you don't know a lot about the structure of the dictionary, can still be narrowed to <code>nodes: Dict[str, Any]</code>.

Now that you're using the streaming interface for Requests (nice!), it's more important that you use the response object as a context manager. For more information read <a href="https://github.com/psf/requests/issues/4136" rel="nofollow noreferrer">https://github.com/psf/requests/issues/4136</a>

Basically:

MID

with open(self.folder / f'Video{number}.mp4', 'wb') as f, \
     self.http_base.get(link, stream=True) as response:
    shutil.copyfileobj(response.raw, f)


POST

SUBMITTED

TicTacToe.turnNumber

PRE

MID

turnNumber

POST

SUBMITTED

gt;array);
        if (newp == NULL)
            err(EXIT_FAILURE, "realloc");
        nl-&gt;array = newp

PRE

I <em>very</em> strongly recommend to <em>always</em> type explicit braces, even around one-liners, e.g.

MID

if (newp == NULL) {
    err(EXIT_FAILURE, "realloc");
}


POST

Every time you feel compelled to put a comment like <code>/* count newlines and create array of pointer to lines */</code>, or <code>/* randomly permutate lines */</code>, it is a strong indication that the commented piece of code wants to be a function.

In general, avoid naked loops. A loop implements an algorithm, and hence deserves a name.

The shuffling algorithm

SUBMITTED

rows
    for (int i = 0; i &lt; height; i++)
    {
        //loop through image pixels
        for (int j = 0; j &lt; width; j++)
        {
            //calculate average value for each pixel
            average = 1.0 * (image[i][j].rgbtBlue + image[i

PRE

This way you avoid uninitialized variables, and you will never have to scroll up/down/up/down... while reading your C code.

As a nit, I think instead of <code>1.0 * (...) / 3</code> you could just as easily have written <code>(...) / 3.0</code>.  Or better yet, just do integer division.  You're about to round anyway.  Does it matter if you are 0.33/255 off?

Either way, if you're going to round average, you might as well make it an <code>int</code> and then call <code>round</code> once instead of calling <code>round(average)</code> three times.

In the function <code>reflect</code>:

How about making a function <code>void swap(BYTE* lhs, BYTE* rhs, int size);</code>?  Then you can write

MID

for (int i  ....) {
    for (int j .....) {
        swap(image[i][j], image[i][width - j - 1], sizeof(RGBTRIPLE));
    }
}


POST

instead of 9 bulky lines of code.

In the function <code>blur</code>:

SUBMITTED

x (void

PRE

MID

(void)

POST

SUBMITTED

class GrayVideo

PRE

MID

GrayVideo

POST

SUBMITTED

stdc++.h&gt; 
 using  namespace std

PRE

Please never use it.<br />
You are supposed to include only the headers you need.

This is not a good idea:

MID

 using  namespace std ;


POST

Please read the article: <a href="https://stackoverflow.com/q/1452721/14065">Why is “using namespace std;” considered bad practice?</a>

The main issue is that it can completely change the meaning of code without causing any kind of compiler warning.

The reason the &quot;standard&quot; library is named &quot;std&quot; is so that it is not a big issue to prefix things in the standard library with <code>std::</code>. This is the preferred technique.

In C++ we have deprecated the use of <code>NULL</code> and replaced it with <code>nullptr</code>. The difference is that <code>NULL</code> is a macro that evaluates to the integer zero while <code>nullptr</code> has a specific type of <code>std::nullptr_t</code>. The advantage of this is that <code>nullptr</code> can only be assigned to pointer types while <code>NULL</code> can be assigned to pointers and any integer type (which has caused issues).

SUBMITTED

board"""
    shapes

PRE

<strong>Repeat 10 times: "I will keep to DRY principles".</strong>

If you repeat such a line, then put the line in a function and call that. If you add another method of clearing the screen then likely one of the locations with the same line of code will be forgotten. Looking at the comment, you've already thought of a name and started typing.

Of course, there is a lot of DRY (don't repeat yourself) failures where the same code is used but with different integer values, but this one stood out.

MID

shapes = [...]


POST

Do you really want that variable to be assigned the entire shape all the time? That needs to be a constant or - in real code - a resource that is being read <em>once</em>.

SUBMITTED

dd ?
    currentRow dd ?
    currentColumn dd ?
    numberBeforeTheImmediatelyAboveOne dd ?
    numberImmediatelyAbove

PRE

I find it very confusing that you consider all of this assembly as <em>inline</em> assembly. I see the start and exit of a regular FASM assembly program, 2 things I don't expect to find in <em>inline</em> assembly.

Am I correct when I say that your high level language only uses single precision float variables? If not then variables like <em>numberOfRows</em>, <em>currentRow</em>, and <em>currentColumn</em> should be treated like dword integers for speed and frankly because that's what they truly are.

MID

numberBeforeTheImmediatelyAboveOne dd ?
numberImmediatelyAbove dd ?


POST

While using descriptive names is encouraged, having source lines that are much longer than the visible screen's width makes reading a lot more difficult. Perhaps you could make use of FASM's line continuation character <code>\</code> ?

SUBMITTED

str(input

PRE

MID

input

POST

SUBMITTED

interface Predicate&lt;T&gt; {
  (x: T) : boolean
}

class PredicateBuilder&lt;T&gt; {
  condition: Predicate&lt;T&gt;;

  constructor(condition: Predicate&lt;T&gt;) {
    this.condition = condition;
  }

  public and(input: PredicateBuilder&lt;T&gt; | Predicate&lt;T&gt;): PredicateBuilder&lt;T&gt; {
    const p: Predicate&lt;T&gt; = this.condition;
    const q: Predicate&lt;T&gt; = this.extractCondition(input);

    return new PredicateBuilder((x: T) =&gt; p(x) &amp;&amp; q(x));
  }

  public or(input: PredicateBuilder&lt;T&gt; | Predicate&lt;T&gt;): PredicateBuilder&lt;T&gt; {
    const p: Predicate&lt;T&gt; = this.condition;
    const q: Predicate&lt;T&gt; = this.extractCondition(input);

    return new PredicateBuilder((x: T) =&gt; p(x) || q(x));
  }

  public not(): PredicateBuilder&lt;T&gt; {
    return new PredicateBuilder((x: T) =&gt; !this.condition(x));
  }

  public apply(x: T): boolean {
    return this.condition(x);
  }

  private extractCondition(input: PredicateBuilder&lt;T&gt; | Predicate&lt;T&gt;): Predicate&lt;T&gt; {
    let condition: Predicate&lt;T&gt;;
    if ("condition" in input) {
      condition = input.condition;
    } else {
      condition = input;
    }

    return condition

PRE

As pointed out as a comment, I was unhappy about the <code>extractCondition</code> function.
This function handles, variables which do conform your <code>Predicate&lt;T&gt;</code> type. Which is fine, but I think this doesn't belong here.
Because a <code>Predicate</code> should have an <code>accept</code> or, if we talk about the Java implementation, <code>test</code> function.
This is not given when we can pass on <em>any</em> random function which do return a <code>boolean</code>. But does not conform our design of a <code>Predicate</code>.

Next <em>naming</em>, the <code>PredicateBuilder</code> seems okay-ish, but it feels wrong. As it isn't a builder in the classical sense.
Furthermore we have to work around functional interfaces, and this is I think the main pain point. To achieve this I would propose to rename the <code>Predicate&lt;T&gt;</code> interface, as it should be describing what a Predicate holds (a function which takes a parameter and returns a boolean). Therefore the name <code>Predicate</code> is available again and should be used instead of <code>PredicateBuilder</code>.

The repetition regarding <code>and</code>, <code>or</code>, etc... feels also some kind off. But I think that's because you always do <code>extractCondition</code> and other stuff (I've eliminated this in my suggestion, as the Java Predicate implementation does basically the same). Plus I've create a static method <code>Predicate#of(...)</code> to <em>easier</em> "get" a new Predicate. This reduces the mess a bit, but changing the operands is also still a bit clumsy, in my opinion.

Oh and btw. I've felt free to use arrow functions :-)

MID

interface InternalPredicate&lt;T&gt; {
  (x: T) : boolean
}

class Predicate&lt;T&gt; {
  constructor(private condition: InternalPredicate&lt;T&gt;) {}

  public static of = &lt;T&gt;(condition: InternalPredicate&lt;T&gt;) =&gt; {
    return new Predicate(condition);
  }

  public and = (input: Predicate&lt;T&gt;): Predicate&lt;T&gt; =&gt;
    Predicate.of((x: T) =&gt; this.apply(x) &amp;&amp; input.apply(x));

  public or = (input: Predicate&lt;T&gt;): Predicate&lt;T&gt; =&gt;
    Predicate.of((x: T) =&gt; this.apply(x) || input.apply(x));

  public not = (): Predicate&lt;T&gt; =&gt;
    Predicate.of((x: T) =&gt; !this.apply(x));

  public apply = (x: T): boolean =&gt; this.condition(x);
}


Those are my two cents to the Predicate implementation, feel free to discuss them with me.

Alternative solution to eliminate the <code>InternalPredicate</code> and to support functions which are booleans:

type PredicateType&lt;T&gt; = (x: T) =&gt; boolean;

class Predicate&lt;T&gt; {
        constructor(private condition: PredicateType&lt;T&gt;) {}

        private static isInstance = &lt;T&gt;(input: Predicate&lt;T&gt; | PredicateType&lt;T&gt;): Predicate&lt;T&gt; =&gt; (input instanceof Predicate) ? input : Predicate.of(input);

        public static of = &lt;T&gt;(condition: PredicateType&lt;T&gt;) =&gt; new Predicate(condition);

        public and = (input: Predicate&lt;T&gt; | PredicateType&lt;T&gt;): Predicate&lt;T&gt; =&gt;
          Predicate.of((x: T) =&gt; this.apply(x) &amp;&amp; Predicate.isInstance(input).apply(x));

        public or = (input: Predicate&lt;T&gt; | PredicateType&lt;T&gt;): Predicate&lt;T&gt; =&gt;
          Predicate.of((x: T) =&gt; this.apply(x) || Predicate.isInstance(input).apply(x));

        public not = (): Predicate&lt;T&gt; =&gt;
          Predicate.of((x: T) =&gt; !this.apply(x));

        public apply = (x: T): boolean =&gt; this.condition(x);
}


POST

It comes pretty close the the <code>extractCondition</code> approach, but the main difference here is, that a new instance is created if the input is a <em>raw</em> function. This adds up to be more robust to changes and being less error prone. Another advantage is, we don't care about how the predicate internally works, we're just in charge of returning a predicate based on the input. This clears up the use case of the function a bit more. 

<strong>EDIT</strong>: As discussed in the comments, it is <em>nicer</em> to merge the private <code>isInstance</code> function into the static <code>of</code> function.

SUBMITTED

scores:
            score = line.split()
            if score[0] == self.name:
                self.current_score = int(score[1])
                self.UserFound = True
                scores.close()
                return
        self.UserFound = False


    def CreateNewUser(self):
        scores = open('rating.txt', 'a')
        print(f'\n{self.name} 0', file=scores, flush=True)
        scores.close()


    def check_choice(self, human

PRE

We can see the error appears that the <code>user_found</code> flag isn't being set correctly. Of course! Let's fix that:

MID

def create_new_user(self):
    scores = open('rating.txt', 'a')
    print(f'\n{self.name} 0', file=scores, flush=True)
    scores.close()
    self.user_found = True


POST

and let's delete the file <code>rating.txt</code> just to make sure this particular test runs properly -

SUBMITTED

sentances.
    float

PRE

MID

float

float gradeLevel(char* input);

POST

SUBMITTED

back() &lt;&lt; endl;
    trie&lt;char&gt; t;
    for (string const&amp; w: words) t.insert(w);
    for (string const&amp; w: t.match("bar")) cout &lt;&lt; w &lt;&lt; endl;
    for (string const&amp; w: t.match("br")) cout &lt;&lt; w &lt;&lt; endl;

    return

PRE

<em>bug:</em>

Trie implementations need to mark word endings somehow. e.g. If you add the word "bar" to end of the input string, it won't be inserted in the trie (because the trie already contains the whole word as a prefix of other words, e.g. "barndoor"). We can't tell that the word "bar" is there as a separate word because the last letter isn't a leaf node.

To mark the end of a word we need to either insert a special character that will always end up in a leaf node (e.g. '\0' or '~'), or add a boolean variable to <code>node_t</code>. (Using a special character may be more efficient, but obviously means we can't store strings containing that character).

<em>fun(?) fact:</em>

If you reduce the input to just "bard", it will be printed by both of your <code>match</code> loops:

MID

for (string const&amp; w: t.match("bar")) cout &lt;&lt; w &lt;&lt; endl;
for (string const&amp; w: t.match("br")) cout &lt;&lt; w &lt;&lt; endl;


POST

That seems incorrect.

I'm not sure if it's causing the above issue, but this looks suspicious:

SUBMITTED

scheduleUsers.lstOnlineProctoring[k]);
                }

            } else {
                angular.forEach($scope.selectedUserListOP, (el, idx) =&gt; {
                    if(el.StudentScheduleUsrID === $scope.scheduleUsers.lstOnlineProctoring[k].StudentScheduleUsrID) {
                        $scope.selectedUserListOP.splice(idx, 1);
                    }
                });
            }
        }
    } catch(e) {
                console.log('Method: selectAllProctoringUser:  ' + e.message

PRE

I see what looks like a bug. The <code>x</code> variable (which should probably be renamed to something more informative - maybe <code>user</code>?) is a object (with <code>selected</code> and <code>StudentScheduleUsrID</code> properties) which you remove from the array in the upper code with

MID

} else {
    angular.forEach($scope.selectedUserListOP, (el, idx) =&gt; {
        if(el.StudentScheduleUsrID === $scope.scheduleUsers.lstOnlineProctoring[k].StudentScheduleUsrID) {
            $scope.selectedUserListOP.splice(idx, 1);
        }
    });
}


<code>splice</code>'s first argument should be the <em>index</em> of the element you want to start deleting from. That's fine. But in the lower code, the first argument you pass to <code>splice</code> is the <em>object</em> <code>x</code>, not the index:

$scope.scheduleUsers.lstOnlineProctoring.forEach(x =&gt; {
  // ...
  } else if(!checked){
      if($scope.selectedUserListOP.filter(m =&gt; m.StudentScheduleUsrID == x.StudentScheduleUsrID).length &gt; 0)
          $scope.selectedUserListOP.splice(x, 1);
  }


That won't work, because the first argument is not a number. If you want to remove this <code>x</code> from the array there, find its <em>index</em> in the array with <code>findIndex</code>, then pass that number to <code>splice</code>.

const selectedUserIndex = $scope.selectedUserListOP.findIndex(
  selectedUser =&gt; selectedUser.StudentScheduleUsrID === user.StudentScheduleUsrID
);
if (selectedUserIndex !== -1) {
  $scope.selectedUserListOP.splice(selectedUserIndex, 1);
}


POST

On a different note: Errors <strong>should not arise</strong> in synchronous code in most cases. If you have code that sometimes results in an unexpected error, you should fix the code so that the error doesn't ever occur (as far as you can tell). If you've tested the code in various situations (which you should be doing anyway, as a developer) and you can't think of any which might cause an error to occur, there shouldn't be any reason to use <code>try</code>/<code>catch</code>, since it'll just clutter up the code - and besides, you aren't doing anything with the error other than logging it to the console, but the error will be logged to the console anyway. So, feel free to remove the <code>try</code>/<code>catch</code>.

It can be reasonable to have a <code>try</code>/<code>catch</code> if any of the following are true <em>and</em> you can do something useful with the error (such as send it to your server logs for examination, or gracefully degrade functionality for the user):

SUBMITTED

quit game""")
    list = ["rock","paper","scissors"]
    while True:

        a_player = input(f"{k} choose: rock, scissors, paper : ").lower()
        if

PRE

This code:

MID

a_player = input(f"{k} choose: rock, scissors, paper : ").lower()


creates the need to catch errors down the line and is repeated so I recommend replacing it with:

 def input_choices(string):
    while True:
        choice = input(string)
        if choice.lower() in list:
            return choice
        else:
            print('Please type correctly')

a_player = input_choices(f"{k} choose: rock, scissors, paper : ")


POST

This avoids the need for:

SUBMITTED

JSONObject obj

PRE

MID

obj

POST

SUBMITTED

fp.readlines()]

        self.data: list = []

    @staticmethod

PRE

to be redundant. <code>open</code> will do that for you.

Since you're learning about type hinting: what is this a list <em>of</em>?

MID

self.data: list = []


POST

Similarly, this:

SUBMITTED

def calculate_standard_deviation

PRE

MID

calculate_standard_deviation

POST

SUBMITTED

n_cores = std::thread::hardware_concurrency();
        if (n_cores == 0)
        {
            std::cerr &lt;&lt; "Error: Could not find number of available cores.\n";
        }
    }
}




void Job_Queue::thread_loop()
{
    {
        std::unique_lock&lt;std::mutex&gt; mu(Job_Queue::job_mutex);
    }
    bool job_q_empty = false

PRE

Is this an actual issue?

MID

        if (n_cores == 0)
        {
            std::cerr &lt;&lt; &quot;Error: Could not find number of available cores.\n&quot;;
        }


POST

Will this ever return 0?<br />
Can it return 0? Will a machine not always have at least one core? If it had zero cores can you run the code?

This is pointless:

SUBMITTED

if (!_data)
        delete[] _data;
    _data = tmp

PRE

The <code>new</code> operator will never return null. If it can not allocate memory it will throw an exception. So no need to do this manual check.

But if it did work like you expected you should not throw until you have put the object back to its original state.

It is perfectly fine to call delete on a <code>nullptr</code>.

MID

    if (!_data)
        delete[] _data;


POST

This test is just a pesimization of the normal case.

Things go badly here:

SUBMITTED

gt;value_) };

        return {};             
    }

    std::optional&lt;bool&gt; JValue::GetBooleanValue() const
    {
        if (this-&gt;value_type_ == JValueType::Boolean)
            return { std::get&lt;bool&gt;(this-&gt;value_) };
        return {}; 
    }


    bool JValue::AddArrayChild(JValue&amp;&amp; value)
    {
        bool success = false;

        if (this-&gt;value_type_ == JValueType::Array)
        {
            success = true;
            //move() here is superfluous, but leaving it just in case `value` changes to a regular value in the future
            this-&gt;children_.emplace_back(std::move(value)); 
        }

        return success;
    }


    bool JValue::AddObjectChild(std::string name, JValue&amp;&amp; value)
    {
        bool success = false;

        if (this-&gt;value_type_ == JValueType::Object

PRE

As I mentioned, I’m not really sure of the point of <code>_name</code>. But in any case, this accessor makes an unnecessary copy. You could return a <code>std::string const&amp;</code>, and also make it <code>noexcept</code>.

MID

bool JValue::AddArrayChild(JValue&amp;&amp; value)
{
    bool success = false;

    if (this-&gt;value_type_ == JValueType::Array)
    {
        success = true;
        //move() here is superfluous, but leaving it just in case `value` changes to a regular value in the future
        this-&gt;children_.emplace_back(std::move(value)); 
    }

    return success;
}


POST

Couple things here.

First, the comment is wrong. <code>std::move()</code> is absolutely <em>not</em> superfluous there. If this weren’t a member function, it wouldn’t compile without the <code>std::move()</code>, because the copy constructor is private. (If you don’t believe me, you can try commenting out <code>Clone()</code> and deleting the copy ops to see for yourself.)

You see, <code>value</code> is an rvalue reference… but it is not an rvalue. An rvalue reference <em>takes</em> (ie, binds to) rvalues… but it is not an rvalue itself. The function can only be called with rvalue arguments… but <em>within the function</em>, the argument is an lvalue.

The easiest way to understand when something is an rvalue is to ask: “can this be used after this point?”. In that function, if you did <code>this-&gt;children_.emplace_back(value);</code>, could <code>value</code> be used again after that line? Why yes, yes it could. You could even repeat that line to add two copies of <code>value</code> to <code>children_</code>. Therefore, <code>value</code> is not an rvalue.

The second thing is: this function really shouldn’t be taking its argument as an rvalue reference. What’s the point? The general rule for (non-template) function parameters is:

SUBMITTED

include &lt;stdio.h&gt;

int valid(int[][9], int, int, int);
int

PRE

Overall it looks fine for a beginner-level program, you keep the functions small and separate different parts of the logic between them, which is good.

MID

int valid(int[][9], int, int, int);

POST

SUBMITTED

Name

PRE

I would highlight two things:

MID

Name

POST

From implementation point of you, you can improve readability if you do something like this:

SUBMITTED

name);
        }
        else{
            System.out.println(&quot;Please indicate savings or checking account&quot;);
            return null;
        }
    }

    public BankAccount getAccount(String account, String name

PRE

I'm sure you already know this, but naming matters.  The few keystrokes that you save using <code>w</code> are paid for every time somebody reads the code.  Consider always using more meaningful names <code>withdrawalAmount</code> etc.

Be cautious about reusing names of classes from the standard library.  Rather than <code>Consumer</code>, consider giving it a more specific name to reflect what it's consuming.  This will both be more descriptive and remove the name conflict with <code>Consumer&lt;T&gt;</code>.

The scenario you've constructed feels a bit forced, which makes it more difficult to assess if the code really makes sense.  Bank accounts don't really a producer/consumer relationship.  Spinning up a new thread, in order to perform a single transaction feels very inefficient.  On the face of it, your producer creates money and your consumer removes money.  I can't help but feel like really, they are both producing transactions that would be better served by a <code>TransactionConsumer</code>.

Consider using an enum rather than a raw <code>String</code> for the account.  Perhaps you need the flexibility of a string, however if you can use an enum it makes typo's less likely and removes the need for your 'else' conditions.

Generally speaking, when you can't handle a situation you want to throw an exception.  The error printed if an unsupported account is specified suggests that the caller does something else do you really want this method to return <code>null</code> in that scenario?  If you do want to support 'possibly' creating the account, consider returning an <code>Optional</code> instead to give the caller a hint that it could fail.  Currently your <code>main</code> doesn't check if null is returned, so you'll end up with <code>NullPointerException</code>s from your Producer/Consumers.

If the intention is to only have the accounts created by your factory, I would consider dropping the non-balance constructor from your accounts.  This would make it easier to overload the construction methods and chain them:

MID

public BankAccount getAccount(String account, String name) {
    return getAccount(account, name, 0);
}


POST

To answer question 4, no you shouldn't always include setters.  If you don't want the value to be changed from outside the class after construction, don't include setters.  In the future, people with less context may decide that since it's there, it must be ok to use it.  <code>setBalance</code> is a good example of a confusing setter.  Why would you want an external actor to be able to set the balance of this account?  But what makes it stand out is that whilst <code>getBalance</code>, <code>deposit</code> and <code>withdrawal</code> are synchronised, <code>setBalance</code> isn't.  So, somebody could do a deposit and have a receipt for a different balance entirely printed...

Money is one of those things where people start getting upset if rounding errors start impacting their balance.  Generally speaking you should be using <code>BigDecimal</code> for money, rather than relying on <code>double</code>.

I'm not a huge fan of overly commented code, however in your deposit method you sleep for 300.  Consider adding a comment as to why you're sleeping, or extracting the logic into a private method that indicates what the sleep is about, something like <code>simulateSlowProcessing</code> perhaps.

To me, <strong>withdraw has a bug</strong>.  If a withdrawal comes in that is more than the balance, the thread can't escape until after the balance goes above that value.  This might be ok, if you were waiting for a message to process, however it doesn't really seem to make sense for a withdrawal.  If you don't have money, you expect it to tell you that and move on.  Indeed, if you escape the while loop, you perform a check that suggests you want to be able to fail transactions if there isn't sufficient funds.  Because the scenario isn't entirely clear, it's difficult to know what you expect the behaviour to be.  Changing <code>Main.Consumer</code> to withdraw 500, for example can result in the program never exiting.

It also looks like there is an <strong>AccountNumber bug</strong>.  Again, this is probably caused by the scenario, however you're using a static to set the account number for created accounts.  However, you only do this through the 'name' constructor.  You don't do it through the 'name' and 'initial balance' constructor, which is the one you're actually using.

<strong>compoundInterest has a bug</strong> in my view.  You're not currently calling it, however it makes use of <code>setBalance</code> on the base class.  You get the balance, perform some calculation and then set the balance.  It's possible for <code>deposit</code>/<code>withdrawal</code> to be called between the <code>getBalance</code> and the <code>setBalance</code> which meaning that money can be lost or gained as a consequence.  If you want to do stuff like this, then it would be better to use the atomic adjustment methods in the base class.  So, for example you could use <code>deposit</code> to add a calculated amount of interest to the balance...

Whether or not to use runnable or thread class depends on what you're doing, at the moment I don't think it makes a lot of difference either way.  As I've said, I'm not sure that spinning up a thread for each transaction really makes sense to me.

<code>static</code> methods in your main class are fine, however, you want your main to be responsible for one thing, typically bootstrapping your application.  With that in mind, the scope for having many static methods should be quite small.  I think the same applies for <code>static</code> classes, they aren't 'bad', however they may be a sign that the Main class is doing too much.

For multi-threading, control performed at the right level.  Typically, you want to minimise the amount of time when objects are locked, so protecting balance in the base object seems to make sense.  However, as I've already indicated you need to be careful about what you do in derived classes to ensure you don't accidentally break that encapsulation.

Setters aren't always required, fields that you don't expect at all (open date, account number...) should also be marked as <code>final</code>. Some serialisation may require setters, but then you might want to reconsider your logic location.

An arraylist of accounts sounds OK in principal, however you've not done anything with it the code.  Whether or not it's tightly coupled really depends on what you do with it and how/if you expose it to other classes.  A <code>HashMap</code> of accountNumber to Account might make more sense... but consider how/if your Bank needs to know the type of account and how it will identify them.

SUBMITTED

seq = ''.join

PRE

MID

join

POST

SUBMITTED

m_ListContainer.Contains

PRE

MID

Contains

POST

SUBMITTED

if (std::count(window

PRE

Your code is a single function which is a bit long, and it's not very obvious what it is doing. There are two ways of dealing with this: either creating functions that implement logical steps of the algorithm individually, or add some comments to describe which steps your algorithm is doing. Don't add comments that just descibre exactly what the code does, but give a higher level description.

MID

std::count()

You use <code>std::count()</code> a lot, but you don't need to. You can count the number of zeroes and ones when building <code>window</code>, and when you are calling <code>window.erase()</code> you can decrement your counts.

std::string

POST

Instead of using <code>std::find()</code> and counting manually using <code>while</code>-loops, you can use <a href="https://en.cppreference.com/w/cpp/string/basic_string/find" rel="noreferrer"><code>std::string::find()</code></a>. You can also construct a string directly from a subregion of another string.

SUBMITTED

hash_mpz.cpp

PRE

MID

hash_mpz.cpp

POST

SUBMITTED

let i

PRE

MID

i

function setFlag(matrix, i, j) {

const setFlag = function(matrix, i, j) {

POST

This is my current proposal, I did not test it, but you should get the gist of it;

SUBMITTED

in $(cat

PRE

MID

cat

POST

SUBMITTED

obj)
    {
        return obj is Coordinates coordinates &amp;&amp; Equals(coordinates);
    }

    public bool Equals(Coordinates other)
    {
        return worldX == other.worldX &amp;&amp; worldY == other.worldY;
    }

    public override int GetHashCode

PRE

Doing so with <code>Sector</code>, <code>Cost</code>, <code>Integration</code> and <code>Flow</code> requires of cause that these objects are reference types and not replaced - if they are updated while the <code>Coordinates</code> instance lives. It is probably just a micro optimization - but everything counts?

MID

public bool Equals(Coordinates other)
{
  return worldX == other.worldX &amp;&amp; worldY == other.worldY;
}


POST

This is actually an implementation of <code>IEquatable&lt;Coordinates&gt;</code> so you can add this interface to the inheritance list:

SUBMITTED

join_table_query)
        results = cursor.fetchall()
        print(results)
        if len(results) &lt; 1:
            success = False
            raise ValueError('The name that was given to cardbot didn\'t exist in the card table

PRE

with calls to the actual <code>logging</code> module, which is more configurable and maintainable.

MID

'The name that was given to cardbot didn\'t exist in the card table.'


can be

&quot;The name that was given to cardbot didn't exist in the card table.&quot;


POST

Your <code>join_table_query</code> is long. There are several approaches to improve this - either save a view in the database (my favourite), or a stored procedure (common but I think it's overkill in this case).

the bot is protected from any direct sql injections before I deploy it

This is directly vulnerable:

SUBMITTED

uint8_t possibilities

PRE

You also wrote <code>const struct cell</code>, but the <code>const</code> doesn't do anything here.

Naming things is always hard. Try to give it some thought whenever you have to come up with a new name, and make sure that it is as meaningful and precise as possible. Some suggestions:

MID

possibilities

POST

SUBMITTED

public class CredentialsValidator {

  public boolean validateCredentialsRequest(ValidationCredentialsRequest credentialsRequest) {
    switch (credentialsRequest.getCredentialType()) {
      case TYPEA:
        return validatetypeACredentials(credentialsRequest);
      case TYPEB:
        return validateTypeBCredentials(credentialsRequest);
      case TYPEC:
        return validateTypeCCredentials(credentialsRequest);
    }
    return true;
  }

  private boolean validateTypeCCredentials(ValidationCredentialsRequest credentials) {
    if (credentials.getIsNewCredential()) {
      return nonNull(credentials.getUsername())
          &amp;&amp; !credentials.getUsername().isEmpty()
          &amp;&amp; nonNull(credentials.getPassword

PRE

Instead, this logic could be in <code>ValidationCredentialsRequest</code>, and <code>CredentialsValidator</code> only interacts with the validation methods instead of the getters:

MID

public boolean validateCredentialsRequest(ValidationCredentialsRequest credentialsRequest) {
   switch (credentialsRequest.getCredentialType()) {
       case TYPEA:
           return credentialsRequest.isTypeAValid();
       case TYPEB:
           return credentialsRequest.isTypeBValid();
       case TYPEC:
           return credentialsRequest.isTypeCValid();
   }
   return true;
}


class ValidationCredentialsRequest {
   /* ... */

   public boolean isTypeAValid() {/* ... */ }

   public boolean isTypeBValid() {/* ... */ }

   public boolean isTypeCValid() {
       if (newCredential) {
           return nonNull(username)
               &amp;&amp; !username().isEmpty()
               &amp;&amp; nonNull(password)
               &amp;&amp; !password.isEmpty();
       }
       return nonNull(credentialsId);
   }

}


<a href="https://en.wikipedia.org/wiki/Polymorphism_(computer_science)" rel="noreferrer">Polymorphism</a> is a concept where one thing can be something else at the same time: for example, a <code>Shape</code> can be a <code>Rectangle</code> at the same time.

With <code>Polymorphism</code> we can achieve that we no longer need the switch case. This would have the advantage that we don't have to change the <code>CredentialsValidator</code> class when adding new validation logic:

class CredentialsValidator {
    
    public boolean validateCredentialsRequest(ValidationCredentialsRequest credentialsRequest) {
        return credentialsRequest.isValid();
    }
    
}


POST

From here all different &quot;shapes&quot; of <code>ValidationCredentialsRequest</code> need to share the same interface - all need the <code>isValid</code> method:

SUBMITTED

lines)
       =&lt;&lt; return . read
       =&lt;&lt; getLine

PRE

MID

=&lt;&lt; return . read =&lt;&lt; getLine

=&lt;&lt; readLine

POST

SUBMITTED

include &lt;exception&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &lt;map&gt;

enum MsgTy {
    OK = 0,
    WARNING,
    ERROR,
    CRITICAL,
};

class FileWriter {
    std::string filename_;
    std::ostringstream msg_;
public:
    FileWriter(const std::string&amp; filename, std::ostringstream&amp; msg) 
      : filename_{ filename } {
        operator()(msg);
    }

    void operator()(std::ostringstream&amp; msg) {
        std::ofstream out(&quot;log.txt&quot;, std::ios::app);
        out &lt;&lt; msg.str();        
    }
};

static std::map&lt;MsgTy, std::string&gt; msg_id{
    {MsgTy::OK, {&quot;OK: &quot

PRE

In modern C++, you should use a strong <code>enum</code>—an <code>enum class</code>. That way your enumerators won’t pollute the namespace.

Speaking of polluting the namespace, the almost universal convention in C++ is that all-caps identifiers are used for preprocessor defines. By using them in this case, you run the risk of someone else’s macro definitions fuggering up your <code>enum</code>. And given that having a macro named something like <code>ERROR</code> is <em>highly</em> likely in large enough projects, you’re really cruising for a bruising here. (Actually, POSIX reserves everything starting with <code>E</code> followed by a digit or uppercase letter… so you’re <em>REALLY</em> asking for trouble with that in particular.)

I’m also not keen on the name <code>MsgTy</code>. Seems a little ugly and obtuse. I get that you want it to be short but… this seems a bit much.

MID

class FileWriter {
    std::string filename_;
    std::ostringstream msg_;
public:
    FileWriter(const std::string&amp; filename, std::ostringstream&amp; msg) 
      : filename_{ filename } {
        operator()(msg);
    }

    void operator()(std::ostringstream&amp; msg) {
        std::ofstream out(&quot;log.txt&quot;, std::ios::app);
        out &lt;&lt; msg.str();        
    }
};


Oi, this class is….

First off… what is the point of the data members? You don’t use either of them.

Second… what’s the point of the function call operator? You could just as well do all the work in the constructor. You never use the function call operator anywhere else.

Third… what’s the point of taking the argument as a string stream when you just go ahead and re-format it through a file stream? You’re double-formatting it.

This entire class could boil down to:

struct FileWriter
{
    FileWriter(std::string_view filename, std::string_view msg)
    {
        auto out = std::ofstream{filename, std::ios_base::app};
        out &lt;&lt; msg;
    }
};


POST

But even then, I’m not sure this is a great idea, because you’re reopening the file every time you’re writing a new log line, then closing it after. That doesn’t seem like a great idea, efficiency-wise.

A better idea would be to open the file once, and keep it open. Then just syncronize your writes (assuming you care about concurrency, which it sure doesn’t look like it), and flush after every log line. Normally <code>std::endl</code> is a terrible idea… but flushing after every line is <em>exactly</em> the singular use case it’s actually intended for.

SUBMITTED

buf

PRE

MID

buf

You will notice that functions like <code>sprintf()</code> and <code>strftime()</code> don't return a pointer, but rather an integer that says something about the number of bytes that (would) have been written to the output buffer. This is much more useful than just copying the pointer to <code>buf</code>, which doesn't give the caller any new information.

The callback function returns a pointer to a string. But where is this allocated? Your <code>format()</code> function doesn't call <code>free()</code>, so either the string should be stored in some statically allocated array, or it is allocated on the heap. In the former case, unless you return a pointer to a string literal, your <code>format()</code> function can only be used from one thread at a time. If you return memory that is allocated on the heap, then you have to keep track of it so the caller can clean up all the allocated memory once <code>format()</code> returns.

buf

POST

To solve the above issue, and to avoid an unncessary copy, you can pass a pointer into the buffer and the remaining size to the callback function, and have the callback function write directly to the buffer. For example:

SUBMITTED

private Board

PRE

MID

Board

POST

SUBMITTED

constexpr

PRE

Overall the code is quite well written, and it's an interesting program.

MID

constexpr

POST

SUBMITTED

Long                  'Row

PRE

MID

Row

Row

POST

SUBMITTED

quot;
    cp

PRE

MID

cp

POST

SUBMITTED

window = Window()
# do some more setup here before going to user
path = get_path_from_user()
window.build(path)

class Window:
    def __init__(self):
        self.image: Optional[Image] = None

    def build(self, path):
        self.image = Image(path

PRE

According to PEP 526, the initializer isn't needed.  Have you tried:

MID

class Window:
    def __init__(self):
        self.image: Optional[Image]    # &lt;== this is just a type hint, no initialization

    def build(self, path):
        self.image = Image(path)


POST

I don't use PyCharm, so I don't know if it would still complain.

SUBMITTED

of GameLogic

PRE

<strong>TL;DR summary:</strong> Use less comments, use meaningful comments, use <code>Deque</code>, DRY and generalise the repetitive code (with some smarts), out-of-border checking, make <code>Square</code> abstract &amp; paint in it's subclass, repaint only when something changes.

Firstly, I am totally new to this StackExchange, so sorry if I misunderstood my review task or I cross any borders - I honestly don't want to be mean to you, just to point out style errors or things that can be improved in your design or implementation.

I have not run your solution at all, it looks functional and I believe you it works. But I have read all the code.

MID

GameLogic

GameLogic

POST

SUBMITTED

modifier : 0);
            break

PRE

playAgain can be consolidated into the main game loop, instead of running a separate infinite loop. Just something for you to look into.

Suppose your <code>newFont</code> methods cannot find the font. It just silently exits. The developer has no idea what happened. Instead, provide the developer with a complete error message explaining what failed. Something like &quot;Unable to allocate font: &lt;font_path&gt;&quot;. This allows the developer to fix the issue. Better yet, have a backup font in case font allocation fails; this allows the game to run even if it can't find the font.

MID

break

POST

SUBMITTED

import requests


class GAME:


    def find_game_ids(self,accId,key):
        
        i=0
        GAMEID = []
        Idgame=20       
        url_match_list=('https://na1.api.riotgames.com/lol/match/v4/matchlists/by-account/'+(accId)+'?queue=420&amp;endIndex=20&amp;api_key='+(key))
        response2=requests.get(url_match_list)
        #Adding 20 games into the list
        while Idgame&gt;0:
            GAMEID.append('https://na1.api.riotgames.com/lol/match/v4/matches/'+str(response2.json()['matches'][i]['gameId'])+'?api_key='+(key))
            i=i+1
            Idgame=Idgame-1

        return GAMEID


    def game_data(self,game_list,key,sumName):

        wins=[]
        deaths=[]
        deaths= []
        kills=[]
        assists=[]
        visions=[]
        csTotal=[]
        
        
        #Finding the data of said summoner in each game id
        for urls in game_list:

            
            response=requests.get(urls)
            Loop=0
            index=0
            while Loop&lt;=10:
                
                if response.json()['participantIdentities'][index]['player

PRE

This can be further improved though. If you're iterating to create a list like you are here, list comprehensions can sometimes be cleaner:

MID

def find_game_ids(self, accId, key):
    url_match_list = f&quot;https://na1.api.riotgames.com/lol/match/v4/matchlists/by-account/{accId}?queue=420&amp;endIndex=20&amp;api_key={key}&quot;
    response2 = requests.get(url_match_list)
    
    return [f&quot;https://na1.api.riotgames.com/lol/match/v4/matches/{response2.json()['matches'][i]['gameId']}?api_key={key}&quot;
            for i in range(20)]


POST

The major readability problem in each case stems from how long that string is. You may want to break it over multiple lines, or generate it outside of the function using another function.

In <code>game_data</code>, you're calling <code>response.json()</code> <em>repeatedly</em>. Looking over the <a href="https://requests.readthedocs.io/en/master/_modules/requests/models/#Response.json" rel="nofollow noreferrer">source of that method</a>, it does <em>not</em> appear to do any caching. That means that every call to <code>.json</code> will reparse the data, which is a waste of CPU time. Save that into a variable once and use it as needed:

SUBMITTED

def binary_to_decimal_converter(binary_value):
    print(f&quot;Binary: {binary_value}&quot;)
    decimal_value = 0
    # Treating binary input as a string
    # power is power of number 2
    # power must be less than string length because computer starts counting from 0th index
    power = len(str(binary_value)) - 1
    loop_var = 0
    while loop_var &lt; len(str(binary_value)):
        if str(binary_value)[loop_var] == str(1):
            decimal_value += 2 ** power
        power -= 1
        loop_var += 1
    return print(f&quot;Decimal: {decimal_value}&quot;)


# Calling the function
binary_to_decimal_converter

PRE

And if the function ends without a return statement, it automatically returns <code>None</code> anyway.  So the <code>return</code> can simply be omitted.

Note: It is better to return results from a function that does a calculation, without printing anything inside the function, and have the caller do the printing.  This will create more flexible code in the future.  Left to student.

MID

def binary_to_decimal_converter(binary_value):
    print(f&quot;Binary: {binary_value}&quot;)
    decimal_value = 0

    # power is power of number 2
    # power must be less than string length because computer starts counting from 0th index
    power = len(binary_value) - 1

    for digit in binary_value:
        if digit == &quot;1&quot;:
            decimal_value += 2 ** power
        power -= 1

    print(f&quot;Decimal: {decimal_value}&quot;)


# Calling the function
binary_to_decimal_converter(&quot;1111101100&quot;)


POST

SUBMITTED

post'])) {

    $uploadOk = 1;
    $imageName = $_FILES['postToUpload']['name

PRE

Your code is insecure because:

MID

$_FILES['postToUpload']['name']

POST

SUBMITTED

public class Import
{
  static String db_host = null;
  static

PRE

First, you should follow the <a href="https://www.oracle.com/java/technologies/javase/codeconventions-namingconventions.html" rel="nofollow noreferrer">Java naming conventions</a>.

Second, don't shorten names just because you can. Example, what does &quot;Proc&quot; stand for? Procedure? Processor? Even if names become longer, the readability is worth it!

MID

static String db_host = null;


POST

Your members should not be <code>static</code>, and should ideally be qualified with something else than <code>package-private</code>, like <code>protected</code> or <code>private</code> to show the intent clearly.

In order to read the required arguments I need some kind of state machine.

Is that a requirement you've been given or is that an assumption you had? Because that's not true at all. Overall, your system is completely unnecessarily complex without an obvious reason or benefit. Neither does it seem like a state-machine at all, it's just an overly complex chain of function calls.

A state-machine for your command-argument parsing would be something like this:

SUBMITTED

gt;
#include &lt;errno.h&gt;
#include &lt;bits/stdc++.h&gt

PRE

There are several improvements you can do for this code using just c++ standard library classes and functions.

MID

#include &lt;bits/stdc++.h&gt;

POST

It's not guaranteed that this header file exists, and is a compiler specific internal. Using such will make your code less portable.<br />
Only <code>#include</code> headers provided for the classes and functions you want to use from the c++ standard library.<br />
You can read more about the possible consequences and problems here: <a href="https://stackoverflow.com/questions/31816095/why-should-i-not-include-bits-stdc-h">Why should I not #include &lt;bits/stdc++.h&gt;?</a>

As well don't <code>#include</code> header files where you don't use anything from them (e.g. <code>#include &lt;filesystem&gt;</code>).

E.g. your code to build the <code>prompt</code> variable can be drastically simplified by just using <code>std::string</code> instead of <code>char*</code>:

SUBMITTED

const navLinks

PRE

I think this primarily comes down to the purpose of <code>Root</code>. If it is a general purpose wrapper container component, then the latter pattern makes sense. I.E. it is providing the layout but no actual UI, this works well. If on the other hand it isn't very generalizable, i.e. it is more single purpose, then passing it props is preferred. I understand this doesn't sound like an answer, but like many things in javascript, there's no clear, hard line between them and this could also simply come down to personal preference/opinion.

Do I need an App.js file or index.js file and could have one rather than the other?

Again, these both exist by convention, but you could easily merge the two if you so desired. The distinction basically comes down to separation of concerns. <code>index.js</code> is primarily concerned with rendering the application into the DOM whereas <code>App.js</code> is primarily concerned with being the root application container. This is typically where redux stores &amp; providers, react contexts &amp; providers (<em>well, all &quot;providers&quot; in general</em>), root routers/navigation, theming, etc, etc... would/could reside and provide functionality to the app.

App.js

MID

navLinks

POST

SUBMITTED

import heapq, math, sys

infinity = float('inf')

class AStar():

    def __init__(self, start, grid, height, width):
        self.start, self.grid, self.height, self.width

PRE

MID

self.start, self.grid, self.height, self.width = start, grid, height, width


I would not put these all on the same line like that. I think it would be much easier to read spread over multiple lines:

self.start = start
self.grid = grid
self.height = height
self.width = width


POST

I would probably have the <code>Node</code> class as toplevel instead of nested. I don't think you're gaining much by having it inside <code>AStar</code>. You could name it <code>_Node</code> to make it &quot;module-private&quot; so that attempting to import it to another file will potentially raise warnings.

In <code>Node</code>'s <code>__lt__</code> implementation, I wouldn't call the second parameter <code>comparator</code>. A comparator is something that compares, whereas in this case, that's just another node. <code>other_node</code> or something would be more appropriate.

In <code>heuristic</code>, I'd personally make use of an <code>else</code> there:

SUBMITTED

methods=['POST'])
def insert_data():
    if not db:
        raise Exception('db object not defined')

    if us.header_key and request.headers.get('X-Purpleair') == us.header_key:
        db.insert_sensor_row(request.json)
    elif not us.header_key:
        db.insert_sensor_row(request.json)

    if us.loadHistoricalData:
        # Add all historical data to DB.
        db

PRE

Just to be clear, if <code>db</code> truly hasn't been assigned at this point, you cannot use <code>if not db</code> to check for that. Attempting to use a name before it's been associated with an object with raise a <code>NameError</code>, which you'd need to catch. At that point though, I'd probably just allow the original <code>NameError</code> to propagate and not worry about catching it unless there was other specific information that I wanted to add to the error.

If you meant that &quot;db is in a bad, falsey state&quot;, I'd probably change the error message to be clearer what the problem is, and change <code>raise Exception(. . .</code> to <code>raise ValueError(. . .</code>. Throwing generic <code>Exception</code>s isn't a great idea, since it makes it harder for the caller of the function to handle only specific errors.

MID

if us.header_key and request.headers.get('X-Purpleair') == us.header_key:
    db.insert_sensor_row(request.json)
elif not us.header_key:
    db.insert_sensor_row(request.json)


It seems like this could be reduced down to:

if not us.header_key or request.headers.get('X-Purpleair') == us.header_key:
    db.insert_sensor_row(request.json)


POST

If <code>not us.header_key</code> is false, the right operand of <code>or</code> will run, and you know at that point that <code>us.header_key</code> must be truthy.

SUBMITTED

cmd check_output_and_retry(cmd, expected_output, delay=1, retry=3):
    for i in range

PRE

Pycharm and potentially other Python stylers might get upset at you for having a named variable you don't use: <code>i</code>. Consider replacing with <code>_</code>:

MID

for _ in range(retry):  # ...


POST

I'm just going to assume the <code>cmd check_output...</code> is just a typo, since Python uses <code>def</code>.

Write a docstring!

Again, you might not think all of the above are improvements, just alternatives. If you did follow them all, you might end up with the following:

SUBMITTED

if [ &quot;$( wc -c &lt; &quot;${file_path}&quot; )&quot; -gt &quot;${max_size}&quot; ]
    then
        file_name=&quot

PRE

Instead of:

MID

&quot;$( wc -c &lt; &quot;$file_path&quot; )&quot;


use stat:

stat -c %s &quot;$file_path&quot;


POST

=&gt; better query the file system than count the number of bytes in files, some of which can be pretty large

Instead of enclosing the whole block between brackets, I would set up <strong>file redirection</strong> from the beginning eg:

SUBMITTED

operation,
    variables

PRE

MID

variables

POST

Even with all this, there is no authoritative data sources. If you build an online store, someone can join and start responding with <code>{price: 0.00}</code>.

Load balancing times them out, authentication tags them, validation makes them do some work, so there's momentum working here. It's not just opening a URL. Still it's possible to open a browser window and send bad data.

My plan is to use brain.js. Train a test set of good and bad source detection. Bundle with the app. Property, value, and source should be enough for consensus and alerting the peer network of bad sources. Other ideas are transparency with good UI and let the user detect bots, and also references. Send a supplier list along with the price, and let the app independently validate. All these are domain specific so I left it out of graphql networking implementation.

Work in progress, will report back soon.

<strong>Update: 10/21/20</strong>
RelayEnvironmentProvider component suspends. Since this at the top level of the app, the entire app suspends as oppose to individual components. The relay issue-tracker demo has a custom react experimental version. I'm creating a <a href="https://github.com/urgent/peer-graphql" rel="nofollow noreferrer">npm</a> to see if I can drop this functionality into Relay networking.

react, react-relay, relay-runtime, and graphql are all 100kb+ each. brain.js is at ~580kb. Working in the browser, and built for the browser are two different things.

To keep bundle size small, I webpack these as external modules loaded from the vendor's CDN, excluded from webpack build.

<code>graphql-tools</code> has limited browser support. file includes do not work. Instead I went with compile time codegen while building io-ts runtime decoding from graphql schema.

jest has limited support too, especially with create-react-app. I wanted to import all files in a folder automatically. browser supports this but jest doesn't. If I want that extensibility, compile time codegen would be the best.

Also jest does not support TextEncoder, which relay uses, and was used but no longer in my nacl implementation. I used StandardLib instead.

I looked into modeling a state machine for this. xState and graphql is redundant. graphql is really nice, the best state management there is. It's best to avoid complex state as most as possible. Straight through pure functions with just input and output, best you can do.

SUBMITTED

reader.ReadLineAsync

PRE

MID

ReadLineAsync

POST

SUBMITTED

import java.util.ArrayList;

public class Pizza {

    private String size;
    private ArrayList&lt;String&gt; toppings;

    public String getSize() {
        return size;
    }

    public void setSize(String size) {
        this.size = size;
    }

    public ArrayList&lt;String&gt; getToppings() {
        return toppings;
    }

    public void setToppings(ArrayList&lt;String&gt; toppings) {
        this.toppings = toppings;
    }

    public String toString() {
        return this.size + &quot; pizza with &quot; + this.getToppings

PRE

What would be a more clean solution would be to keep the <code>List</code> of toppings internal, and only expose a method to add (and if needed to remove) toppings. That would greatly simplify your class.

MID

public class Pizza {
    private List&lt;String&gt; toppings = new ArrayList&lt;&gt;();

    public String getCount() {
        return toppings.size();
    }
    
    public Pizza addTopping(String topping) {
        toppings.add(topping);
        
        return this;
    }
    
    public String toString() {
        return toppings.length() + &quot; pizza with &quot; + toppings;
    }
}


POST

Note that <code>toppings.toString()</code>, as it will be called for <code>String</code> concatenation, will not output the toppings at all.

SUBMITTED

bool check(const char *word)
{   
    int nodeIdx = hash(word);   
    if (nodeIdx &lt; 0)return false;    

    nodeWords * searchNode; 
    searchNode = nodeArray[nodeIdx];    
    bool returnFlag = false;    

    do
    {
        if (strcmp(word,searchNode-&gt;word) == 0 )returnFlag = true;
        else if (strcmp(word,searchNode-&gt;word) &lt; 0 &amp;&amp; searchNode-&gt;left  != NULL) searchNode = searchNode-&gt;left;
        else if (strcmp(word,searchNode-&gt;word) &gt; 0 &amp;&amp; searchNode-&gt;right != NULL) searchNode = searchNode-&gt;right;
    }while (searchNode-&gt;left != NULL || searchNode-&gt;right != NULL || strcmp(word,searchNode-&gt;word) == 0);    
    
    return returnFlag

PRE

MID

bool check(const char *word)
{
    int nodeIdx = hash(word);
    if (nodeIdx &lt; 0)
    {
        return false;
    }

    nodeWords * searchNode;
    searchNode = nodeArray[nodeIdx];

    while (searchNode != NULL)
    {
        if (strcmp(word, searchNode-&gt;word) == 0 )
        {
            return true;
        }
        else if (strcmp(word, searchNode-&gt;word) &lt; 0 )
        {
            searchNode = searchNode-&gt;left;
        }else{
            searchNode = searchNode-&gt;right;
        }
    }
    return false;
}


POST

SUBMITTED

ArrayList GetProctorsDetails

PRE

As pointed out by @iSR5's comment, A <code>DataSet</code> is basically a wrapper around a <em>collection</em> or <code>DataTable</code> objects. It has some other helpful utility methods, but from a performance point of view the only performance issue with your logic is that in the <code>DataSet</code> solution you need to access the table to read from through the indexer that has <em>assumed</em> that there is a table at index <code>0</code>.

MID

GetProctorsDetails

POST

SUBMITTED

SubscriptionId = 1, ParentProductId

PRE

MID

ParentProductId

ParentProductId

POST

SUBMITTED

int number) {
long long complete_integer = 0;
int

PRE

MID

long long int

int

POST

SUBMITTED

while ( 1 ) {
        switch

PRE

MID

switch

POST

While it isn't necessary in the current code, to prevent undefined behavior it is best to have a default case for every switch statement:

SUBMITTED

gt;assign

PRE

MID

assign()

POST

When reading your code, I was wondering why <code>add()</code> and <code>remove()</code> looked so different. Adding a new entity is apparently a two-step process: first you call <code>add()</code> to reserve an ID, and then you <code>assign()</code> values to the components of that ID. Why not make this a one-step process?

You seem to be using the high bits as a kind of generation counter. Is this doing anything useful? If <code>Capacity</code> is set to 65536, then there are no high bits left, so you can't be relying on this. I would avoid this altogether, this way you can remove <code>m_index_mask</code>, <code>m_new_id</code> and all the <code>&amp; m_index_mask</code> operations.

The standard library containers all have a similar interface; you only have to learn it once and you can apply this knowledge on all the containers it provides. It helps if you follow the same conventions, so you don't have to learn and use different terms for your classes. Mostly, it's just renaming a few member functions:

SUBMITTED

quot;Bad login&quot

PRE

<strong>Async login bug</strong> The <code>try</code>/<code>catch</code> around <code>User.findOne</code> does not accomplish anything because <code>findOne</code> is asynchronous. When <code>findOne</code> fails, it'll pass an error to the callback, but when the callback does <code>throw err</code>, nothing is there to catch the asynchronous error, so no response will be sent to the user. Another issue is that you aren't checking if <code>user</code> exists - <a href="https://stackoverflow.com/questions/10551313/mongodb-node-findone-how-to-handle-no-results">if it doesn't</a>, an error will be thrown when you try to access its <code>password</code> property. (You also aren't checking for whether <code>.sign</code> results in an error or not)

You could also consider using Promises instead of callbacks - <code>findOne</code> already returns a Promise, and Promises are often preferable because they're more easily chainable and their error handling can be cleaner.

<strong>Security</strong> looks reasonable, though:

MID

Bad login

POST

Is how I'm checking usernames and password efficient?

Looks completely normal to me.

<strong>LOGGING:</strong> I log all connections to the server, and all login attempts. Is this a good practice

If one is logging, login attempts are one of the most important things to log. But <code>console.log</code> is not the right way to do it, at least not alone - say that some user was concerned about their logins, how would you examine their recent login attempts? Control-F-ing through the application stdout isn't a very manageable way of doing it. I'm not sure what the industry standard for this is, but you could consider saving to a logging database.

<strong>Email login</strong> You do:

SUBMITTED

void execute

PRE

MID

execute

POST

SUBMITTED

quot;polynomial

PRE

MID

polynomial

POST

SUBMITTED

normalize

PRE

MID

normalize()

POST

SUBMITTED

std::bad_alloc &amp;e){
            len = len &gt;&gt

PRE

Why not just multiply by 2.

MID

            len = len &gt;&gt; 1;


POST

Or is that divide by 2. Either way the intent is not clear. Use code that expresses your intent clearly.

Only prints if there is no exception.

SUBMITTED

domain.Post

PRE

MID

Post

POST

SUBMITTED

at &quot;+username+&quot; account &quot;)
print(repo1)

target_url = &quot;https://github.com/&quot;+username+&quot;/&quot;+output_repo_name+&quot;.git&quot;
print(target_url)

print

PRE

is likely incorrect. What you've written is 77 in <em>decimal</em>, but this would work out to <code>115</code> in octal. If you wanted <code>077</code> in octal, you would actually need to write <code>0o077</code>.

Consider replacing <code>os.path</code> with use of <code>pathlib</code>.

The <code>argv</code> parsing that you've done is fragile - it will fail with an invalid-index exception if the user provides insufficient parameters. Consider using <code>argparse</code> instead.

Also: do <em>not</em> ask for a password as part of a command line, since it will be stored in the user's shell history. Accept it from an environmental variable, a secure wallet, or from stdin via <code>getpass</code> (not <code>input</code>).

MID

&quot;https://github.com/&quot;+username+&quot;/&quot;+output_repo_name+&quot;.git&quot;


is more easily written as

f'https://github.com/{username}/{output_repo_name}.git'


POST

SUBMITTED

do {
    let decoder = JSONDecoder()
    let either = try decoder.decode(Either&lt;T, PayloadError&gt;.self, from: data)
    switch either {
        case .left(let value):
            completion(.success(value))
        case .right(let payloadError):
            completion(.failure(.generic)))
    }
} catch {
    if let value = String(data: data, encoding: .utf8) as? T {
        completion(.success(value))
    } else {
        completion(.failure(.generic

PRE

I've finally end up splitting the two use cases. This in order to make the code readable and more maintainable.

<code>PayloadError</code> is mapped to a <code>ServiceError: Error</code> in order to align the output.

<em>Use case 1</em>

MID

guard let data = response.data else {
    completion(.failure(.invalidData))
    return
}

let jsonDecoder = JSONDecoder()
if let payloadError = try? jsonDecoder.decode(PayloadError.self, from: data) {
    completion(.failure(ServiceError.from(payloadError)))
} else if let token = String(data: data, encoding: .utf8) {
    completion(.success(token))
} else {
    completion(.failure(.decodingError))
}


<em>Use case 2</em>

guard let data = response.data else {
    completion(.failure(.invalidData))
    return
}
let decoder = JSONDecoder()
guard let either = try? decoder.decode(Either&lt;T, PayloadError&gt;.self, from: data) else {
    completion(.failure(.decodingError))
    return
}
switch either {
case .left(let value):
    completion(.success(value))
case .right(let payloadError):
    completion(.failure(ServiceError.from(payloadError)))
}


POST

SUBMITTED

operator&lt;&lt;( std

PRE

MID

&lt;&lt;

POST

I strongly believe that this is a bad idea. I can explain in a very simple manner

SUBMITTED

const name

PRE

You can make this better by:

MID

name

POST

SUBMITTED

const { return

PRE

MID

return;

POST

SUBMITTED

quot;
    
    def __init__(self, player_id): 
        &quot;&quot;&quot;init player id&quot;&quot;&quot;
        self.player_id = str(player_id)
    
    def tick_case(self):
        &quot;&quot;&quot;ask the player a case to tick&quot;&quot;&quot;
        row, col = 10, 10
        while not(self.__is_case_valid(row, col)):
            print('Player ' + self.player_id + ' , this is your turn')
            row = input('which row do you want to enter?' ) 
            col = input('which row do you want to enter?' ) 
        return(int(row), int(col))
    
    def __is_case_valid(self, row, col

PRE

MID

        row, col = 10, 10
        while not(self.__is_case_valid(row, col)):
            print('Player ' + self.player_id + ' , this is your turn')
            row = input('which row do you want to enter?' ) 
            col = input('which row do you want to enter?' ) 
        return(int(row), int(col))


There is a problem here. Imagine this scenario

which row do you want to enter? Code review<br>
which row do you want to enter? 2

I have three problems here

which column do you want to enter?

POST

you need to <a href="https://www.w3schools.com/python/python_try_except.asp" rel="nofollow noreferrer">try and except</a> and catch the <code>ValueError</code> and ask the user to enter valid input again. I would make a simple function

SUBMITTED

string QuantityInvolved

PRE

MID

QuantityInvolved

POST

ComplaintForm

SUBMITTED

include &lt;stdarg.h&gt;
#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#include &quot;log.h&quot;

bool time_prefix = false;

void log_use_time_prefix(bool toggle)
{
    time_prefix = toggle;
}

void log_info(char *format_string, ...)
{
    va_list args1;
    va_start(args1, format_string);
    va_list args2;
    va_copy(args2, args1);
    char buf[1 + vsnprintf(NULL, 0, format_string, args1)];
    va_end(args1);
    vsnprintf(buf, sizeof buf, format_string, args2);
    va_end(args2);

    if (time_prefix)
    {
        time_t t = time(NULL);
        struct tm tm = *localtime(&amp;t);
        printf(&quot;%d:%d:%d \033[0m\033[1;34m[INFO]\033[0m %s&quot;, tm.tm_hour, tm.tm_min, tm.tm_sec, buf);
    }
    else
    {
        printf(&quot;\033[0m\033[1;34m[INFO]\033[0m %s&quot;, buf);
    }
}

void log_error(char *format_string, ...)
{
    va_list args1;
    va_start(args1, format_string);
    va_list args2;
    va_copy(args2, args1);
    char buf[1 + vsnprintf(NULL, 0, format_string, args1)];
    va_end(args1);
    vsnprintf(buf, sizeof buf, format_string, args2);
    va_end(args2);
    if (time_prefix)
    {
        time_t t = time(NULL);
        struct tm tm = *localtime(&amp;t);
        printf(&quot;%d:%d:%d \033[0m\033[1;31m[FAIL]\033[0m %s&quot;, tm.tm_hour, tm.tm_min, tm.tm_sec, buf);
    }
    else
    {
        printf(&quot;\033[0m\033[1;31m[FAIL]\033[0m %s&quot;, buf);
    }
}

void log_success(char *format_string, ...)
{
    va_list args1;
    va_start(args1, format_string);
    va_list args2;
    va_copy(args2, args1);
    char buf[1 + vsnprintf(NULL, 0, format_string, args1)];
    va_end(args1);
    vsnprintf(buf, sizeof buf, format_string, args2);
    va_end(args2);
    if (time_prefix)
    {
        time_t t = time(NULL);
        struct tm tm = *localtime(&amp;t);
        printf(&quot;%d:%d:%d \033[0m\033[1;32m[PASS]\033[0m %s&quot;, tm.tm_hour, tm.tm_min, tm.tm_sec, buf);
    }
    else
    {
        printf(&quot;\033[0m\033[1;32m[PASS]\033[0m %s&quot;, buf);
    }
}

void log_warning(char *format_string, ...)
{
    va_list args1;
    va_start(args1, format_string);
    va_list args2;
    va_copy(args2, args1);
    char buf[1 + vsnprintf(NULL, 0, format_string, args1)];
    va_end(args1);
    vsnprintf(buf, sizeof buf, format_string, args2);
    va_end(args2);
    if (time_prefix)
    {
        time_t t = time(NULL);
        struct tm tm = *localtime(&amp;t);
        printf(&quot;%d:%d:%d \033[0m\033[1;33m[WARN]\033[0m %s&quot;, tm.tm_hour, tm.tm_min, tm.tm_sec, buf);
    }
    else
    {
        printf(&quot;\033[0m\033[1;33m[WARN]\033[0m %s&quot;, buf

PRE

<strong><code>log.h</code> first, guards</strong>

For <code>log.c</code>, consider first including <code>log.h</code> before <code>&lt;&gt;</code> includes to test that <code>log.h</code> compiles on its own without additional includes.

I expected the idiomatic <a href="https://en.wikipedia.org/wiki/Include_guard" rel="nofollow noreferrer">include guard</a> in <code>log.h</code>.

<strong>Sample</strong>

Sample code to fold in the 4 functions.  See <a href="https://stackoverflow.com/q/3369588/2410359">Pass va_list or pointer to va_list?</a>.

MID

#include &lt;stdbool.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

bool time_prefix = false;

void log_general(bool time_prefix, const char *color, const char *name,
    const char *format_string, va_list *arg) {
  va_list argCopy;
  va_copy(argCopy, *arg);
  int len = vsnprintf(NULL, 0, format_string, argCopy);
  va_end(argCopy);
  if (len &lt; 0) {
    return;
  }
  char buf[len + 1];
  len = vsnprintf(buf, sizeof buf, format_string, *arg);
  if (len &lt; 0) {
    return;
  }
  if (time_prefix) {
    time_t t = time(NULL);
    if (t == -1) {
      return;
    }
    struct tm *tm = localtime(&amp;t);
    if (tm == NULL) {
      return;
    }
    printf(&quot;%02d:%02d:%02d &quot;, tm-&gt;tm_hour, tm-&gt;tm_min, tm-&gt;tm_sec);
  }
  printf(&quot;\033[0m\033[%sm[%s]\033[0m %s\n&quot;, color, name, buf);
}


void log_warning(const char *format_string, ...) {
  va_list args1;
  va_start(args1, format_string);
  log_general(time_prefix, &quot;1;33&quot;, &quot;WARN&quot;, format_string, &amp;args1);
  va_end(args1);
  fflush(stdout);
}

void log_info(const char *format_string, ...) {
  va_list args1;
  va_start(args1, format_string);
  log_general(time_prefix, &quot;1;34&quot;, &quot;INFO&quot;, format_string, &amp;args1);
  va_end(args1);
  // fflush(stdout); // No need for flush info messages.
}

int main() {
  time_prefix = true;
  log_warning(&quot;%d&quot;, 123);
  log_info(&quot;%f&quot;, 123.0);
}


POST

SUBMITTED

Q', 0.1962),
    
    ].iter().cloned().collect();

    for byte in text.clone(){
        let char_rep: char =  byte as char;
        if !char_rep.is_ascii

PRE

Use <code>text.iter()</code> instead of <code>text.clone()</code>; it avoids allocating a copy. In general, where both are available, <code>.into_iter()</code> consumes the structure and iterates over its elements by value (moves them), and <code>.iter()</code> does not consume the structure but iterates over references to its elements instead.

MID

let char_rep: char =  byte as char;
if !char_rep.is_ascii(){


POST

You can just use <code>if !byte.is_ascii() {</code> here.

SUBMITTED

sfinae {

    template

PRE

I think everyone would consider a <code>float</code> to be a &quot;mathematical&quot; type. However, since you check for the binary operators, this template will fail for <code>float</code>, <code>double</code>, <code>std::complex</code> and possibly other types as well. In fact, it also fails for <code>modular</code>! You might want to reduce the amount of operations you check for.

Note that the word &quot;mathematical&quot; also doesn't imply a certain set of operations. In Mathematics, you can make types you can do math with, but which for example only support addition and subtraction operations. The closest that comes to what you mean is the word <a href="https://en.wikipedia.org/wiki/Arithmetic#Arithmetic_operations" rel="nofollow noreferrer">&quot;arithmetic&quot;</a>. So I suggest that you rename it <code>is_arithmetic</code>, and do not check for the logical and bitwise operations.

There is a similar issue with <code>is_comparable</code>. You check for the presence of all comparison operators, but there are types where only some operators are valid. Consider for example <code>std::complex&lt;float&gt;</code>: it's an arithmetic type, you can certainly check whether two complex numbers are the same or not, however you cannot check if one number compares greater than another number; that operation does not make sense for complex numbers. So here it might make sense to split it up into an <code>is_equality_comparable</code> and perhaps something like <code>is_less_greater_than_comparable</code>. Note that most algorithms only require a single comparison operator to be available, either <code>==</code> or <code>&lt;</code>, and you don't want to unnecessarily restrict the types you accept.

MID

template

POST

Why is the constructor for <code>class modular</code> a <code>template</code>? That way it will accept all types, even ones that don't make sense. Just make a non-templated constructor that accepts a <code>Common_Integer</code> parameter:

SUBMITTED

uid

PRE

Explanation:

MID

uid

POST

SUBMITTED

top=&quot;$(git rev-parse --show-cdup)&quot;
    top=&quot;${top:-./}&quot;
    super_root=&quot;$(git rev-parse --show-superproject-working-tree)&quot

PRE

MID

local super_root=&quot;$(git rev-parse --show-superproject-working-tree)&quot;

POST

SUBMITTED

sleepFor(300);
    this

PRE

MID

*this

POST

The use of <code>*this</code> is both unnecessary and reductant. when you call a member function with an object of the class, it implicitly calls it with the object as its first argument, this can simply be explained as thus
<code>BankData(*this, args)</code>

so the extra-qualification just makes the code unreadable and adds no gain.

SUBMITTED

err = 1;  
    while

PRE

You can do similar with <code>transitions</code>. Overall, designated array initializers like above, that make use of the enum is strongly recommended for readability and data integrity.

General comments:

MID

while(1)

POST

SUBMITTED

PRELOAD

PRE

MID

PRELOAD

POST

SUBMITTED

const reference operator

PRE

MID

reference const

T&amp; const

POST

SUBMITTED

else:
            return True

    def is_winner(self, player):

        player = -1 if player == 'X' else 1

        # three in a row
        for i

PRE

You could also negate the condition instead of comparing against <code>0</code>, but I'd keep it like this for explicitness.

MID

def is_winner(self, player):
    player = -1 if player == 'X' else 1


POST

There's a couple things to note here:

You're using <code>-1</code> and <code>1</code> as placeholder values to indicate the players. These are examples of <a href="https://stackoverflow.com/questions/47882/what-is-a-magic-number-and-why-is-it-bad">Magic Numbers</a>, and should ideally be replaced by a more descriptive name. I'm not sure what the limitation on <code>numpy</code> arrays are, but an <code>Enum</code> of something like:

SUBMITTED

false;
  refreshed = false;
  pending = false;
  transceiver = _transceiver;
}

bool Register::read(void)
{
  if (!transceiver-&gt;isBusy()){
    new (&amp;read_reg_request)
        ReadRegRequestMsg(device, address, transceiver);
    read_reg_request.write();
    sent_msg = Message::MessageType::kReadRegRequest;
    pending = true

PRE

I was a bit surprised to see the following code:

MID

bool Register::read(void)
{
    if (!transceiver-&gt;isBusy()) {
        new (&amp;read_reg_request) ReadRegRequestMsg(device, address, transceiver);
        ...


Placement <code>new</code> is something you do in rather rare circumstances where you either want to avoid default construction or where copy assignment is not possible. There is no problem copy-assigning a <code>ReadRegRequestMsg</code>, and since <code>read_reg_request</code> was already default constructed, there is no performance gain here. I would replace this line of code with:

read_reg_request = ReadRegRequestMsg(device, address, transceiver);


But upon further inspection, why store the request in a member variable in the first place? It is not used outside <code>Register::read()</code>, so it could just have been a local variable. But the only thing you do is call <code>write()</code> on it, so you don't even need to store the result in a local variable, and can just write:

bool Register::read(void)
{
    if (!transceiver-&gt;isBusy()) {
        ReadRegRequestMsg(device, address, transceiver).write();
        ...


POST

But then that brings me to:

Why is <code>ReadRegRequestMsg</code> a class, why does it inherit from <code>class Message</code> which itself doesn't do anything useful, when the only thing you need is the function that writes a message to a device? It could be a stand-alone function:

SUBMITTED

type Parser a = String -&gt; (Maybe a, String)
-- (Nothing, ErrorMessage)
-- (Just a, Leftovers

PRE

Technically, the <code>(Nothing, e)</code> case can never be triggered, but you need to keep it in to avoid a <code>-Wall</code> warning.

There are two &quot;big ticket&quot; problems with your code, however.  The first is that your choice of <code>Parser</code> data type is poor:

MID

type Parser a = String -&gt; (Maybe a, String)


In the return type here, you use the first <code>Maybe a</code> component as a flag:  if it's <code>Nothing</code>, the second <code>String</code> component is an error.  If it's <code>Just a</code>, the second <code>String</code> component is the rest of the stream.  However, parse errors and rest-of-streams are not semantically comparable things, and it's pure coincidence that they happen to have the same <code>String</code> type, so they shouldn't be represented by the same field in your algebraic type.  From a practical standpoint, if you decided to refactor your code to parse streams of tokens other than <code>String</code>s or use a different <code>Error</code> type that includes location information, you'll have to do a lot of unnecessary modification.  You also introduce the potential for dumb programming bugs, where you start parsing error message or printing stream remainders on the console, because they're both <code>String</code> and the bad code will type check.  But these practical concerns are probably not that convincing, and in this simple example probably aren't too serious.  It's really just the theoretical, best-practices issue that this is a bad design when a much more straightforward and idiomatic type is available:

type Parser a = String -&gt; Either String (a, String)


Most Haskell programmers would be confused by your <code>Parser</code> type.  But, every Haskell programmer will understand this new <code>Parser</code> type immediately.  The <code>Either error result</code> convention and the <code>String -&gt; (a, String)</code> pattern, and the combination of the two of them, are hardwired into their brains.  You could make it even more obvious by writing:

type Parser a = String -&gt; Either Error (a, String)
type Error = String


POST

Anyway, the resulting rewritten parsers look about the same, for example:

SUBMITTED

int[] arrayy)
    {

        for (int index = 0; index &lt; getnums; index++)
        {
            arrayy[index] = index;
        }
        return arrayy

PRE

MID

for (int index = 0; index &lt; getnums; index++)


POST

SUBMITTED

class resource_handle

PRE

MID

resource_handle

POST

<code>class resource_haldle</code> is a well written wrapper around a pointer, but it doesn't do anything else besides holding a pointer and giving access to the pointer. So it can just be replaced by a bare pointer instead. What would be better is to determine what kind of ownership semantics the pointer should have that is returned by <code>resource_cache::load()</code>. If, as you mentioned in the comments in <code>main()</code>, you are worried that a handle can turn into a dangling pointer, then you should consider using <a href="https://en.cppreference.com/w/cpp/memory/shared_ptr" rel="nofollow noreferrer"><code>std::shared_ptr</code></a>, or possibly use <code>std::shared_ptr</code> internally and have <code>load()</code> return a <a href="https://en.cppreference.com/w/cpp/memory/weak_ptr" rel="nofollow noreferrer"><code>std::weak_ptr</code></a>.

For example, in <code>class resource_cache</code>, do the following:

SUBMITTED

self.sub_word

PRE

MID

sub_word

POST

SUBMITTED

parentId) {
 
    var

PRE

MID

var

POST

SUBMITTED

numbers_color_map.items():
       colored_number = assign_color_to_number(number, default_color).ljust(padding)
       print(colored_number, end=' ') if number % LINE_WIDTH != 0 else print(colored_number)

   print

PRE

A lot of stuff are going on in <code>print_table</code>. The name is also misleading, what table are we printing here. It would not take much to get confused on what is really going on in the function.

Why smashed this into one line?

MID

 print(colored_number, end=' ') if number % LINE_WIDTH != 0 else print(colored_number)


POST

This looks smart but confuses the reader, he/she would need to pause a little to understand this piece of code.

This following can also be improved.

SUBMITTED

_last;
        int_t

PRE

MID

int_t

POST

SUBMITTED

to the original input. But, its sorted.
for a in range(0, len(k)):
    for b in range(0, len(k[a])):
        l = s.index(k[a][b

PRE

Those two <code>no</code> variables do <em>not</em> refer to the same thing, the latter shadowing the former. Tear out your globals and pass them around via function parameters and return values, or make a class.

Drop <code>0, </code> from these:

MID

for a in range(0, len(c)):
    for b in range(0, len(c[a])):


POST

I am using lists that are being treated as sets. As I found lists were easier to manipulate in python than sets.

That's... ominous, and a little baffling? How could a <code>set()</code> be a worse representation of an actual set than a <code>list()</code>?

Among the many consequences of this decision, this code:

SUBMITTED

attr_accessor :arr

PRE

should just be:

MID

arr


Same here:

while key &lt; self.arr.length


should be

while key &lt; arr.length


POST

You should prefer &quot;speaking&quot; predicate methods such as <a href="https://ruby-doc.org/core/Numeric.html#method-i-negative-3F" rel="nofollow noreferrer"><code>Numeric#negative?</code></a> over relational operators such as <code>&lt; 0</code>.

So, this:

SUBMITTED

defun make-pair (table i)
  (setf
   ;; increment pair count:
   (gethash 'pairs table) (1+ (gethash 'pairs table 0))
   ;; make first half of the new pair unavailable:
   (gethash i table) nil)
  table)

(defun keep-first-half-of-pair (table i)
  (setf (gethash i table) t)
  table)

(defun first-half-available-p (table i)
  (gethash i table))

(defun consider-one (table i)
  (if (first-half-available-p table i)
      (make-pair table i)
      (keep-first-half-of-pair table i)))

(defun count-pairs (integers)
  (let ((table (reduce #'consider-one
                       integers
                       :initial-value
                       (make-hash-table))))
    (gethash 'pairs table 0)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; boilerplate for running as a hacker rank submission
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(read-line) ;; we don't need n

(defvar integers
  (read-from-string
   (concatenate 'string
                &quot;(&quot; (read-line) &quot;)&quot;)))

(format t &quot;~a~%&quot; (count-pairs

PRE

Summing all these considerations, I will rewrite your solution using
local helper functions, to reduce the complexity and simplify the
use of the parameters, and substitute the iterator while reducing by
one the number of auxiliary functions.

MID

 (defun count-pairs (integers)
  (let ((pairs 0)
        (table (make-hash-table)))
    (flet ((make-pair (i)
             (incf pairs)
             (setf (gethash i table) nil))
           (keep-first-half-of-pair (i)
             (setf (gethash i table) t))
           (first-half-available-p (i)
             (gethash i table)))
      (loop for i in integers
        if (first-half-available-p i)
          do (make-pair i)
        else
          do (keep-first-half-of-pair i)))
    pairs))


If you need to return the table there is no other possibility. In the above solution this is not necessary, since <code>table</code> is not returned by the functions.

It's just a convention that you can follow or not. If you want to stick to Common Lisp common style, it is better to use the <code>-p</code> convention.

Yes.

Finally, for the fifth point, I would prefer a more concise solution, that counts all the elements, and only at the end counts all the pairs, in this way:

(defun count-pairs (integers)
  &quot;returns the numbers the pairs of the list integers&quot;
  (let ((table (make-hash-table)))
    (loop for i in integers
          do (incf (gethash i table 0)))
    (loop for v being the hash-value of table
          sum (truncate v 2))))


POST

SUBMITTED

memory&gt;

struct out_of_range

PRE

Broken.

Please have a read of the articles I wrote on building your own vector.

Have a read of the vector series: lokiastari.com/series

There is one of these in the <a href="https://en.cppreference.com/w/cpp/error/out_of_range" rel="nofollow noreferrer">standard</a>!

MID

struct out_of_range {};


POST

If you are going to define your own exceptions then please at least inherit from <code>std::exception</code> but preferably <code>std::runtime_error</code>. These base classes allow you to store an error message that you can use for logging.

Sure it is fine to use a standard allocator. But remember that allocators simply allocate the space they do not call the constructor or the destructor of the object that they store.

SUBMITTED

bool check_username_valid(const string&amp; str, string &amp;out_error) {
    static const struct LUT {
        bool a[256]{};
        LUT() {
            for (int x = 'a'; x &lt;= 'Z'; x++) a[x] = true;
            for (int x = 'A'; x &lt;= 'Z'; x++) a[x] = true;
            for (int x = '0'; x &lt;= '9'; x++) a[x] = true;
            a['_'] = true;
        }
        inline bool operator [] (char x) const { return a[int(((unsigned char)(x)))]; }
    } allow;

    if (str.length() &lt; MinUsernameLen) { out_error = &quot;Username Too Short&quot;; return false; }
    if (str.length() &gt; MaxUsernameLen) { out_error = &quot;Username Too Long&quot;; return false; }
    for (char c : str)
        if (!allow[c]) {
            out_error = &quot;Invalid Character in Username&quot;;
            return false;
        }
    return true

PRE

Instead of the loop, we can use <code>std::all_of()</code> (or <code>std::any_of()</code> with the opposite condition).  That can make the code clearer, because it signals intent at the beginning, and we don't need to unpick control flow as we do with <code>for</code>/<code>return</code>.  With C++20, we are able to pass a <em>range</em> object such as <code>std::string</code> as argument instead of an iterator pair (as we do in C++17).

And we have <code>std::isalnum()</code>, which is likely implemented as a lookup table like this (with the caveat that we need to be careful about signed <code>char</code>).  It's more portable (the code we have will be wrong if there are non-alphabetic characters between <code>A</code> and <code>Z</code>, as there are on EBCDIC systems, for example) and easier to get right (witness the typo - <code>Z</code> instead of <code>z</code> - that means on ASCII-like systems we allow no lower-case letters).

We could change the interface to just return the error string, with a null pointer indicating success, to avoid the &quot;out&quot; parameter.

MID

#include &lt;algorithm&gt;
#include &lt;cctype&gt;
#include &lt;string&gt;
    
// return a null pointer if valid, else a pointer to the error message
const char *check_username_valid(const std::string&amp; str)
{
    if (str.length() &lt; MinUsernameLen) { return &quot;Username Too Short&quot;; }
    if (str.length() &gt; MaxUsernameLen) { return &quot;Username Too Long&quot;; }
    auto const char_permitted
        = [](unsigned char c){ return c == '_' || std::isalnum(c); };

    if (std::all_of(str.begin(), str.end(), char_permitted)) {
        return nullptr;
    }

    return &quot;Invalid Character in Username&quot;;
}


If we'll be adding more permitted username characters, we might want to use the lookup-table approach - but we don't need a new type, and this <code>static const</code> can be built at compilation time:

#include &lt;array&gt;
#include &lt;climits&gt;

bool legal_username_char(unsigned char c)
{
    static auto const table
        = []{
              std::array&lt;bool,UCHAR_MAX+1&gt; a;
              for (unsigned char i = 0;  i++ &lt; UCHAR_MAX; ) {
                  a[i] = std::isalnum(i);
              }
              // additional non-alnum chars allowed
              a['_'] = true;
              return a;
          }();
    return table[c];
}


POST

That idiom is an <em>immediately-invoked lambda</em>, and it's very handy for creating complex constants like this.  Note also the use of <code>UCHAR_MAX</code> rather than making assumptions about the size of the type.

Minor: no need for cast to <code>int</code> when indexing (<code>a[int(((unsigned char)(x)))]</code>).  An unsigned char is perfectly fine as array index.

SUBMITTED

cmake_minimum_required(VERSION 3.16.1)

set(EXECUTABLE_NAME &quot;Parser_Unit_Test.exe&quot;)

project(${EXECUTABLE_NAME} LANGUAGES C VERSION 1.0)

if(&quot;${CMAKE_BUILD_TYPE}&quot; STREQUAL &quot;Debug&quot;)
    set(GCC_WARN_COMPILE_FLAGS  &quot; -Wall &quot;)
    set(CMAKE_C_FLAGS  &quot;${CMAKE_CXX_FLAGS} ${GCC_WARN_COMPILE_FLAGS}&quot;)
endif()

set(VM_SRC_DIR &quot;../../..&quot;)
set(LEXICAL_TEST_DIR &quot;../../State_Machine_Unit_Test/State_Machine_Unit_Test&quot;)
set(COMMON_TEST_DIR &quot;../../Common_UnitTest_Code&quot;)

add_executable(${EXECUTABLE_NAME} internal_parser_tests.c  parser_unit_test.c  parser_unit_test_main.c ${VM_SRC_DIR}/error_reporting.c ${VM_SRC_DIR}/human_readable_program_format.c ${VM_SRC_DIR}/lexical_analyzer.c ${VM_SRC_DIR}/opcode.c ${VM_SRC_DIR}/parser

PRE

Here are some ideas that may help you improve your code.

Many people misunderstand CMake as a &quot;build system&quot; but it is not.  It is a tool for <em>creating</em> a build system.  Generally speaking, this means that you describe the desired artifacts (executables to be compiled, tests to be compiled and run, documentation to be constructed, etc.) and then CMake translates that into a build system that will run on the target system.  Like <a href="https://www.gnu.org/software/automake/manual/html_node/Autotools-Introduction.html" rel="nofollow noreferrer"><code>autotools</code></a> before it, it attempts to take care of the annoying arbitrary differences among systems, compilers and build environment to do three things:

When you add dependencies such a <code>bash</code> shell scripts, you impair the ability of CMake to provide these benefits.  Through this review, I'll show how we can both restore those benefits <em>and</em> simplify.

One of the current <code>CMakeLists.txt</code> files includes these lines:

MID

set(EXECUTABLE_NAME &quot;Run_All_Unit_Tests.exe&quot;)

project(${EXECUTABLE_NAME} LANGUAGES C VERSION 1.0)

if(&quot;${CMAKE_BUILD_TYPE}&quot; STREQUAL &quot;Debug&quot;)
    set(GCC_WARN_COMPILE_FLAGS  &quot; -Wall &quot;)
    set(CMAKE_C_FLAGS  &quot;${CMAKE_CXX_FLAGS} ${GCC_WARN_COMPILE_FLAGS}&quot;)
endif()

set(VM_SRC_DIR &quot;../../..&quot;)


POST

Even though that's not very many lines, there are a number of problems with platform assumptions.  First, there's the executable name -- most platforms do not use an <code>.exe</code> suffix.  CMake is smart enough to know the required suffix for each platform so simply omit it.

Second, the <code>project</code> command is typically going to only appear exactly once in the top level directory.  Your files seem to have them sprinkled in multiple places.  This makes the project more fragile and harder to reuse.  It also leads an experienced CMake reader to wonder if you intend for these to actually be separate projects, but it doesn't make much sense to have a <code>Parser_Unit_Test</code> without a parser, so they can't really be separate.

Third, the <code>if</code> clause will fail unless we happen to be using <code>gcc</code> (or something compatible like <code>clang</code>).  Better is to either use <a href="https://cmake.org/cmake/help/latest/command/add_compile_options.html" rel="nofollow noreferrer"><code>add_compile_options</code></a> or use <a href="https://cmake.org/cmake/help/latest/command/target_compile_options.html#command:target_compile_options" rel="nofollow noreferrer"><code>target_compile_options</code></a> for settings per target.

Fourth, setting the <code>VM_SRC_DIR</code> explicitly enforces a very specific directory structure which is not easily altered.  In some cases this is unavoidable, but this is not one of those.  Instead, because this is within a unit test, a better approach would be to simply pass from a higher level <code>CMakeLists.txt</code> file the path to the thing you're attempting to test.

It's good that you're using <code>target_compile_definitions</code> instead of setting things globally, but you should also reconsider the use of lines like these:

SUBMITTED

ReturnAllCombinationsOfInputtedList

PRE

MID

ReturnAllCombinationsOfInputtedList()

POST

SUBMITTED

Card&gt

PRE

MID

&gt;=

POST

This part:

SUBMITTED

quot;parseDate.................................Date [{}]&quot;, dateString);
    LocalDateTime   ldateResults = null;
    dateString = dateString.replace(&quot;/&quot;,&quot

PRE

Don't shorten variable names just because you can, it makes the code harder to read and harder to maintain. Case in point is &quot;ltwoXcp&quot;, what's that supposed to even mean?

MID

dateString = dateString.replace(&quot;/&quot;,&quot;-&quot;);


Do not assign to parameters, it makes the code harder to debug. Treat all parameters as <code>final</code> (you can also make all parameters <code>final</code>, but in my opinion that is too much noise for a very simple rule to follow).

try { ldateResults = getLocalDateTimeFromString ( dateString, &quot;MMyyyy&quot; ); }
catch ( Exception ltwoXcp ) {


Same here regarding formatting. With default Java-style formatting, the code would look like this:

try {
    ldateResults = getLocalDateTimeFromString ( dateString, &quot;MMyyyy&quot; );
} catch (Exception ltwoXcp) {


Again, whether or not that is easier to read is up to the reader. But overall you seem to go for tenser code, which does not improve readability or maintainability as you would believe.

LOG.warn(&quot;Date [{}] failed with format [MMyyyy], trying another&quot;, dateString);


POST

Logging every failed parse attempt seems excessive.

SUBMITTED

quot; * 100)

    imap_server.close()
    imap_server.logout()


def add_server():
    # Add

PRE

is done with the file as soon as you have <code>settings</code>, so the <code>try</code> and onward should be de-indented.

It's good that you have a <code>finally</code> guaranteeing <code>server.quit</code>, but it would be better to put the <code>server</code> in a <code>with</code>, since <code>SMTP</code> is a context manager.

Your IMAP calls

MID

imap_server.close()
imap_server.logout()


POST

are missing similar protection.

<code>view_inbox</code> needs to be broken up into subroutines. It's way too long and complex right now.

SUBMITTED

import javax.swing.*;
import javax.swing.border.EmptyBorder;
import java.awt.*;

public

PRE

So what solution you pick is up to you...story time! More times than not I've encountered very &quot;liberate&quot; use of the <code>final</code> keyword and ran into more troubles than it solved. It happens quite often to me that I need to extend a class to either lever out or strap on functionality because my use-case does not perfectly fit the implementation. A <code>final</code> class removes any possibility to do so which means that other ways must be found to do that.

There's also the question what you want to try to achieve. Personally, I got told that using <code>final</code> literately will make the code easier to read and maintain, that is an opinion that I cannot agree with. Because if methods and members are randomly <code>protected</code>, <code>private</code> and <code>private final</code> and made need to be changed every now and then when the logic changes, it does reek more like a cargo-cult like decision than an active design decision.

Enough of the rant, I could talk hours about this and it's slightly outside the scope of this review.

MID

import javax.swing.*;
import java.awt.*;


POST

Ideally you'd avoid wildcard imports to make it easier to see what classes are being used (collisions are possible). A good IDE will also automatically manage imports for you.

SUBMITTED

mysqli_connect_error()) {
         
         die(&quot;Couldn't connect to the database. try again later.&quot;);
         
     } 
 
      $query = &quot;SELECT * FROM `users`&quot;;

      if($result = mysqli_query($link, $query)) {
          
          $row = mysqli_fetch_array($result);
          
      }

        $signupButton

PRE

Bringing this briefly back to <em>errors</em>: you have named a whole bunch of errors reasonably well (<code>$usernameError</code>, <code>$termsandcontitionsError</code>) and then you have a random <code>$error</code>. To me that looks like a <em>general error condition</em> but in reality it is actually there to note when the username already exists in the database. Changing it's name would make that much clearer.

Other than that you should be aware that you re-use a few variable names. Especially when it come to queries and result sets. There's potential for confusion here and, if the code were more entangled/complex, there's the possibility you could overwrite something prematurely. If the <em>bland names</em> (e.g. <code>$query</code> and <code>$result</code>) were inside of a function then it doesn't matter so much (assuming they're used once only) because readers are already aware of scope; but having multiple occurrences and overwrites in any one body of code is not a good idea.

There is a significant percentage of your code that, well, doesn't seem to do anything <strong>or</strong> is repeated later in the code...

This query just executes and does nothing with the result set:

MID

$query = &quot;SELECT * FROM `users`&quot;;

if($result = mysqli_query($link, $query)) {

  $row = mysqli_fetch_array($result);

}


POST

Anything to do with <code>$creatorAccount</code>, <code>$payment</code> &amp; <code>$signupButton</code> is halted after the input is <em>sanitized</em>. Which means the related errors are also, kind of, pointless?

<em>Terms and Conditions</em> has a few variables (including error variables) and <code>if</code> statements but it never actually does anything: the code never actually checks whether T&amp;C are set.

Every sigle input is <em>sanitized</em> with <code>signupform_input</code> at least twice, for example:

SUBMITTED

range(0,4):
    wynik = [ALPHABET[i+x] if i+x&lt;len(ALPHABET) else ALPHABET[i+x-len(ALPHABET)] for i in

PRE

MID

ALPHABET[i+x] if i+x&lt;len(ALPHABET) else 

ALPHABET[i+x-len(ALPHABET)]

ALPHABET[(i+x) % len(ALPHABET)]

POST

SUBMITTED

the mean

PRE

For <code>Copy</code> types like <code>usize</code>, there is no need to take a reference.
Simply pass the <code>usize</code> instead.

MID

mean

POST

Since your <code>sum</code> checks for empty collections already, you can use the
result rather than check again in <code>mean</code>:

SUBMITTED

Object { $_.Trim() }
            $joinedlines = @()
            for ($i=0;$i -lt $FileContent.count;$i++){
                if ($FileContent[$i

PRE

MID

for ($i=0;$i -lt $FileContent.count;$i++){

for ($i = 0; $i -lt $FileContent.count; $i++) {

POST

SUBMITTED

Symbol}})
    isnothing(parameter_names) ? nothing

PRE

MID

parameter_names = nothing


Uh.  You know what you are doing there?  You declare a <em>mutable global variable</em>, which is bad for type stability to begin with.  And then you write to it multiple times from the top level, in every <code>include</code>!

Make the variable local wherever you use it.

birth = Birth(Dict_initializer(parameter_names),birth_process)


POST

Same here.  Make it local.

SUBMITTED

include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt

PRE

Your description appears to suggest you're reimplementing <code>wipe</code>; I recommend you read its sources to see what an effective implementation looks like.  I'll note that the concept could well be flawed if you're writing to a log-structured filesystem or to wear-levelling media - both of those need specific actions to erase data, because overwriting will simply create new data blocks elsewhere.

The &quot;PascalCase&quot; naming convention makes this code surprisingly hard to read (and not just because capital <code>I</code> looks a lot like <code>1</code>, and <code>Int</code> sounds a lot like <code>int</code>).  I would prefer to see more conventional identifiers, so that variables <em>look like</em> variables.

This include looks pointless:

MID

 #include &lt;unistd.h&gt;


POST

As we're using only Standard Library, prefer to omit this, for a portable program.

SUBMITTED

const std::string b = std::to_string(ib);

    int32_t i = 0;
    if (a.size() == b.size()) {
        while (i &lt; a.size()) {
            if (a.at(i) == b.at(i)) {
                ++i;
                
                continue;
            }
            else if (a.at(i) &gt; b.at(i))
                return true;
            else
                return false;
        }
    } else {
        int32_t min_size = static_cast&lt;int32_t&gt;(std::min(a.size(), b

PRE

That works just as well.

MID

while (i &lt; min_size) {
    if (a.at(i) == b.at(i)) {
        ++i;
        
        continue;
    }
    else if (a.at(i) &gt; b.at(i))
        return true;
    else
        return false;
}


The next naked loop; what exactly is this one doing? Well, it’s going from 0 (which is the value of <code>i</code> at the start of the loop, though it isn’t immediately obvious from the code), to the minimum size of the two strings, and doing a lexicographical comparison. In other words:

if (auto const res = a.compare(0, min_size, b); res != 0)
{
    return res &lt; 0;
}


POST

We don’t even need to check which one is smaller here, because we’re using the minimum size.

Now from this point on is where the problems really start. At this point, you’ve dealt with the case where the two strings have equal length (of course, you need to fix the bug when they’re exactly equal). You’ve also dealt with the case where you have a short string and a long string, and the first part of the long string is either greater or less than the short string. So what you have now is the case where you have a short string, and a longer string that starts with the short string. In other words: the short string is <code>&lt;pattern&gt;</code>, and the long string is <code>&lt;pattern&gt;&lt;something&gt;</code>.

So what happens next?

Well, what you do is get the first digit of <code>&lt;pattern&gt;</code>, and then compare it with every digit in <code>&lt;something&gt;</code>. But does that make sense?

Consider when <code>&lt;pattern&gt;</code> is 42, and <code>&lt;something&gt;</code> is 41 or 49:

With 41, you compare the first 4 with the 4 in 41… it’s <code>&gt;=</code>, so you return <code>true</code>.

No problem, 42 should compare less than 4241, because 424241 is greater than 424142.

With 49, you compare the first 4 with the 4 in 49… it’s <code>&gt;=</code>, so you return <code>true</code>.

But 42 should compare less than 4249, because 424249 is <em>NOT</em> greater than 424942.

So your algorithm doesn’t work.

As for the rest of the function, I won’t review it in detail (because it needs to be rewritten), but I’ll just say:

SUBMITTED

public abstract class ServiceBase&lt;TEntity, TRepository, TPrimaryKey&gt; : IServiceBase&lt;TEntity, TPrimaryKey&gt;
        where TEntity : class
        where TPrimaryKey : struct
        where TRepository : IBaseRepository&lt;TEntity, TPrimaryKey&gt;
{
    public TRepository Repository;

    public ServiceBase(IBaseRepository&lt;TEntity, TPrimaryKey&gt; rep)
    {
        Repository = (TRepository)rep;
    }

    public virtual async Task&lt;TEntity&gt; GetById(TPrimaryKey id)
    {
        return await Repository.Find(id);
    }

    public async Task&lt;TEntity&gt; GetSingle(Expression&lt;Func&lt;TEntity, bool&gt;&gt; whereCondition)
    {
        return await Repository.GetQueryable().Where(whereCondition).FirstOrDefaultAsync();
    }

    public async Task&lt;IEnumerable&lt;TEntity&gt;&gt; GetAll()
    {
        return await Repository.GetAll();
    }

    public IEnumerable&lt;TEntity&gt; GetAll(Expression&lt;Func&lt;TEntity, bool&gt;&gt; whereCondition)
    {
        return Repository.GetQueryable().Where(whereCondition);
    }

    public IQueryable&lt;TEntity&gt; GetAllQueryable()
    {
        return Repository.GetQueryable();
    }

    public IQueryable&lt;TEntity&gt; Query(Expression&lt;Func&lt;TEntity, bool&gt;&gt; whereCondition)
    {
        return Repository.GetQueryable().Where(whereCondition);
    }

    public virtual async Task&lt;TEntity&gt; Create(TEntity entity)
    {
        return await Repository.Add(entity);
    }

    public virtual async Task Delete(TEntity entity)
    {
        await Repository.Delete(entity);
    }

    public virtual async Task Update(TEntity entity)
    {
        await Repository.Edit(entity);
    }

    public async Task&lt;long&gt; Count(Expression&lt;Func&lt;TEntity, bool&gt;&gt; whereCondition)
    {
        return await Repository.GetQueryable().Where(whereCondition).CountAsync();
    }

    public async Task&lt;long&gt; Count()
    {
        return await Repository.GetQueryable().CountAsync();
    }       

    public async Task&lt;IEnumerable&lt;TEntity&gt;&gt; BulkInsert(IEnumerable&lt;TEntity&gt; entities)
    {
        return await Repository.BulkInsert(entities);
    }

    public async Task BulkUpdate(IEnumerable&lt;TEntity&gt; entities)
    {
        await Repository.BulkUpdate(entities

PRE

The simplified version would be something like this :

MID

public interface IRepository : IDisposal
{
    Task&lt;int&gt; Save();
}

public interface IRepositoryQueryable&lt;TEntity, TKey&gt; : IRepository
    where TEntity : class 
    where TKey : struct
{
    IQueryable&lt;TEntity&gt; GetQueryable();
}

public interface IRepositoryBulk&lt;TEntity, TKey&gt; : IRepository
where TEntity : class 
where TKey : struct
{
    Task&lt;int&gt; BulkInsert(IEnumerable&lt;TEntity&gt; entities); // returns number of inserted entries
    Task&lt;int&gt; BulkUpdate(IEnumerable&lt;TEntity&gt; entities); // returns number of updated entries
}

public interface IRepository&lt;TEntity, TKey&gt; : IRepository
    where TEntity : class 
    where TKey : struct
{
    Task&lt;IEnumerable&lt;TEntity&gt;&gt; GetAll();
    IEnumerable&lt;TEntity&gt; GetAll(Expression&lt;Func&lt;TEntity, bool&gt;&gt; whereCondition);
    Task&lt;TEntity&gt; GetSingle(Expression&lt;Func&lt;TEntity, bool&gt;&gt; whereCondition);
    Task&lt;TEntity&gt; GetByKey(TKey id);
    Task Insert(TEntity entity);
    Task Update(TEntity entity);
    Task Delete(TEntity entity);
}


POST

SUBMITTED

import useConstructor

PRE

MID

useConstructor

POST

SUBMITTED

gt; tempList

PRE

MID

tempList

POST

SUBMITTED

capacity() const noexcept { return m_Capacity; }
  size_type max_capacity() const noexcept {
    return std::numeric_limits&lt;size_type&gt;::max();
  }
  const_pointer data() const { return m_RawData; }
  void

PRE

Missing <code>return</code>.

MID

  size_type max_capacity() const noexcept {
    return std::numeric_limits&lt;size_type&gt;::max();
  }


POST

Standard containers don’t have <code>max_capacity()</code>… but they do have <code>max_size()</code>, which you don’t.

Also, assuming you can hold the max value of <code>size_type</code> seems optimistic. A better estimate would probably be <code>std::numeric_limits&lt;size_type&gt;::max() / sizeof(T)</code>. But meh, I’ve never seen anyone actually <em>use</em> <code>max_size()</code>.

SUBMITTED

Call rand_num

PRE

MID

rand_num

POST

So prefer:

SUBMITTED

string getFilePath

PRE

MID

getFilePath

POST

SUBMITTED

quot;input

PRE

MID

input

input

POST

SUBMITTED

max = vec[i];
return max;
}

void test (std::vector&lt;int&gt; vec, int i) {
assert

PRE

Let's change add another test to avoid that implementation:

MID

std::vector&lt;int&gt; vec = { 7, 50, 16, 8, 25, 9, 12,113 };
test (vec, 113);


Now I can't just return 112, I have to actually do something else. I would use either of these as my implementation:

return vec.lastElement();
return vec[7];


POST

More test cases needed to fix those problems. I could go on, but I think you understand. I think the following test cases could be a good base:

SUBMITTED

xdt:Transform

PRE

MID

Transform

POST

I've checked the transformation with <a href="https://elmah.io/tools/webconfig-transformation-tester/" rel="nofollow noreferrer">this tool</a>.

SUBMITTED

src=&quot

PRE

I'm not familiar with Paper so can't say anything about that. And I won't say much about the HTML, as it's obviously just a functional placeholder, except two points:

MID

&quot;

POST

SUBMITTED

c);
      if (!isDigit &amp;&amp; !isNonDigit) {
        unread();
        break

PRE

On the whole, the code was easy to read, and the tests were concise (apart from the fully qualified <code>be.imgn.common.base.Version.valueOf</code> call.  Here's a few things to think about.

The <code>VersionParser</code> class takes in a <code>String</code> and then provides a <code>parse</code> method which actually does the parsing work.  However, this method can only ever be called once.  If it's called more than once, then it fails, because the source string has already been parsed and the method assumes that it's only called on a newly constructed parser.  This feels wrong.  It's relying on the clients knowing too much about how the class works.  A better approach might have been to make the class constructor private and have a static <code>parse</code> method for the interface, which spun up the data, if required, and performed the parse.  Alternately, <code>parse</code> could simply reset processed back to the beginning of the source data an reprocess it, or even return a cached version...

Circular dependencies as a general rule are bad.  They have a tendency to result in tightly coupled code that bites you, just as you decide you want do reuse a bit of the code somewhere else.  As it stands, you've got a circular dependency.  Your <code>Version</code> calls <code>VersionParser</code> which then creates a <code>Version</code>.  To me, it seems like a <code>VersionParser</code> might need to know about a <code>Version</code>, in order to construct it, but a <code>Version</code> shouldn't really need to know about a <code>VersionParser</code>.

MID

!isDigit &amp;&amp; !isNonDigit

POST

One of your goals is self explanatory code.  If found this line less than obvious, my instinct was non-digit is the same as not-a-digit, which is everything that isn't a digit... However that's clearly not the case.  A NonDigit, appears to be an alpha, or '-'.  A better name might help, however you only actually seem to use it in this check.  Maybe a method <code>isValidVersionCharacter</code> which evaluated digits and 'non digits', would be clearer...

There's quite a lot of <code>!</code> in your code.  For me, this made some of the calls to <code>check</code> awkward to process.

SUBMITTED

enum HandType

PRE

Same here: you could use a <code>struct Rank(u8);</code> or an <code>enum Rank {...}</code>. If the parsing here is complex you could also implement <code>FromStr</code> for <code>Rank</code> and <code>Suit</code>, and defer to that, instead of implementing it in-line.

Let's skip ahead a bit...

MID

HandType

POST

SUBMITTED

class Identifier

PRE

MID

Identifier

POST

SUBMITTED

var code = codeEntered;
  var run = code *= 1;
  return(run

PRE

because the assignment (the first line) <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Assignment" rel="nofollow noreferrer">evaluates to the value of the right hand side</a>.

Instead of writing <code>var code = codeEntered;</code>, you can save yourself a line and just use the variable <code>codeEntered</code> instead of making a new variable.

The line  <code>var run = code *= 1;</code> also is a bit unexpected. This is equivalent to writing

MID

code = code * 1;
var run = code;


POST

But <code>code</code> is a string, and multiplying it by <code>1</code> evaluates to <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN" rel="nofollow noreferrer"><code>NaN</code></a> (try it!), so after that line, <code>code == run == NaN</code>.

Code style: <code>return(run);</code> would typically be written <code>return run;</code> instead (it's not a function).

In summary, <code>testCode</code> actually always returns <code>NaN</code>, but the value then gets thrown away because it isn't used anywhere. In effect, your code actually just runs <code>h1.textContent = world</code> when you click the button, then runs <code>testCode</code> whose value isn't used (but is always NaN anyway).

I hope this gives you some useful feedback.

SUBMITTED

private async void WorkerFuncCore

PRE

MID

async void

async Task

async void

POST

SUBMITTED

std;

class

PRE

If this is your first C++ project, then congratulations, it is not a bad attempt at all! However, there are still a lot of areas where your code can be improved. I'll list some of those below. I recommend you try to improve your code based on these suggestions, and the consider creating a new code review question here with the updated code.

MID

class

POST

I have decided to make snake game as my first project with C++ (using OOP)

I don't know if this mindset is what caused this issue, or maybe experience with Java, however not everything needs to be a <code>class</code> in C++. The very first piece of code you pasted in your question is this:

SUBMITTED

Program
    {
        static

PRE

MID

static

POST

SUBMITTED

Dim calc

PRE

MID

calc

POST

Single Responsibility Principle (SRP): Each procedure should have a single purpose (or, have a single reason to change)

SUBMITTED

void         copy_small

PRE

MID

copy_small

POST

SUBMITTED

no_of_files = 0
        self.no_of_folders = 0
        self.last_opened_folder = &quot;&quot;

    def create_basics(self, a):
        if self.val[0] == 0:  # if this is first time then pass
            pass
        else:  # if this not the first time then delete all the old widgets
            self.left.pack_forget()
            self.up.pack_forget()
            self.parent_frame.pack_forget()
            self.down.pack_forget()
        # after deleting the old widgets creating new one
        self.left = tk.Frame(self.window, bg=&quot;#ffffff&quot;, width=10)
        self.left.pack(side=&quot;left

PRE

While you say they're globals, I don't have the faintest clue about what they represent. And looking through your code, I'm still confused. Variables should be representative of the data they store.

Instead of

MID

if self.val[0] == 0:  # if this is first time then pass
    pass
else:  # if this not the first time then delete all the old widgets
    self.left.pack_forget()
    self.up.pack_forget()
    self.parent_frame.pack_forget()
    self.down.pack_forget()


How about checking if the value isn't 0?

if self.val[0] != 0:
    self.left.pack_forget()
    self.up.pack_forget()
    self.parent_frame.pack_forget()
    self.down.pack_forget()


POST

The same concept can be applied to multiple other places in your code.

SUBMITTED

usr/bin/perl6
use v6;

my $a;
my $b = 34;
my $c;
$a = prompt &quot;enter number: &quot;;
$c = ($a * $b);
say  &quot;$a multiplied by  $b is $c&quot

PRE

To tighten your code a bit, you can declare <code>my $a</code> and assign in the same line:

MID

my $a = prompt &quot;enter number: &quot;;
my $b = 34;
my $c;
$c = ($a * $b);
say  &quot;$a multiplied by  $b is $c&quot;;


POST

The above seems to solve your question, however a user might not respond with the proper input. If a user replies to the prompt with <code>Hello</code> you'll get an ungraceful error:

SUBMITTED

size,
               const

PRE

MID

const

POST

It looks like the dimensions of a matrix are fixed at construction time. You should therefore make the member variables that represent the size and shape of the matrix <code>const</code>.

Note that you can, and will need to, call functions inside the member initializer list, like so for example:

SUBMITTED

struct Cacher

PRE

Even though I'm relatively new to Rust myself, I'll give this a shot since no one else has responded so far.

MID

Cacher

POST

Let's test that <code>Cacher</code> is working as intended (wouldn't call <code>calc</code> on the same value twice) by adding a log:

SUBMITTED

end();
    }

    auto

PRE

MID

auto

POST

SUBMITTED

public static async Task ForEachAsyncSemaphore&lt;T&gt;(this IEnumerable&lt;T&gt; items,
                                                      Func&lt;T, Task&gt; func,
                                                      int dop,
                                                      CancellationToken ct)
    {
        Exception capturedException = null;

        var childCts = new CancellationTokenSource();
        var linkedTokens = CancellationTokenSource.CreateLinkedTokenSource(ct, childCts.Token);

        using (var semaphore = new SemaphoreSlim(dop))
        {
            var cancellationTask = Task.Delay(Timeout.Infinite, linkedTokens.Token);
            var tasks = items.Select(async item =&gt;
            {
                await semaphore.WaitAsync(linkedTokens.Token);

                try
                {
                    await func(item);
                }
                catch (Exception ex)
                {
                    capturedException = ex;
                    childCts.Cancel();
                }
                finally
                {
                    semaphore.Release();
                }

            }).ToArray();

            // Use cancellation task as signal to exit early if unexpected exception
            await Task.WhenAny(Task.WhenAll(tasks), cancellationTask);

            if (capturedException != null)
            {
                throw capturedException

PRE

First let me share with you my revised version then I will detail the changes what I've made:

MID

public static async Task ThrottledConcurrenctForeach&lt;T&gt;(
    this IEnumerable&lt;T&gt; toBeProcessedItems, Func&lt;T, Task&gt; asyncOperation,
    int maxDegreeOfConcurrency, CancellationToken externalCancellationToken)
{
    ExceptionDispatchInfo capturedException = null;

    var internalCancellation = new CancellationTokenSource();
    var internalCancellationSignal = new TaskCompletionSource&lt;object&gt;();

    var combinedCancellationTokenSource = CancellationTokenSource.CreateLinkedTokenSource(externalCancellationToken, internalCancellation.Token);
    combinedCancellationTokenSource.Token.Register(() =&gt; internalCancellationSignal.TrySetCanceled(), useSynchronizationContext: false);

    using var throttler = new SemaphoreSlim(maxDegreeOfConcurrency);
                
    var processingOperations = toBeProcessedItems.Select(async item =&gt;
    {
        await throttler.WaitAsync(combinedCancellationTokenSource.Token);

        try { await asyncOperation(item); }
        catch (Exception ex)
        {
            capturedException = ExceptionDispatchInfo.Capture(ex);
            internalCancellation.Cancel();
        }
        finally { throttler.Release(); }

    });

    await Task.WhenAny(Task.WhenAll(processingOperations), internalCancellationSignal.Task);
    capturedException?.Throw();
}


POST

As you can see I've done a lots of renaming. I do believe that using the meaningful names improves readability and gives clarity. Here are a few examples:

SUBMITTED

NumberFormat = &quot;0.00&quot;;

                                    //Remove the word &quot;M/S&quot;

                                    CellRange[] ranges = newSheet.FindAllString(&quot;M/S&quot;, false, false);

                                    foreach (CellRange range in ranges)
                                    {
                                            range

PRE

and use it to remove <code>M/S</code> from the cells like :

MID

//Remove the word &quot;M/S&quot;
RemoveString(targetSheet, &quot;M/S&quot;); 


POST

you can do the same for removing white spaces, duplicates and sorting &amp; autofit columns as well.

Also, all the code after this line :

SUBMITTED

i &lt

PRE

In this rewrite, I'm passing in a function to mergeSort() that tells mergeSort how to convert a given array value into something that can be sorted using javascript's <code>&lt;</code>, <code>&gt;</code>, and <code>===</code> operators. This gives the mergeSort() function flexibility to be used in a wide variety of places. For your specific scenario, you're wanting to sort arrays of elements. So, this calcSortKey function will take each element, look-up the corresponding text data, then parse it if needed.

I'm using the following algorithm to parse the text data:

MID

&lt;

POST

SUBMITTED

class ...Pair

PRE

Your <code>FoldedMap</code> has a member function <code>_merge()</code>, which doesn't work (there's no corresponding <code>_merge()</code> in <code>MapBase</code>), but also it should just be renamed to <code>merge()</code>; function overloading should work just fine.

MID

Pair

POST

Instead of making <code>MapBase</code> be a template of two types, make it a template of just <code>Pair</code>:

SUBMITTED

CharSequence text = Text;
        int duration = Duration

PRE

Your question presents a main activity that seems to act as a test harness for a particular case 'dogggg'.  If the common password list has been downloaded then 'dogggg' is weak, if it hasn't then it's not.  This is OK if you are just trialling something, however it makes review feedback less useful than it could otherwise be.  We effectively have no real knowledge about how it is you're planning on using your <code>PasswordStregthAssessment</code> class.  The use cases feel like they could frame future code improvements.  You should consider actually using and presenting the class in a project to aid ours and your understanding of the requirements.  Some of the below probably won't be relevant to your specific use cases...

The password file that you're downloading is about 70K (this doesn't seem like it's very big) and it hasn't been updated for 12 months and from what I can tell you don't own the project.  If I'd decided that it was a useful list for evaluating passwords, I would consider just taking a cut of the file, either manually, or as part of your build process, so that the file is actually bundled with your application as a resource.  If it does change, and you wanted the change, then you'd have the option of redeploying a new version of your app with the updated file.  Obviously this adds an overhead to taking updates, particularly if you don't normally need to update your app, however it gives you more control and reduces uncertainty about behaviour.

This comes back to my first point a bit, as the actual usage of the checker seems relevant.  If you don't want to package the password file along with your application, then the next relevant question is how often are you going to check the strength of a password?  Is it a one-shot evaluation that happens when the user registers your application, in which case downloading the list on-demand might make sense, or is the purpose of your application to let users try passwords and have them evaluated by your app, in which case many passwords are going to be checked.  If this is the case, then it might make more sense to actually download the password file once and save it locally, then use the local version for future validations.

You app's behaviour is inconsistent, it'll return different results if you're connected / not connected to the internet.  As a user, this might be confusing.  If you're using the password to connect to a remote system, does that have the same password validation rules or is that another inconsistency?

Naming for variables in Java is generally <code>camelCase</code>.  I wouldn't expect to see <code>int Duration</code> for example.  Adding extra variables isn't always necessary and creates extra noise that the reader has to work through.  So, for example:

MID

int duration = Duration;


POST

Where <code>Duration</code> is already an <code>int</code> doesn't really add any value.  You don't mutate either <code>duration</code> or <code>Duration</code>.  Instead you could just pass <code>Duration</code> directly into the <code>makeText</code>.

Your backup list of passwords has a string resource for each password, which means you need to give each password a name, and add it to your list.  A more efficient approach would be to create a single <code>string-array</code> resource which contained all of the passwords.  You could then add passwords to the file without needing to change the code.  There's a tutorial on how to create and use a <code>string-array</code> resource <a href="https://www.homeandlearn.co.uk/android/grid_view_array.html" rel="nofollow noreferrer">here</a>.

You're synchronising if you add items to your <code>commonPasswords</code> during the runnable, however you're not synchronising if you perform the add of your backup items, or when you're reading from the list.   This doesn't look guaranteed to work to me.  Some discussion <a href="https://stackoverflow.com/q/55840034/592182">here</a>.

Something to consider is what happens if it takes 3 seconds to read the passwords from the remote file list (my phone will sometimes take longer than that just to make a connection, particularly if it decides it wants to switch from Wi-Fi to mobile data.

You're starting a brand new thread to go and do some work, then sleeping for 2 seconds whilst you wait for the thread to perform the fetch.  If the fetch only takes 1 second, you still wait for 2.  If it takes longer, then you give up waiting even though the thread keeps running (and may finish when you're no longer expecting it to).  If you really want to take this approach, consider killing the thread at the point that you give up on it.  But really this seems like a bad use of a thread.  Kicking the work to a background thread (preferably from a thread pool) could make sense if you're going to return the main thread to so that it can continue to handle GUI interactions, however it can't do that if it's blocking in a sleep.

Really, it feels like a better approach would be to add a time-out to your http request so that if it's unable to complete within a given period of time you can give up on the request and then continue processing with your alternative.  Additional reading <a href="https://stackoverflow.com/q/693997/592182">here</a> and <a href="https://stackoverflow.com/q/3000214/592182">here</a>.

SUBMITTED

a: int

PRE

MID

int

POST

SUBMITTED

eq 1 ]; then

PRE

MID

; then

POST

SUBMITTED

jpg, png, gif', 'max:2048'],
            ]);
        
            $current_user-&gt;first_name = $request-&gt;get('first_name');
            $current_user-&gt;last_name = $request-&gt;get('last_name');
            $current_user-&gt;email = $request-&gt;get('email');
            $current_user-&gt;bio = $request-&gt;get('bio');

            // Upload avatar
            if (isset($request-&gt;avatar)) {
                $imageName = md5(time()) . '.' . $request-&gt;avatar-&gt;extension();
                $request-&gt;avatar-&gt;move(public_path('images/avatars'), $imageName

PRE

The <code>UserProfileController::update()</code> method is somewhat long. Presuming that the model <code>UserProfile</code> is a sub-class of <code>Illuminate\Database\Eloquent\Model</code> then the <a href="https://laravel.com/api/5.8/Illuminate/Database/Eloquent/Model.html#method_update" rel="nofollow noreferrer"><code>update()</code> method</a> can be passed an array of attributes to update. Instead of these lines:

MID

$current_user-&gt;first_name = $request-&gt;get('first_name');
$current_user-&gt;last_name = $request-&gt;get('last_name');
$current_user-&gt;email = $request-&gt;get('email');
$current_user-&gt;bio = $request-&gt;get('bio');


POST

Get an array of fields to update from <code>$request-&gt;all()</code>, then set the <code>avatar</code> on that array if the avatar needs to be updated.

The validation rules could be moved out to a <a href="https://laravel.com/docs/8.x/validation#form-request-validation" rel="nofollow noreferrer">FormRequest</a> subclass.

SUBMITTED

temp = 0;
    for

PRE

MID

for

POST

SUBMITTED

def regex_2_find

PRE

MID

regex_2_find

POST

SUBMITTED

timePrecision;
};



class Fus {
public:
    Fus(){}
    virtual

PRE

<a href="https://www.codeproject.com/Tips/5249485/The-Most-Essential-Cplusplus-Advice" rel="nofollow noreferrer">Do not use <code>#define</code></a>.  These should be normal variables, declared <code>constexpr</code>.

MID

 Fus(){}
 virtual ~Fus(){}


POST

Use <code>=default</code>, assuming you need to declare them at all.

Why did you declare the destructor as <code>virtual</code> when you have no virtual functions in the class otherwise?  Clearly you won't be using it in a polymorphic manner... and I don't see anything being derived from it anyway.

<code>inline bool checkMatch(const Pulse &amp;pulseA, const InfoPulse &amp;pulseB, const unsigned long long &amp;seuilMatch, const unsigned long long &amp;sumTOADurationA);</code><br />
The <code>inline</code> keyword is redundant on functions declared inside the class body.  And there is no function body here!  What do you think <code>inline</code> will do here?

It appears that class <code>Fus</code> does not have any state at all.  That is, no <em>data</em> members.  So what is the point of defining the constructor and destructor?

The code is doing a lot of work to <code>pulseFus</code>, which suggests that there should be member functions of <em>that</em> class (<code>Pulse</code>).

These functions operate on a pure &quot;out&quot; parameter, which is bad.  Use function return values to return results!  A simple example is<br />
<code>void Fus::createPulse(const Pulse &amp;pulseA, const Pulse &amp;pulseB, Pulse &amp;pulseFus)</code><br />
which ought to be something like

SUBMITTED

color: &quot;text-green-600&quot;,
        icon: TiBatteryFull
    }
};

export default function BalanceIndicator({status}) {
    let Balance = battery[status].icon;

    return (
        &lt;div className=&quot;text-sm flex items-center&quot;&gt;
            &lt;i className={`mr-3 text-2xl ${battery[status].color}`}&gt;&lt;Balance /&gt;&lt;/i&gt;
        &lt;/div&gt

PRE

It can be declared with <code>const</code> instead, since it is only assigned once. This can help avoid <a href="https://softwareengineering.stackexchange.com/a/278653/244085">accidental re-assignment and other bugs</a>.

MID

let Balance = battery[status].icon;

return (
    &lt;div className=&quot;text-sm flex items-center&quot;&gt;
        &lt;i className={`mr-3 text-2xl ${battery[status].color}`}&gt;&lt;Balance /&gt;&lt;/i&gt;
    &lt;/div&gt;
)


With this approach the icon is stored in <code>Balance</code> yet the color needs to be looked up again. The icon and color could be stored in variables after a single look-up with <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" rel="nofollow noreferrer">destructuring assignment</a>.

const {icon, color} = battery[status];

return (
    &lt;div className=&quot;text-sm flex items-center&quot;&gt;
        &lt;i className={`mr-3 text-2xl color}`}&gt;&lt;icon /&gt;&lt;/i&gt;
    &lt;/div&gt;
)


POST

This makes the line containing the markup shorter, which improves readability.

What happens if <code>status</code> does not correspond to a key in <code>battery</code>? Perhaps it is unlikely but as code grows over time the likelihood could grow. The code should handle this scenario - perhaps with an error message or exception thrown.

SUBMITTED

phoneNumber
  .split

PRE

MID

split

POST

SUBMITTED

ByVal myNumber

PRE

MID

myNumber

POST

SUBMITTED

getMyRandom

PRE

MID

getMyRandom

POST

SUBMITTED

self.status

PRE

MID

.status

POST

SUBMITTED

string payload

PRE

MID

payload

POST

SUBMITTED

def PrintWordsOccurence(txt):
    lst = [x for x in txt.split(' ') if x != ' ' and x != '']
    newlst = list

PRE

It does the same filtering as you do. Just skip ' ' argument.

It looks overburdened, right? You can create a set of list comprehension as well:

MID

newlst = list({x for x in txt.split()})


or just

newlst = list(set(txt.split()))


but the best way is

You're reinventing it with worse time complexity.

f-strings look better (but it depends on your task).

<a href="https://www.python.org/dev/peps/pep-0008/" rel="noreferrer">PEP8</a> advices to use lower case with underscores: print_words_occurence

from collections import Counter
def print_words_occurence(txt):
   for word, count in Counter(txt.split()).items():
       print(f&quot;[{count}] {word}&quot;)


POST

Also consider dividing an algorithmic part and input/output - like yielding a pair (word, count) from the function and outputting it somewhere else.

SUBMITTED

class Info

PRE

MID

Info

POST

SUBMITTED

com/a/26065433/6667035
#ifndef M_PI
    #define M_PI 3.14159265358979323846
#endif


namespace TinyDIP
{
    // Forward

PRE

MID

#ifndef M_PI
    #define M_PI 3.14159265358979323846
#endif


POST

Don't use <code>#define</code>, and since you marked this as C++20 <a href="https://en.cppreference.com/w/cpp/numeric/constants" rel="nofollow noreferrer">use the constants supplied in the standard library</a>.

SUBMITTED

EF

PRE

MID

EF

POST

SUBMITTED

dict

PRE

MID

dict

POST

SUBMITTED

SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

ALTER VIEW [cp].[GetEcommerceItemsView]
AS
SELECT
    RTRIM(LTRIM(IV.ITEMNMBR)) AS ItemNumber
   ,RTRIM(LTRIM(IM.ITEMDESC)) AS ItemDescription
   ,ecItems.[extended_desc] AS ExtendedDesc
   ,CAST(ecItems.Featured AS BIT) AS Featured
   ,cat.category_name AS CategoryName
   ,CASE IM.PRICMTHD
        WHEN 1 THEN IV.UOMPRICE
        WHEN 2 THEN IV.UOMPRICE * IC.LISTPRCE / 100
        WHEN 3 THEN (IM.CURRCOST) * (1 + (IV.UOMPRICE / 100))
        WHEN 4 THEN (IM.STNDCOST) * (1 + (IV.UOMPRICE / 100))
        WHEN 5 THEN (IM.CURRCOST) / (1 - (IV.UOMPRICE / 100))
        WHEN 6 THEN (IM.STNDCOST) / (1 - (IV.UOMPRICE / 100))
        ELSE 0
    END AS Price
   ,IQ.QTYONHND AS QtyOnHand
   ,CAST(cat.[metadata1_active] AS BIT) AS [Metadata1Active]
   ,cat.[metadata1_name] AS [Metadata1Name]
   ,ecItems.[metadata1] AS [Metadata1]

   ...

   ,CAST(cat.[metadata20_active] AS BIT) AS [Metadata20Active]
   ,cat.[metadata20_name] AS [Metadata20Name]
   ,ecItems.[Metadata20] AS [Metadata20]
   ,C.CUSTNMBR AS CustomerNumber
FROM dbo.RM00101 AS C
LEFT OUTER JOIN dbo.IV00108 AS IV
    ON C.PRCLEVEL = IV.PRCLEVEL
LEFT OUTER JOIN dbo.IV00101 AS IM
    ON IM.ITEMNMBR = IV.ITEMNMBR
LEFT OUTER JOIN dbo.IV00102 AS IQ
    ON IQ.ITEMNMBR = IV.ITEMNMBR
        AND IQ.RCRDTYPE = 1
LEFT OUTER JOIN dbo.IV00105 AS IC
    ON IC.ITEMNMBR = IV.ITEMNMBR
        AND IV.CURNCYID = IC.CURNCYID
LEFT OUTER JOIN dbo.bma_ec_items AS ecItems
    ON ecItems.ITEMNMBR = IV.ITEMNMBR
LEFT OUTER JOIN dbo.bma_ec_item_category AS icat
    ON icat.ITEMNMBR = IV.ITEMNMBR
LEFT OUTER JOIN dbo.bma_ec_categories AS cat
    ON cat.category_id = icat.category_id
WHERE (IM.ITEMNMBR IN (SELECT
        ITEMNMBR
    FROM dbo.bma_ec_items
    WHERE (display_on_ecommerce = 1))
)
GO

PRE

I followed all the recommendations from RedGate's Sql Prompt (Modified my view to the one recommended change):

MID

SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO

ALTER VIEW [cp].[GetEcommerceItemsView]
AS
SELECT
    RTRIM(LTRIM(IV.ITEMNMBR)) AS ItemNumber
   ,RTRIM(LTRIM(IM.ITEMDESC)) AS ItemDescription
   ,ecItems.[extended_desc] AS ExtendedDesc
   ,CAST(ecItems.Featured AS BIT) AS Featured
   ,cat.category_name AS CategoryName
   ,CASE IM.PRICMTHD
        WHEN 1 THEN IV.UOMPRICE
        WHEN 2 THEN IV.UOMPRICE * IC.LISTPRCE / 100
        WHEN 3 THEN (IM.CURRCOST) * (1 + (IV.UOMPRICE / 100))
        WHEN 4 THEN (IM.STNDCOST) * (1 + (IV.UOMPRICE / 100))
        WHEN 5 THEN (IM.CURRCOST) / (1 - (IV.UOMPRICE / 100))
        WHEN 6 THEN (IM.STNDCOST) / (1 - (IV.UOMPRICE / 100))
        ELSE 0
    END AS Price
   ,IQ.QTYONHND AS QtyOnHand
   ,CAST(cat.[metadata1_active] AS BIT) AS [Metadata1Active]
   ,cat.[metadata1_name] AS [Metadata1Name]
   ,ecItems.[metadata1] AS [Metadata1]

   ...   

   ,CAST(cat.[metadata20_active] AS BIT) AS [Metadata20Active]
   ,cat.[metadata20_name] AS [Metadata20Name]
   ,ecItems.[Metadata20] AS [Metadata20]
   ,C.CUSTNMBR AS CustomerNumber
FROM dbo.RM00101 AS C
LEFT OUTER JOIN dbo.IV00108 AS IV
    ON C.PRCLEVEL = IV.PRCLEVEL
LEFT OUTER JOIN dbo.IV00101 AS IM
    ON IM.ITEMNMBR = IV.ITEMNMBR
LEFT OUTER JOIN dbo.IV00102 AS IQ
    ON IQ.ITEMNMBR = IV.ITEMNMBR
        AND IQ.RCRDTYPE = 1
LEFT OUTER JOIN dbo.IV00105 AS IC
    ON IC.ITEMNMBR = IV.ITEMNMBR
        AND IV.CURNCYID = IC.CURNCYID
LEFT OUTER JOIN dbo.bma_ec_items AS ecItems
    ON ecItems.ITEMNMBR = IV.ITEMNMBR 
    AND ecItems.display_on_ecommerce = 1
LEFT OUTER JOIN dbo.bma_ec_item_category AS icat
    ON icat.ITEMNMBR = IV.ITEMNMBR
LEFT OUTER JOIN dbo.bma_ec_categories AS cat
    ON cat.category_id = icat.category_id
GO



POST

Re-Ran the the tuning advisor and applied those Index creations. Then I switched to System.Text.Json from Newtonsoft.Json as my serializer in the Asp.net Core project. Re-Ran my Bench-Mark test:

I guess this is optimized as it gets, unless I switch to Dapper.

<strong>UPDATE</strong>

To be fair to @iSR5, I discovered I had a typo in my username I was using to get the Authorization Token. I corrected it and re-ran the test:

SUBMITTED

expandoObject.DynamicUpdate

PRE

But this line is executed after resolving <code>newElement</code> and <code>oldElement</code>.
Let's fix it!

See <a href="https://github.com/vlova/CodeReviewPatchJson265739/commit/c193f61c8cc901970fddd46118bb95849d4c9858#diff-e8c9f036b174ca0668defb35667f7482834224e2e14492830e893dcd2be29159" rel="nofollow noreferrer">diff</a>

So, you built extension over <code>IDictionary&lt;string, object&gt;</code>.
But your code assumes that nested objects will be of type JsonElement.
What if we will use your code over Newtonsoft.Json deserializer?
What if we will use your code over JsonConverter which performs nested deserialization of ExpandObject (like DynamicJsonConverter in <a href="https://www.codetd.com/en/article/8462216" rel="nofollow noreferrer">https://www.codetd.com/en/article/8462216</a>)?

Well, your code will fail in runtime. This is really bad for you.

Instead public instances of this method should accept either <code>JsonDocument</code> or <code>string</code> and return updated content. As we don't know required parsing options, it's better to accept <code>JsonDocument</code>.

We will return <code>IDictionary&lt;string, object&gt;</code> from <code>DynamicUpdate</code>. Maybe it's not totally good idea, because ExpandoObject will contain JsonElements inside — and this is not something that we will expect to see in IDictionary. But I'm afraid that we will do too much work in case if we will choose to return <code>JsonDocument</code> or <code>string</code>.

By this we also made version of method without side-effects - and this is much way better than previous.

By this we also can simplify contents of <code>GetNewValue</code>.

See <a href="https://github.com/vlova/CodeReviewPatchJson265739/commit/c8ac91834f633179c1f6ab45bb143b812c4f4ed5#diff-e8c9f036b174ca0668defb35667f7482834224e2e14492830e893dcd2be29159" rel="nofollow noreferrer">diff</a>

I'm not going to provide code for it. Probably you already know that your implementation doesn't works with arrays properly.

MID

DynamicUpdate

POST

SUBMITTED

bisect

EvenFibSum = int
Limit = int

PE_002_LIMIT = 4 * 10 ** 6

# fmt: off

PRE

I can't comment on your algorithm, but your code seems very readable from my perspective. Just a few small comments:

<strong>1. Type aliases</strong>

These two lines confused me at first:

MID

EvenFibSum = int
Limit = int


POST

After I read further down, it became clear that the purpose of these two lines was to create type aliases for clearer annotations. However, you could maybe consider adding a comment above these two lines to explain what's going on. Alternatively, consider using <code>typing.Annotated</code> or <code>typing.NewType</code>. (Personally, I'm a fan of <code>typing.Annotated</code>.)

For example, perhaps:

SUBMITTED

var length

PRE

MID

length

POST

SUBMITTED

return f&quot;{self.structure}, len={self.len}&quot;


def make_IEP(intersect: Intersection, cardinality: Cardinality) -&gt; Type[IEP]:
    &quot;&quot;&quot;Creates an IEP class with a fixed intersect and cardinality&quot;&quot;&quot;

    class IEP(ConstructorIEP):
        def __init__(self, structure: Structure):
            self.intersect = intersect
            self.cardinality = cardinality
            self.structure = structure

    return IEP


def inclusion_exclusion_principle(
    structure_of_objects: list[Structure],
    intersection_: Intersection,
    cardinality_: Cardinality,
    cache: bool = False,
) -&gt; int:
    &quot;&quot;&quot;If structure_of_objects = [A, B, C, ...] this function returns |A U B U C U ...|

    The return value is calculated using the exclusion

PRE

Your str dunder should call <code>__len__</code> not lookup <code>len</code>.
Makes your code more Pythonic and allows subclasses to follow Python's idioms and still have the code work fine.

<code>make_IEP</code>

I think the function should be a class builder on <code>ConstructorIEP</code>.

I'm not a fan of <code>self.intersect = intersect</code>.
Bind the method to the class not the instance.

MID

@classmethod
def build_type(cls, intersect: Intersection, cardinality: Cardinality) -&gt; Type[IEP]:
    &quot;&quot;&quot;Creates an IEP class with a fixed intersect and cardinality&quot;&quot;&quot;

    class IEP(ConstructorIEP):
        intersect = staticmethod(intersect)
        cardinality = staticmethod(cardinality)

        def __init__(self, structure: Structure):
            self.structure = structure

    return IEP


POST

<code>inclusion_exclusion_principle</code> (not a full review)

<code>intersection_</code> should be <code>intersection</code> and <code>intersection</code> should be <code>intersection_</code>.
A user of your function couldn't care less what the internal names of your function are, but <em>do</em> care about having sensible argument names.

Why have you defined <code>IEP</code> again and not used <code>make_IEP</code>?

I'm no mathematician so I'm going to stop here.

Overall my answer is mostly nitpicks or somewhat trivial tidbits. Good code.

SUBMITTED

def f

PRE

MID

f

POST

SUBMITTED

int min2 = stoi(s2.substr(3,2));
    
    if(((hour1*60)+min1)&gt;=((hour2*60)+min2)){
        return true;
    }
    return false;
}

int difftime(string s1,string

PRE

The use of <code>std::pair</code> is not terrible here, but it would be easier to understand the code if, instead of the somewhat cryptic <code>first</code> and <code>second</code> data items that <code>std::pair</code> provides, we could use <code>starttime</code> and <code>endtime</code>.  Also the use of <code>b1</code>, <code>p1</code>, etc. are not at all descriptive and should be replaced with more meaningful names.  Also <code>comparator</code> is very vague.  I'd probably change the sense and call it <code>IsLessThan</code>.  But we can do better as I'll show later.

The last lines of <code>comparator()</code> are these:

MID

if(((hour1*60)+min1)&gt;=((hour2*60)+min2)){
        return true;
}
return false;


We can simplify that by using the expression evaluation directly:

return hour1 * 60 + min1 &gt;= hour2 * 60 + min2;


POST

SUBMITTED

li=0;
      path_rate_t most = {malloc(sizeof(char)*PATH_ALLOC_SIZE), 0};
      path_rate_t buf = {malloc(sizeof(char)*PATH_ALLOC_SIZE), 1};

      while(fscanf(dbfp, &quot;%zu,%s&quot;, &amp;buf.freq, buf

PRE

Don't use all-caps for things that are not macros - that unnecessarily panics readers.

MID

  path_rate_t most = {malloc(sizeof(char)*PATH_ALLOC_SIZE), 0};
  path_rate_t buf = {malloc(sizeof(char)*PATH_ALLOC_SIZE), 1};


POST

<code>sizeof (char)</code> can only be 1, so the multiplication is pointless.

SUBMITTED

var tooltip

PRE

MID

var

POST

You should prefer to make all variables <a href="https://tc39.es/ecma262/#sec-let-and-const-declarations" rel="nofollow noreferrer"><code>const</code></a> as much as possible. Only if you absolute must mutate the binding, and there is no way around it, may you use <code>let</code>. Never use <a href="https://tc39.es/ecma262/#sec-variable-statement" rel="nofollow noreferrer"><code>var</code></a>. It is simply a vestige of a bad decision made early on in the language design and cannot be removed because of backwards-compatibility. You should just pretend it never existed.

So, <code>tooltip</code> should be a <code>const</code>, not a <code>var</code>.

SUBMITTED

gt;= waitingTimes)
        {
            return false;
        }
        Thread.Sleep(1000);
        count++;
    }
    return true;
}

private static bool IsElementExists(IWebDriver driver, string xpath)
{
    try
    {
        var element = driver.FindElement(By.XPath(xpath));
        return true;
    }
    catch (Exception ex)
    {
        log.Info(ex.Message);
    }
    return false

PRE

MID

private static bool DoesElementExist(IWebDriver driver, string elementXPath)
{
    try
    {
        _ = driver.FindElement(By.XPath(elementXPath));
        return true;
    }
    catch (NoSuchElementException ex)
    {
        log.Info(ex.Message);
        return false;
    } 
}


POST

SUBMITTED

Christoffel_d = Tensor('partial derivative of Christoffel symbol',
                       'Gamma', '__*_**,*', [])
Riemann = Tensor('Riemann curvature tensor', 'R', '__*_***', [])
Ricci = Tensor('Ricci curvature tensor', 'R', '_**', [])
Einstein = Tensor('Einstein tensor', 'G', '_**', [])
Einstein_alt = Tensor('Einstein tensor', 'G', '__*_*', [])

# user inputs metric:
g = eye(n)
while True:
    diag = str(input('Is metric diagonal? y for yes, n for no\n')).lower()
    if diag == 'y':
        for i in range(n):
            g[i, i] = sympify(fix_input(str(input(
                'What is g_[%s%s]?\n' % (str(coords[i]), str(coords[i])
                )))))
    else:
        for i in range(n):
            for j in range(i, n):
                g[i, j] = sympify(fix_input(str(input(
                    'What is g_[%s%s]?\n' % (str(coords[i]), str(coords[j])
                    )))))
                g[j, i] = g[i, j]
    if g.det() == 0:
        print('\nMetric is singular, try again!\n')
        continue
    else:
        break

# calculate everything:
# inverse metric:
g_inv = MutableDenseNDimArray(g.inv())
assign(metric_inv, g_inv)
g = MutableDenseNDimArray(g)
assign(metric, g)
# first derivatives of metric components:
g_d = metric_d.tensor_zeros()
for i in range(n):
    for j in range(i):
        for d in range(n):
            g_d[i, j, d] = g_d[j, i, d]
    for j in range(i, n):
        for

PRE

This could become one function <code>def clean_coordinates(coordinates)</code>. And same for the rest of the code.

MID

g = eye(n)
while True:
    diag = str(input('Is metric diagonal? y for yes, n for no\n')).lower()
    if diag == 'y':
        for i in range(n):
            g[i, i] = sympify(fix_input(str(input(
                'What is g_[%s%s]?\n' % (str(coords[i]), str(coords[i])
                )))))
    else:
        for i in range(n):
            for j in range(i, n):
                g[i, j] = sympify(fix_input(str(input(
                    'What is g_[%s%s]?\n' % (str(coords[i]), str(coords[j])
                    )))))
                g[j, i] = g[i, j]
    if g.det() == 0:
        print('\nMetric is singular, try again!\n')
        continue
    else:
        break


POST

SUBMITTED

pro_cond_var.notify_one();

            pro_mutex.unlock();
        }
    }
}

void net_thread() {
    while (true) {
        // receives data from socket and pushes into net_list queue

        Data data(&quot;A&quot;, &quot;Hello, world!&quot;);
        net_mutex.lock();

        net_list.emplace_back(data); // first copy
        net_cond_var.notify_one();

        net_mutex

PRE

It is generally more efficient to call <a href="https://en.cppreference.com/w/cpp/thread/condition_variable/notify_one" rel="nofollow noreferrer"><code>notify_one()</code></a> without the mutex being locked, otherwise the notified thread could be woken and immediately attempt to lock the still locked mutex as well.

Your <code>main()</code> function calls <code>join()</code> on all the threads it started, which is good, but unfortunately this means it will wait forever, since the threads themselves never return. In a real application you want to be able to terminate those threads gracefully. This requires waking up the threads that are blocked on <code>cond_var.wait()</code>, and having some way to signal that they should exit their loop, either using a separate flag, or by pushing a special item to the queue that signals that they should exit their loop.

I see you call <code>net_mutex.lock()</code> and <code>net_mutex.unlock()</code> in your code, but it's safer to use <code>std::lock_guard()</code>. You can limit the scope of the lock by using braces, like so:

MID

Data data(&quot;A&quot;, &quot;Hello, world!&quot;);

{
    std::lock_guard lock(net_mutex);
    net_list.emplace_back(data);
}

net_cond_var.notify_one();


POST

SUBMITTED

def plot_returns

PRE

MID

plot_returns

POST

SUBMITTED

return r.m_value &lt;= r.m_stop;
    }

    friend range begin(range r) { return r; }
    friend

PRE

Alright, here’s where things really get messy. These are not view operations, these are iterator operations. For a view, all you need is <code>begin()</code> and <code>end()</code>. <code>std::view_interface</code> is smart enough to check the view’s iterator type, and deduce the properties of the view from there. You would automatically get <code>empty()</code>, <code>size()</code>, <code>front()</code>, and <code>operator[]</code>, and others, if possible.

Assuming these functions were in an iterator type, there are still dragons here that you need to be aware of.

Let’s say <code>IntType</code> is a 16-bit unsigned type, so the values range from 0 to 65,535. Let’s assume someone did <code>range{0, 50'000, 40'000}</code>. Now you’d expect this to give you 0, 40,000, and then that’s it, right? What you’re going to get is: 0, 40,000, 14,464. Why? Because you are not taking overflow into account.

<em>This</em> is why <code>std::ranges::iota_view</code> doesn’t have a customizable step. It opens to the door to a whole host of complications.

MID

    friend range begin(range r) { return r; }


POST

This is the clearest sign of the problem with your design. Can you imagine if <code>std::vector&lt;T&gt;::begin()</code> returned a <em>copy of the vector</em>?

This is not a bad idea: a version of <code>std::ranges::iota_view</code> that has a variable step could be useful.

There are a few hurdles you have to overcome, though.

SUBMITTED

void) ecs;
        intro_text.destroy();
    
    };
    
    void update(const Time::Duration&amp; timestep) override {
        
        (void) timestep

PRE

Having a set of <code>State</code> objects take care of whether the main menu should be shown or decide what phase of the game you are in is an interesting inversion of control. It might have some advantages, but it is quite unusual, and it has some issues. For example, now your game loop is always the same regardless of the state; even if you are just in the main menu, you will update the time and the physics. What if you have a pause menu, and while paused no physics should be updated? This is not possible in your current implementation unless you modify <code>Game::run()</code> to somehow detect that the game is paused, adding coupling that I think you wanted to avoid. Although you could move some of that to <code>State::Play::update()</code>.

I also wonder why you have <code>State::Machine</code> manages a vector of states itself. Why not just let EnTT manage those states for you?

I see you write <code>(void) argument</code> to avoid the compiler from producing warnings about unused arguments. However, a better way to do this is to not give the function argument a name, like so:

MID

void update(const Time::Duration&amp;) override {}


POST

I see you write a semicolon after function definitions and even after some <code>if</code>-statements that are using curly braces. This is not necessary, and some compilers might also warn about them.

I knew this was going to be the response when I posted it all [...] The rest is for my brain.

It might make you more comfortable to have written wrappers that feel exactly like you want them to, and perhaps you also added those unnecessary semicolons because you feel it's more natural or symmetric, but it might be a problem for others that want to contribute to your code, as well as adding a lot of maintenance overhead for yourself. In the long run it might better if you just use the standard and external libraries as intended by their authors.

SUBMITTED

order.insert

PRE

MID

insert()

POST

Instead of:

SUBMITTED

def for_id

PRE

MID

for_id()

POST

SUBMITTED

z-sprite

PRE

MID

sprite

POST

SUBMITTED

if(target==0) return 1;
    if(dp[i][target]!=-1) return dp[i][target];
    return dp[i][target]=(solve(i,target-arr[i])%M+solve(i+1,target)%M)%M;
}

int main(){
    int n,target;
    cin&gt;&gt;n&gt;&gt;target;
    arr.resize(n);
    dp.resize(n+1,vector&lt;int&gt;(target+1,-1));
    for(int i=0;i&lt;n;++i){
        cin&gt;&gt;arr[i];
    }
    cout&lt;&lt;solve(0,target

PRE

First, once again there are cryptic names. <code>arr</code>? Really? What is <code>arr</code>? What does it mean? What is it used for? What values does it hold? Pirates?

This vector holds the values of the coins. So… why not call it <code>coin_values</code>?

Second, <a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#i2-avoid-non-const-global-variables" rel="noreferrer">there’s no reason these should be global variables</a>. Global variables are evil for a number of reasons: they are less efficient, they make code harder to understand (and thus, more likely to be buggy), they make code harder to test (and you <em>are</em> testing your code, aren’t you?), and—in this case—they limit your design options (which I’ll explain in a bit).

And finally, as a general rule, whenever you see a vector-of-vectors… that’s usually a sign of a bad design. There are <em>some</em> situations where a vector-of-vectors makes sense, but virtually all uses you see in the wild are wrong. This usage? Seems very wrong.

MID

int solve(int i,int target){
    if(i&gt;=(int)arr.size()) return 0;
    if(target&lt;0) return 0;
    if(target==0) return 1;
    if(dp[i][target]!=-1) return dp[i][target];
    return dp[i][target]=(solve(i,target-arr[i])%M+solve(i+1,target)%M)%M;
}


Okay, now we get to the meat of the problem.

My first complaint is that there’s not a single comment in the code. This is not acceptable in real code. A code reviewer should not have to reverse-engineer your code to figure out what it’s doing. When I see code with no comments like this, I usually don’t even bother to examine it; I just stamp it “fail”, and move on. You don’t need to explain each and every single line and operation, but you should <em>at least</em> explain the <em>logic</em> of what the function is supposed to be doing. The function’s name is “solve”. Solve what? How? The arguments are “i” and “target”. What are those supposed to be? I mean, I can deduce “target” is the value you want to “solve” for… but what the hell is “i”? That doesn’t even come from the problem; that’s an artifact of your particular solution, so it can only make sense to you.

My second complaint is that the code is almost illegible because it’s so tightly packed together. Use some whitespace! Spread things out a bit! You have <em>five</em> different exit points in this function, but that’s hard to see without carefully examining every line of the code. That’s terrible; it’s <em>begging</em> for bugs to be hidden in the code.

(I strongly suspect that the reason no one else has tried to review this code has to do with the fact that it’s impossible to read, and has not a single comment explaining it. Nobody wants to do a forensic deconstruction of someone’s code just to review it.)

So, first thing I’m going to do, for my own sanity, is spread the function out a bit, and then use better identifiers.

int solve(int i, int target)
{
    if (i &gt;= (int)arr.size())
        return 0;

    if (target &lt; 0)
        return 0;

    if (target == 0)
        return 1;

    if (dp[i][target] != -1)
        return dp[i][target];

    return dp[i][target] = (solve(i, target - arr[i]) % M + solve(i + 1, target) % M) % M;
}


Okay, let’s deal with those globals and the poorly named constant:

int solve(int i, int target, std::vector&lt;int&gt; const&amp; coin_values, std::vector&lt;std::vector&lt;int&gt;&gt; const&amp; dp)
{
    if (i &gt;= (int)coin_values.size())
        return 0;

    if (target &lt; 0)
        return 0;

    if (target == 0)
        return 1;

    if (dp[i][target] != -1)
        return dp[i][target];

    return dp[i][target] = (
        solve(i, target - coin_values[i], coin_values, dp) % result_modulo
            + solve(i + 1, target, coin_values, dp) % result_modulo)
        % result_modulo;
}


POST

Now we need to fix the types. As mentioned earlier, the portable range of <code>int</code> is −32,767 to 32,767 (C++20: −32,768 to 32,767), but the target range is from 0 to 1,000,000. So <code>target</code> can’t be an <code>int</code>. It needs to be a <code>long</code>. The same goes for the coin values.

And then there’s <code>i</code>. What is <code>i</code>? No idea, because there’s no comment explaining it, so I have to guess. It <em>looks</em> like it is supposed to be an index into the coin values array. In C++ indices are unsigned types (I know, that’s not great, but that’s what we’re stuck with). In particular, it should be <code>std::vector&lt;int&gt;::size_type</code>.

So this is probably what the function parameters should be more like:

SUBMITTED

target

PRE

MID

target = 1

POST

SUBMITTED

target

PRE

MID

target = 9

POST

Not really all that much. Granted, this is a small case, but still. Given the <em>incredible</em> costs of your memoization scheme, it’s clearly not worth it.

The worst part is that there should be no need for memoization at all. The only reason you have to consider recalculating the same scenario is because of the way you are doing the calculations. Look at the outline above: once you have figured out “2+2+2=6” and know the remainder is “3”, you throw that information away. Later, on a completely separate path, you discover 6-remainder-3 again, this time via “3+3”. The memoization saves you some extra cycles there, but it shouldn’t be necessary.

I would suggest rethinking the problem. Rather than working your way through the coins from smallest to largest, do the opposite. Go from largest to smallest. The reason is that if you are starting from the smallest coin, then at the top of your recursion you have more possibilities than if you’d started from the largest coin. If you start with 2, then you have to find the coins that sum up to 7… whereas if you start with 5, you only have to find the coins that sum up 4… which will be a much smaller set.

For example:

See how much smaller it is than the version that goes from smallest coin to largest? Note also that there is no need for memoization, because we don’t consider smaller coins until the last.

(Indeed, a possible optimization is to note when we get to the last coin, we can just do <code>return ((remainder % coin) == 0) ? 1 : 0;</code> (or <code>return not(remainder % coin);</code> if you want to be “clever”). If the remainder is not divisible by the coin value, then it can’t be made up of those coins.)

Another neat feature of doing it this way is that it is easily parallelizable. You could create a sensible number of threads, and then start each top level coin calculation in a different thread.

With these changes, memoization looses its lustre even further. That means those <em>huge</em> allocations become pointless.

Finally, as a matter of principle, you should write better structured code. Your program basically does three things:

That means your <code>main()</code> function should be something like:

SUBMITTED

pathlib import Path


class

PRE

MID

pathlib.Path

POST

SUBMITTED

for (let p = 0; p &lt; wordList.length; p++) {
  const word

PRE

Rather than use a <code>for(;;)</code> loop use a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of" rel="nofollow noreferrer" title="MDN JavaScript statement  reference. for...of">for...of</a>  loop as you dont need the idx <code>p</code> for anything but indexing the word array.

MID

for (const word of wordList) {


POST

You don't need the comments as what is happening is obvious in the code.

You can combine the get and set into one expression by using the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing_operator" rel="nofollow noreferrer" title="MDN JavaScript operator reference. Nullish coalescing operator">?? (Nullish coalescing operator)</a> to check for undefined.

SUBMITTED

gt; {
      if (command !== prevCommand) {
        const items = syncFunc(allowedTags, command);
        setItems(items);
      }
      return command

PRE

Use effect requires a second parameter, the list of dependencies for the effect.

This effect declares that you want to re-compute the items state when command is updated.

MID

useEffect(() =&gt; {
        const items = syncFunc(allowedTags, command);
        setItems(items);
  }, [command]);


POST

All the code you have to check if the dependency had updated is actually the sole purpose of the <code>useEffect</code> function. Simply give it some dependencies and it will check every render if those dependencies have been updated.

SUBMITTED

write(file

PRE

MID

file

POST

SUBMITTED

list()
        pass

PRE

MID

pass

POST

SUBMITTED

int newEntry)
{
   Node *temporary;
   temporary = new Node;
   temporary -&gt; data = newEntry;
   temporary -&gt; next = nullptr;

   if

PRE

The lines

MID

  temporary -&gt; data = newEntry;
  temporary -&gt; next = nullptr;


POST

scream to be in the <code>Node</code> constructor.

An introductory comment to <code>add</code> is misleading. It claims that the method returns <code>false</code> on a failure to add. I don't see it returning <code>false</code>. I also don't see the possibility of a failure, unless <code>new Node</code> throws a <code>bad_alloc</code>, but then all bets are off anyway.

<code>remove</code> and <code>contains</code> (especially <code>MTFList::contains</code>) share a lot of functionality. You be in a better shape having a helper method, say <code>Node * detach</code>. Consider

SUBMITTED

gt; icons;
    
    public void paint(Graphics graphics) {
        for (int i = 0; i &lt; nRows; i++)
            for (int j = 0; j &lt; nCols; j++)
            {
                Image currentCellImage=null;
                switch(minefield[i][j].state)
                {      
                    case COVERED: { // cell is covered
                        currentCellImage = icons

PRE

<strong>Note:</strong> one thing was astounding me: you did the oop approach on your method <code>Cell.isCovered()</code>. but here you violated the naming convention, the method does not return waht is expected: it has some hidden logic inside. that's no good idea, the method name should be adjusted to properly express the behaviour.

<strong>example:Cell iteration</strong>

MID

for (int i = 0; i &lt; nRows; i++){
    for (int j = 0; j &lt; nCols; j++){
        currentCell=minefield[i][j];
    }
}


POST

since you use this code quite often, you should consider using a more proper type of data<br>
<code>Set&lt;Cell&gt; minefield</code> maybe (or a map), and instead of accessing the array directly(see <code>Locaction</code>) you could get Cells with a proper method: getCellAt(Location location).

SUBMITTED

group);
        if

PRE

MID

if ()

POST

SUBMITTED

counter,counter1

PRE

MID

counter1

POST

SUBMITTED

can do this but added as a support for sstrings!
    printf(&quot;Length of a: %d\n\n&quot;,sstrlen(a)); // Or printf(&quot;Length of a: %d\n\n&quot;,strlen(a)); &lt;- from string.h same thing!
    
    //-=-=- Sstrfind() -=-=-
    //lets find space
    int

PRE

<strong>Bug 2</strong>

<code>fgets(_tmp,GLOBAL_MAX_CHAR_LIMIT,stdin);</code> does not have the return value checked, so following code lacks knowing if <code>_tmp</code> is in fact a <em>string</em>.

<strong>Bug 3</strong>

Wrong printf specifier for <code>size_t</code> --&gt; undefined behavior.

MID

// printf(&quot;Length of a: %d\n\n&quot;,sstrlen(a));
printf(&quot;Length of a: %zu\n\n&quot;, sstrlen(a));


POST

Also with code like <code>for(int i=0;i&lt;sstrlen(show);i++){</code>, a well enabled compiler would have warned.

This, not fully using your compiler's warnings is the biggest mistake.

<strong>Underestimating FP</strong>

&quot;conversion from string to number [double/float/int] type is easily possible ...&quot;

I look forward to seeing that <em>easy</em> code.  I suspect it will have unexpected weaknesses.

<strong>Compile Error Check</strong>

The <code>isGMCLCorrupt()</code> test deserves to be a <code>_Static_assert()</code> compile time test.

<strong>Missing use of <code>const</code></strong>

<code>const</code> allows greater optimization and wider use.

SUBMITTED

sOMCache])

Point

PRE

I liked the fact that you used the <code>sum()</code> builtin function, but I have no idea what <code>sOM</code> or <code>sOMCache</code> mean in <code>sOM = sum([int(x) for x in sOMCache])</code> — &quot;Sum of marks&quot;, maybe?  But the capitalization is weird by <a href="https://www.python.org/dev/peps/pep-0008/" rel="nofollow noreferrer">Python standards</a>, and this isn't a cache — you wouldn't just eject data from this &quot;cache&quot;, would you?

I think, as you probably suspected, that you missed the mark for this exercise.  The main issues with your solution are:

MID

Point

POST

SUBMITTED

run(std::vector&lt;std::string&gt;(argv + 1, argv + argc));
        }
        catch (std::exception err)
        {
            std::cerr &lt;&lt

PRE

<code>arg</code> is already a <code>std::string</code>, so we could just <code>throw std::runtime_error(&quot;Error: invalid instruction: &quot; + arg);</code>. Even if it wasn't, we could use <code>std::to_string(arg)</code> instead of a<strike>n evil</strike> <code>stringstream</code>.

MID

std::vector&lt;std::string&gt;(argv + 1, argv + argc)


POST

Again, if we used <code>std::vector&lt;std::string_view&gt;</code> we can avoid the copies here.

SUBMITTED

int y

PRE

MID

y

POST

SUBMITTED

gt;
          {dates.map((weatherDate, index) =&gt; {
            if (
              index === 0 ||
              weather[weatherDate].length &lt; 4
            ) {
              return null;
            }
            return weather[weatherDate] &amp

PRE

Sometimes you just don't care about the first <code>n</code> elements of an array.

MID

dates.map((weatherDate, index) =&gt; {
    if (
        index === 0
    ) {
        return null;
    }
    /* ... */
);


POST

You could check the index in every iteration and return <code>null</code> in iteration zero, but, again, <em>what if we could skip rendering that item completely?</em>

In some languages there's a function called <code>skip</code> or <code>drop</code>, and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice" rel="nofollow noreferrer">in javascript we have <code>Array.slice</code></a>. Since you used slice in your code, you might already know how it works so you might want to <em>skip</em> over the next codeblock.

With <code>slice</code> you can skip some elements from the start of an array, and optionally drop some from its end:

SUBMITTED

BigInteger;
import java.util.*;
import java

PRE

MID

import java.util.*;

POST

